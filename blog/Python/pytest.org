#+TITLE:       pytest
#+AUTHOR:      pinvon
#+EMAIL:       pinvon@t480
#+DATE:        2019-03-26 二

#+URI:         /blog/Python/%y/%m/%d/%t/ Or /blog/Python/%t/
#+TAGS:        Python
#+DESCRIPTION: <Add description here>

#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 快速入门

** 安装

#+BEGIN_EXAMPLE
pip install pytest
#+END_EXAMPLE

** 测试

*** 成功

#+BEGIN_EXAMPLE
def test_passing():
    assert (1, 2, 3) == (1, 2, 3)

$ pytest test.py
...
test.py .
#+END_EXAMPLE
. 表示测试成功

*** 失败

#+BEGIN_EXAMPLE
def test_failing():
    assert (1, 2, 3) == (3, 2, 1)

$ pytest test.py
...
test.py F
...
#+END_EXAMPLE
F 表示测试失败

* 测试

** assert

最基础的工具, 进行条件判断.

** 捕获异常

在测试时, 经常需要测试是否如期抛出预期的异常, 以确定异常处理模块生效. 使用 pytest.raises() 进行异常捕获.
#+BEGIN_EXAMPLE
def test_raises():
    with pytest.raises(TypeError) as e:
        connect('localhost', '6379')
    exec_msg = e.value.args[0]
    assert exec_msg == 'port type must be int'
#+END_EXAMPLE

** 标记函数

pytest 会查找当前目录下所有以 test 开头或结尾的 py 文件, 执行文件内所有以 test 开头或结尾的方法. 如果某个方法尚未完成, 可以用以下方法指明不执行该方法:

1 使用 :: 显示指定函数名
#+BEGIN_EXAMPLE
pytest test.py::test_func1
#+END_EXAMPLE
这样只会执行 test_func1().

2 使用 -k 模糊匹配
#+BEGIN_EXAMPLE
pytest -k func1 test.py
#+END_EXAMPLE
只执行 test.py 中包含 func1 字眼的方法.

3 使用 pytest.mark 在函数上进行标记
#+BEGIN_EXAMPLE
@pytest.mark.finished
def test_func1():
    assert 1 == 1

@pytest.mark.unfinished
def test_func2():
    assert 1 != 1
#+END_EXAMPLE
测试时使用 -m 选择标记的测试函数:
#+BEGIN_EXAMPLE
pytest -m finished test.py
#+END_EXAMPLE
使用 mark, 可以给每个函数打上不同的标记, 测试时指定只执行有该标记的方法.

还可以使用 pytest.mark.skip, 这样可以在 pytest 时不指定 -m 参数:
#+BEGIN_EXAMPLE
@pytest.mark.skip(reason='out-of-date api')
def test_connect():
    pass

$ pytest test.py
...
test.py s
#+END_EXAMPLE
s 表示跳过.

** 参数化

如果把测试用例都写在测试函数内部进行遍历, 会因为某组用例失败, 导致测试终止.

可以使用 pytest.mark.parametrize(argnames, argvalues) 进行参数化测试, 使得每组参数都独立执行一次.

校验用户密码的例子:
#+BEGIN_EXAMPLE
@pytest.mark.parametrize('user, passwd',
                         [('jack', 'abcdefgh'),
                          ('tom', 'a123456a')])
def test_passwd_md5(user, passwd):
    db = {
        'jack': 'e8dc4081b13434b45189a720b77b6818',
        'tom': '1702a132e769a623c1adb78353fc9503'
    }

    import hashlib

    assert hashlib.md5(passwd.encode()).hexdigest() == db[user]

$ pytest -v test.py
...
collected 2 items

tests/test-function/test_parametrize.py::test_passwd_md5[jack-abcdefgh] PASSED [ 50%]
tests/test-function/test_parametrize.py::test_passwd_md5[tom-a123456a] PASSED [100%]

========================== 2 passed in 0.04 seconds ===========================
#+END_EXAMPLE
记得要使用 -v 进行测试.

* 固件

概念: 固件是一些函数, pytest 会在执行测试函数之前或之后自动运行它们.

可以使用固件来做一些初始化工作和扫尾工作.

固件可以直接定义在各个测试脚本中, 但是更推荐写在 conftest.py 中进行集中管理.

** 预处理和后处理

pytest 使用 yield 将固件分成两部分, yield 之前的代码属于预处理, 之后的代码属于后处理.
#+BEGIN_EXAMPLE
@pytest.fixture()
def db():
    print('Connection successful')

    yield

    print('Connection closed')


def search_user(user_id):
    d = {
        '001': 'xiaoming'
    }
    return d[user_id]


def test_search(db):
    assert search_user('001') == 'xiaoming'

$ pytest -s test.py
============================= test session starts =============================
platform win32 -- Python 3.6.4, pytest-3.6.1, py-1.5.2, pluggy-0.6.0
rootdir: F:\self-repo\learning-pytest, inifile:
collected 1 item

tests\fixture\test_db.py Connection successful
.Connection closed


========================== 1 passed in 0.02 seconds ===========================
#+END_EXAMPLE
-s 参数可以阻止消息被吞

** 作用域

固件的 scope 可以声明固件的作用域, 可选项有:
1 function. 函数级, 每个测试函数都会执行一次固件;
2 class. 类级, 每个测试类都会执行一次;
3 module. 模块级, 每个模块执行一次;
4 session. 会话级, 每次测试执行一次.

#+BEGIN_EXAMPLE
@pytest.fixture(scope='function')
def func_scope():
    pass


@pytest.fixture(scope='module')
def mod_scope():
    pass


@pytest.fixture(scope='session')
def sess_scope():
    pass


@pytest.fixture(scope='class')
def class_scope():
    pass
#+END_EXAMPLE
使用方法: 作为测试函数的参数. 如:
#+BEGIN_EXAMPLE
def test_multi_scope(sess_scope, mod_scope, func_scope):
    pass
#+END_EXAMPLE

注意, 如果是类作用域, 需要使用 pytest.mark.usefixtures 来指定.
#+BEGIN_EXAMPLE
@pytest.mark.usefixtures('class_scope')
class TestClassScope:
    def test_1(self):
        pass

    def test_2(self):
        pass
#+END_EXAMPLE

** 自动执行固件

如果想让固件自动执行, 可以使用 autouse 参数.

下面两个自动计时固件, 一个用于统计函数运行时间(function 作用域), 一个用于计算测试总耗时(session 作用域)
