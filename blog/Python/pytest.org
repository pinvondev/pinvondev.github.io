#+TITLE:       pytest
#+AUTHOR:      pinvon
#+EMAIL:       pinvon@t480
#+DATE:        2019-03-26 二

#+URI:         /blog/Python/%y/%m/%d/%t/ Or /blog/Python/%t/
#+TAGS:        Python
#+DESCRIPTION: <Add description here>

#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 快速入门

** 安装

#+BEGIN_EXAMPLE
pip install pytest
#+END_EXAMPLE

** 测试

*** 成功

#+BEGIN_EXAMPLE
def test_passing():
    assert (1, 2, 3) == (1, 2, 3)

$ pytest test.py
...
test.py .
#+END_EXAMPLE
. 表示测试成功

*** 失败

#+BEGIN_EXAMPLE
def test_failing():
    assert (1, 2, 3) == (3, 2, 1)

$ pytest test.py
...
test.py F
...
#+END_EXAMPLE
F 表示测试失败

* 测试

** assert

最基础的工具, 进行条件判断.

** 捕获异常

在测试时, 经常需要测试是否如期抛出预期的异常, 以确定异常处理模块生效. 使用 pytest.raises() 进行异常捕获.
#+BEGIN_EXAMPLE
def test_raises():
    with pytest.raises(TypeError) as e:
        connect('localhost', '6379')
    exec_msg = e.value.args[0]
    assert exec_msg == 'port type must be int'
#+END_EXAMPLE

** 标记函数

pytest 会查找当前目录下所有以 test 开头或结尾的 py 文件, 执行文件内所有以 test 开头或结尾的方法. 如果某个方法尚未完成, 可以用以下方法指明不执行该方法:

1 使用 :: 显示指定函数名
#+BEGIN_EXAMPLE
pytest test.py::test_func1
#+END_EXAMPLE
这样只会执行 test_func1().

2 使用 -k 模糊匹配
#+BEGIN_EXAMPLE
pytest -k func1 test.py
#+END_EXAMPLE
只执行 test.py 中包含 func1 字眼的方法.

3 使用 pytest.mark 在函数上进行标记
#+BEGIN_EXAMPLE
@pytest.mark.finished
def test_func1():
    assert 1 == 1

@pytest.mark.unfinished
def test_func2():
    assert 1 != 1
#+END_EXAMPLE
测试时使用 -m 选择标记的测试函数:
#+BEGIN_EXAMPLE
pytest -m finished test.py
#+END_EXAMPLE
使用 mark, 可以给每个函数打上不同的标记, 测试时指定只执行有该标记的方法.

还可以使用 pytest.mark.skip, 这样可以在 pytest 时不指定 -m 参数:
#+BEGIN_EXAMPLE
@pytest.mark.skip(reason='out-of-date api')
def test_connect():
    pass

$ pytest test.py
...
test.py s
#+END_EXAMPLE
s 表示跳过.

** 参数化

如果把测试用例都写在测试函数内部进行遍历, 会因为某组用例失败, 导致测试终止.

可以使用 pytest.mark.parametrize(argnames, argvalues) 进行参数化测试, 使得每组参数都独立执行一次.

校验用户密码的例子:
#+BEGIN_EXAMPLE
@pytest.mark.parametrize('user, passwd',
                         [('jack', 'abcdefgh'),
                          ('tom', 'a123456a')])
def test_passwd_md5(user, passwd):
    db = {
        'jack': 'e8dc4081b13434b45189a720b77b6818',
        'tom': '1702a132e769a623c1adb78353fc9503'
    }

    import hashlib

    assert hashlib.md5(passwd.encode()).hexdigest() == db[user]

$ pytest -v test.py
...
collected 2 items

tests/test-function/test_parametrize.py::test_passwd_md5[jack-abcdefgh] PASSED [ 50%]
tests/test-function/test_parametrize.py::test_passwd_md5[tom-a123456a] PASSED [100%]

========================== 2 passed in 0.04 seconds ===========================
#+END_EXAMPLE
记得要使用 -v 进行测试.

* 固件

概念: 固件是一些函数, pytest 会在执行测试函数之前或之后自动运行它们.

可以使用固件来做一些初始化工作和扫尾工作.

固件可以直接定义在各个测试脚本中, 但是更推荐写在 conftest.py 中进行集中管理.

** 预处理和后处理

pytest 使用 yield 将固件分成两部分, yield 之前的代码属于预处理, 之后的代码属于后处理.
#+BEGIN_EXAMPLE
@pytest.fixture()
def db():
    print('Connection successful')

    yield

    print('Connection closed')


def search_user(user_id):
    d = {
        '001': 'xiaoming'
    }
    return d[user_id]


def test_search(db):
    assert search_user('001') == 'xiaoming'

$ pytest -s test.py
============================= test session starts =============================
platform win32 -- Python 3.6.4, pytest-3.6.1, py-1.5.2, pluggy-0.6.0
rootdir: F:\self-repo\learning-pytest, inifile:
collected 1 item

tests\fixture\test_db.py Connection successful
.Connection closed


========================== 1 passed in 0.02 seconds ===========================
#+END_EXAMPLE
-s 参数可以阻止消息被吞

=需要将 fixture 装饰的函数, 作为其他需要测试的函数的参数, 如 test_search() 里面, 需要有 db 参数=.

** 作用域

固件的 scope 可以声明固件的作用域, 可选项有:
- function. 函数级, 每个测试函数都会执行一次固件;
- class. 类级, 每个测试类都会执行一次;
- module. 模块级, 每个模块执行一次;
- session. 会话级, 每次测试执行一次.

#+BEGIN_EXAMPLE
@pytest.fixture(scope='function')
def func_scope():
    pass


@pytest.fixture(scope='module')
def mod_scope():
    pass


@pytest.fixture(scope='session')
def sess_scope():
    pass


@pytest.fixture(scope='class')
def class_scope():
    pass
#+END_EXAMPLE
使用方法: 作为测试函数的参数. 如:
#+BEGIN_EXAMPLE
def test_multi_scope(sess_scope, mod_scope, func_scope):
    pass
#+END_EXAMPLE

注意, 如果是类作用域, 需要使用 pytest.mark.usefixtures 来指定.
#+BEGIN_EXAMPLE
@pytest.mark.usefixtures('class_scope')
class TestClassScope:
    def test_1(self):
        pass

    def test_2(self):
        pass
#+END_EXAMPLE

** 自动执行固件

如果想让固件自动执行, 可以使用 autouse 参数.

下面两个自动计时固件, 一个用于统计函数运行时间(function 作用域), 一个用于计算测试总耗时(session 作用域)

#+BEGIN_EXAMPLE
# test_autouse.py

DATE_FORMAT = '%Y-%m-%d %H:%M:%S'


@pytest.fixture(scope='session', autouse=True)
def timer_session_scope():
    start = time.time()
    print('\nstart: {}'.format(time.strftime(DATE_FORMAT, time.localtime(start))))

    yield

    finished = time.time()
    print('finished: {}'.format(time.strftime(DATE_FORMAT, time.localtime(finished))))
    print('Total time cost: {:.3f}s'.format(finished - start))


@pytest.fixture(autouse=True)
def timer_function_scope():
    start = time.time()
    yield
    print(' Time cost: {:.3f}s'.format(time.time() - start))


def test_1():
    time.sleep(1)


def test_2():
    time.sleep(2)
#+END_EXAMPLE
注意, test_1() 和 test_2() 都没有使用参数, 但 timer_session_scope() 和 timer_function_scope() 都会执行.


** conftest.py

如果多个测试文件都要用到同一个功能(如登录), 可以将这个功能写到 conftest.py 文件中, 其他用法仍然不变. 使用 conftest.py 需要注意以下几点:
- conftest.py 名称固定, 不能修改;
- conftest.py 与其他测试文件在同一个 package 下, 有 __init__.py 文件;
- 不需要 import 导入 conftest.py, pytest 会自己查找.

如:

__init__.py: 空

conftest.py
#+BEGIN_EXAMPLE
import pytest


@pytest.fixture()
def db():
    print("connect successful")

    yield

    print("connect closed")
#+END_EXAMPLE

test_fix.py
#+BEGIN_EXAMPLE
import pytest


def test_passing(db):
    assert (1, 2, 3) == (1, 2, 3)
#+END_EXAMPLE

* pytest-cov

pytest-cov是自动检测测试覆盖率的一个插件.

安装:
#+BEGIN_EXAMPLE
pip3 install pytest-cov
#+END_EXAMPLE

使用:
#+BEGIN_EXAMPLE
pytest --cov=module_name

或

pytest --cov=./
#+END_EXAMPLE
module_name 是自己的测试模块名.

** .coveragerc

如果直接执行 pytest --cov=./ 会把所有的文件都跑一遍, 有时候我们不需要显示所有文件的覆盖率, 可以通过配置文件来忽略一些文件.

在 package 根目录下新建一个 .coveragerc 文件, 内容形如:
#+BEGIN_EXAMPLE
[run]
omit=
  test_api.py
#+END_EXAMPLE

执行时指定配置文件:
#+BEGIN_EXAMPLE
pytest --cov=./ --cov-config ./.coveragerc
#+END_EXAMPLE
这样就会忽略 test_api.py 文件.

生成 html 格式的测试报告, 并放在 htmlcov 文件夹下:
#+BEGIN_EXAMPLE
pytest --cov=./ --cov-report=html test.py
#+END_EXAMPLE

如果想要自己定义文件夹的名称, 就改成: --cov-report=html:dirname

* 使用 allure 定制报告

#+BEGIN_EXAMPLE
pip3 install allure-pytest
#+END_EXAMPLE

生成 xml 报告:
#+BEGIN_EXAMPLE
pytest --cov=./ test_api.py --alluredir=./result/
#+END_EXAMPLE
