#+TITLE:       传输控制协议 TCP
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-05-30 三

#+URI:         /blog/Network/%y/%m/%d/%t/ Or /blog/Network/%t/
#+TAGS:        计算机网络
#+DESCRIPTION: <Add description here>

#+LANGUAGE:    en
#+OPTIONS:     H:4 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 概述

TCP 是面向连接的, 可靠的传输层协议.

TCP 有发送缓冲区和接收缓冲区, 保证服务器与客户端以不同的速度发送和接收数据. 通信的双方都拥有这两个缓冲区.

TCP 是全双工的, 数据能同时双向流动.

TCP 是可靠的, TCP 的报文中有确认序列号, 告诉发送端期望接收的下一个报文, 如果在规定时间内, 没有关于这个包的确认响应, 则重新发送此数据包.

* TCP 报文格式

[[./11.png]]

序列号: 保证了传送数据包的顺序. 在建立连接时, 双方用随机数产生初始序列号.

确认号: 接收端期望接收的序号. 当接收端收到序列号为 x 的报文后, 就把确认号定义为 x+1, 告诉发送端, 自己期望收到序列号为 x+1 的报文.

TCP 标志位:
- CWR: 拥塞窗口减小
- ECE: 经历拥塞回送
- URG: 紧急指针有效
- ACK: 确认字段值有效
- PSH: 推送数据
- RST: 连接必须复位
- SYN: 在连接建立时对序号进行同步
- FIN: 终止连接

校验和 = 伪首部 + TCP首部

* 三次握手

[[./12.png]]

1. 客户端发送 SYN 报文. SYN=1, seq=x.
2. 服务端发送 SYN+ACK 报文. SYN=1, ACK=1, seq=y, ack=x+1.
3. 客户端发送 ACK 报文. ACK=1, seq=x+1, ack=y+1.

* 四次挥手

[[./13.png]]

1. 客户端打算关闭连接, 发送 FIN 报文. FIN=1, seq=u. 这一步一般情况下也有 ACK, 因为连接建立之后, 两端收发数据的过程中, 一直都需要 ACK 来确认.
2. 服务端发送 ACK 报文. ACK=1, seq=v, ack=u+1. 此时, TCP 连接处于半关闭状态, 即客户端到服务端的连接已关闭, 但若服务端再向客户端发送数据, 客户端仍要接收.
3. 服务端没有数据要发送了, 就发送 FIN 报文. FIN=1, seq=w.
4. 客户端确认, 发送 ACK 报文. ACK=1, seq=z, ack=w+1. 此时, TCP 连接完全关闭.
