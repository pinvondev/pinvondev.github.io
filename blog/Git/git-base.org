#+TITLE:       Git基础
#+AUTHOR:      pinvon
#+EMAIL:       pinvon@t480
#+DATE:        2018-01-04 四

#+URI:         /blog/%y/%m/%d/git基础
#+TAGS:        Git
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 从远程更新到本地(多分支)

#+BEGIN_SRC shell
git fetch origin source # 从远程origin仓库的source分支下载代码到本地的origin/source分支
git diff source origin/source # 查看本地source分支和远程分支origin/source的差异
git merge origin/source # 将origin/source合并到当前分支
git log --graph --pretty=oneline --abbrev-commit  # git log --graph  可以查看分支合并图
#+END_SRC

也可以直接使用pull来更新
#+BEGIN_SRC shell
git pull --rebase origin source:source
#+END_SRC
但是这个方法老出冲突. 或者直接打乱了本地文件.

* 提交

在提交之前, 一定要先进行更新, 然后修改冲突之后再提交.

#+BEGIN_EXAMPLE
git push origin pinvon:pinvon  # 提交本地 pinvon 分支作为远程 pinvon 分支
git push origin :pinvon  # 删除远程 pinvon 分支
git push origin pinvon:master  # 提交本地 pinvon 分支作为远程 master 分支
#+END_EXAMPLE

如要提交失败, 并且配置是正确的, 则说明远程分支比本地的更新, 需要先合并. 如果 git pull 时提示 no tracking information, 说明本地分支没有与远程分支关联, 使用命令 git branch --set-upstream-to <branch-name> origin/<branch-name> 来关联, 也可以在创建本地分支的同时, 创建与远程分支的关联: git branch -b branch-name origin/branch-name.

在实际工作环境中, 比较少碰到这种问题, 因为每个人的分支会先统一规划好, 大家都往自己的分支上推送, 再通知主管来合并, 而不会直接推送一个新分支上去.

还有一种可用于实际工作环境中的方案:
- dev 分支公用
- 每个人有自己的分支, 可以直接 push
- 如果完成一个功能了, 切换到 dev 分支, 更新代码, 然后 merge 自己的分支, 解决冲突, push dev
- 由专人来将 dev 合并到 master

当主分支有更新时, 每个人需要将主分支的代码合并到自己的分支, 在自己的分支下执行命令: git merge master.

分支和标签的区别: 标签是固定的, 分支是会向前移动的.

** 冲突

冲突的内容在 <<<< >>>> 之间; =等号= 上方的是本地内容, 下方是远程内容.

* 撤销

#+BEGIN_SRC shell
git reflog source # 查看source的历史

# 如果需要详细的时间
git reflog source --relative-date

git reset --hard commid_id
#+END_SRC

* 添加远程库

** 创建SSH Key
#+BEGIN_SRC Shell
ssh-keygen -t rsa -C "your@email.com"
#+END_SRC
将公钥的内容复制到[[https://www.github.com][Github]]的SSH Keys里面.

** 创建仓库

到[[https://www.github.com][Github]]创建一个远程仓库. 然后在本地创建一个本地仓库.

** 关联仓库

将本地仓库与远程仓库关联: =git remote add origin git@github.com:path/to/repo.git=.

** 一台电脑, 多个Github账号

1. 生成两对私钥/公钥, 并且密钥文件名不能重复. 

此处假设已有一对密钥, 再生成另一对密钥.
#+BEGIN_SRC Shell
ssh-keygen -t rsa -f ~/.ssh/id_rsa_x -C "your@email.com"
#+END_SRC
这样就会生成 =id_rsa_x= 和 =id_rsa_x.pub= 两个文件.

2. 推送到远程时, 区分不同Github账号, 推送到相应的仓库.

- 在 =~/.ssh/= 下创建一个 =config= 文件并编辑:
#+BEGIN_SRC Shell
# 第一个账号
Host github.com
HostName github.com
User git
IdentityFile ~/.ssh/id_rsa

# 第二个账号
Host second.github.com  # second为前缀名, 可任意设置
HostName github.com
User git
IdentityFile ~/.ssh/id_rsa_x
#+END_SRC
注: =@= 前的 =git= 是User, =@= 后的 =github.com= 是Host. 如果User和Host都一样, 则无法区分多个账号, 所以要分别配置每个User和Host, 再对Host解析到HostName.

- 清空本地的SSH缓存, 添加新的SSH密钥到SSH agent中:
#+BEGIN_SRC Shell
ssh-add -D
ssh-add id_rsa
ssh-add id_rsa_x
ssh-add -l  #  确认新密钥是否添加成功

#  测试
ssh -T git@github.com
ssh -T git@second.github.com
#+END_SRC

- 配置完成后, 取消git全局设置:
#+BEGIN_SRC Shell
git config --global --unset user.name
git config --global --unset user.email

# 单独设置
git config user.email "your@email"
git config user.name "name"

# 查看git项目的配置
git config --list
#+END_SRC

如果要关联到第2个账号, 使用 =git remote add origin git@second.github.com:path/to/repo.git=. 
* 暂存

场景: 在项目上的某个分支工作了一段时间, 但是并未完成, 此时需要切换到另一分支, 而我们又不想仅因为过会儿回到这一点而为做了一半的工作创建一次提交. 此时, 就需要用到命令 =git stash=.

=git stash= 会将未完成的修改保存到一个栈上, 我们可以在任何时候重新应用这些改动.

*** 暂存

#+BEGIN_SRC Shell
git stash
#+END_SRC
此时, 如果使用 =git status= 命令查看, 会发现工作目录是干净的.

=git stash list= 可以查看有哪些东西被暂存了.

*** 取出

#+BEGIN_SRC Shell
git stash apply  # 取出最近被暂存的内容, 但是不删除 stash 内容, 通过 git stash list 仍可看到该内容
git stash pop  # 取出暂存内容的同时, 删除 stash 内容
git stash apply stash@{2}  # 取出指定的更旧的暂存内容
#+END_SRC

* 删除分支

** 查看分支

#+BEGIN_SRC Shell
// 查看本地分支
git branch

// 查看远程分支
git branch -r

// 查看所有分支
git branch -a
#+END_SRC

** 删除本地分支

#+BEGIN_SRC Shell
git branch -d xxx
#+END_SRC

** 删除远程分支

#+BEGIN_SRC Shell
git push origin :xxx
#+END_SRC

* 配置免密钥后仍要输入用户名密码

将 .git/config 中的 https://www.github.com/pinvondev/project.git 改成 git@github.com:pinvondev/project.git 即可.
* Git 基本配置

查看所有配置信息: git config --help

Git 配置文件有三种:
#+BEGIN_EXAMPLE
/etc/gitconfig  # 使用 --system 来配置, 对系统上的所有用户生效
~/.gitconfig  # 使用 --global 来配置, 对当前用户生效
.git/config  # 只对当前 git 项目生效
#+END_EXAMPLE
检查顺序从上往下, 生效以最后的为准.

** core.editor

使用 core.editor 来指定默认编辑器.
#+BEGIN_EXAMPLE
git config --global core.editor "emacs -nw"
#+END_EXAMPLE

** commit.template

.git_template:
#+BEGIN_EXAMPLE
# <类型>: (类型的值见下面描述) <主题> (最多50个字)

# 解释为什么要做这些改动
# |<----  请限制每行最多72个字   ---->|

# 提供相关文章和其它资源的链接和关键字
# 例如: Github issue #23

# --- 提交 结束 ---
# 类型值包含
#    feat : 新功能
#    fix : 修复bug
#    docs : 文档改变
#    style : 代码格式改变
#    refactor : 某个已有功能重构
#    perf : 性能优化
#    test : 增加测试
#    build : 改变了build工具 如 grunt换成了 npm
#    revert : 撤销上一次的 commit
#    chore : 构建过程或辅助工具的变动
# --------------------
# 注意
#    主题和内容以一个空行分隔
#    主题限制为最大50个字
#    主题行大写
#    主题行结束不用标点
#    主题行使用祈使名
#    内容每行72个字
#    内容用于解释为什么和是什么,而不是怎么做
#    内容多行时以'-'分隔
# --------------------
# 模板更多信息详见下面地址
# https://gist.github.com/adeekshith/cd4c95a064977cdc6c50
#+END_EXAMPLE

执行命令:
#+BEGIN_EXAMPLE
git config commit.template .git_template
#+END_EXAMPLE

提交时, 使用 git commit, 然后填写模板即可.
* git merge 与 git rebase 区别

首先是 git merge. 假设当前在 dev 分支:
#+BEGIN_EXAMPLE
            master
            |
C0 &larr; C1 &larr; C3
      
      C2
      |
      dev

git merge master  # 将 dev 分支合并到 master 分支

C0 --> C1 --> C3
       |
       C2 --> 
#+END_EXAMPLE
