#+TITLE:       Fabric官方安全first-network
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-03-28 三
#+URI:         /blog/%y/%m/%d/fabric官方安全first-network
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        BlockChain
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 准备

*** 下载源代码

#+BEGIN_SRC Shell
git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples

# 如果想切换到其他版本, 则输入以下命令. 我直接使用主分支的版本, 因此不切换
git checkout {TAG}
#+END_SRC

** 下载工具

想要运行这里的官方案例, 需要准备一些工具. 你可以使用脚本下载, 如果编译过Fabric的, 也可以选另一种方式, 因为如果编译过, 已经有很多镜像文件了, 不需要使用脚本重新下载.

*** 使用脚本下载

可以直接执行以下命令:
#+BEGIN_SRC Shell
# 能翻墙
curl -sSL https://goo.gl/6wtTN5 | bash -s 1.1.0

# 不能翻墙
curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/master/scripts/bootstrap.sh | bash -s 1.1.0
#+END_SRC

也可以直接到这个网站, 将脚本复制下来, 放在 =fabric-samples= 根目录下的 =bootstrap.sh= 中, 这个文件要自己创建.
#+BEGIN_SRC Shell
# 让其可执行
chmod +x ./bootstrap.sh
./bootstrap.sh
#+END_SRC

*** 编译过Fabric的

如果有根据[[https://pinvondev.github.io/blog/2018/03/25/hyperledger/][编译]]所说的进行编译过, 可以先打开 =bootstrap.sh=, 在里面查找 =dockerFabricPull()= 方法, 将该方法以后(包括该方法)的内容全部注释. 添加两句:
#+BEGIN_SRC Shell
echo ${ARCH}
echo ${VERSION}
./bootstrap.sh
#+END_SRC
查看输出, 根据输出的信息用浏览器到以下两个网站去下载. (终端的curl太慢了)

https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/

https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/

下载完后解压到 =fabric-samples/bin/= 目录下, 如果没有 =bin目录=, 则创建一个. 这里的工具, 有几个也可以在 =fabric/build/docker/bin= 里面找到, 直接复制过去也行.



* 一键运行

#+BEGIN_SRC Shell
cd first-network

# 生成配置
./byfn.sh -m generate

# 启动网络
./byfn.sh -m up

# 关闭网络
./byfn.sh -m down
#+END_SRC
如果成功, 可以看到类似下面两个图中的内容.

[[./9.png]]

[[./10.png]]


* 手动运行

*** cryptogen工具

cryptogen工具为网络节点生成证书信息(x509证书). 这些证书是节点身份的代表, 它们使得我们可以在网络中交易时进行签名/验证身份.

cryptogen工具根据 =crypto-config.yaml= 文件里的配置进行工具, 这个文件包含了网络拓扑, 并且使得我们可以为Organizations和属于Organizations的节点生成证书与密钥. 每个Organization都有唯一的根证书(ca-cert), 它将组件(peers, orders)绑定到Organization. 通过为每个Organization颁发唯一的CA证书, 我们可以模仿一个典型的区块链网络, 这个网络中的成员将使用自己的数字证书获取授权. Hyperledger Fabric中的交易和通信, 都是通过存储在 =keystore= 中的实体的私钥签名, 然后使用公钥进行身份验证.

去掉 =crypto-config.yaml= 中的注释部分, 可以清楚地看清其内容.
#+BEGIN_SRC Shell
sed '/#/d' crypto-config.yaml > cryp.yaml
emacs cryp.yaml
#+END_SRC
可以看到, 里面的内容如下:

[[./11.png]]

=crypto-config.yaml= 中的 =count= 表示Organization中的 =peer= 的数量.

还要注意 OrdererOrgs 下的 Name, Domain, Specs 这些字段. 网络实体的命名规则为: {Hostname}.{Domain}

因此, Orderer节点的命名为 orderer.example.com, MSP ID为Orderer.

使用 =cryptogen= 生成的数字证书和密钥信息保存在 =crypto-config= 文件夹中.

*** configtxgen工具(配置交易生成器)

configtxgen会生成4个配置信息:
1. orderer genesis block
2. channel configuration transaction
3. 两个 anchor peer transactions

其中, orderer block是Orderer Service的创世区块. Channel configuration transaction文件在Channel创建的时候广播给Order. Anchor peer transactions指定了每个Organization在此Channel上的代表节点.

configtxgen的配置文件是 =configtx.yaml=. 去掉其中的注释, 内容如下:

[[./18.png]]

内容很多, 只截取其中一部分.

该配置文件定义了3个成员: 一个Ordering Service组织(Organization) OrdererOrg, 两个节点组织 Org1 和 Org2, 每个组织由2个Peer组成. 每个组织还指定了Anchor Peer(peer0.org1.example.com和peer0.org2.example.com). 还为每个成员指定了MSP文件夹, 用来存储每个组织在orderer genesis block中指定的根证书, 有了这些证书, 任意和Ordering service通信的节点都可以对其数字签名进行验证.

*** 使用工具

其实怎么去使用这些工具, 在一键式脚本 =byfn.sh= 中都有写明. 如根据 =crypto-config.yaml= 中的配置来生成用于相关数字证书, 可以查看 =generateCerts()= 中的写法.

手动执行, 可加深了解.

创建数字证书:
#+BEGIN_SRC Shell
../bin/cryptogen generate --config=./crypto-config.yaml
#+END_SRC
生成的数字证书存放在 =crypto-config= 文件夹中.

生成Ordering Service的创世区块:
设置环境变量 =FABRIC_CFG_PATH=, 告诉configtxgen工具, 要到哪里去寻找配置文件 =configtx.yaml=:
#+BEGIN_SRC Shell
export FABRIC_CFG_PATH=${PWD}
../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
#+END_SRC
这样, Ordering Service的创世区块就生成了, 放在 =channel-artifacts= 目录中.

创建Channel:
#+BEGIN_SRC Shell
export CHANNEL_NAME=mychannel
../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME 
#+END_SRC

创建Channel上Org1的anchor peer:
#+BEGIN_SRC Shell
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
#+END_SRC

创建Channel上Org2的anchor peer:
#+BEGIN_SRC Shell
../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
#+END_SRC

到此为止, 我们有了Channel, Org1, Org2, Org1的anchor peer, Org2的anchor peer
