#+TITLE:       部署
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-04-04 三
#+URI:         /blog/%y/%m/%d/部署
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        BlockChain
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 概述

[[https://github.com/olegabu/fabric-starter][源码]]

这些脚本文件可以用于部署一个区块链网络.

* 网络成员

1. Orderer组织: example.com
2. Peer组织1: a
3. Peer组织2: b
4. Peer组织3: c

通道:
common通道: 包含所有成员, 使用的chaincode在 =reference/= 目录下.
a-b通道, a-c通道, b-c通道: 使用的chaincode在 =relationship/= 目录下.

每个组织使用的容器, 以a组织为例:
peer0.a.example.com: 锚节点
peer1.a.example.com: a组织内另一个节点
ca.a.example.com: 发放证书机构Fabric-ca
api.a.example.com: Fabric-rest API 服务器
www.a.example.com: HTTP服务器, 在生成配置文件和启动阶段, 提供成员的证书
cli.a.example.com: 使用命令与节点交互

* 本地部署

有了 =api= 容器, 我们可以在浏览器中看到每个组织中的成员. 由于有三个组织, 我们把原本他们默认使用的4000端口分别映射成4000, 4001, 4002端口.

#+BEGIN_SRC Shell
./network.sh -m generate
#+END_SRC
该命令会生成所有成员的加密材料, Orderer的创世区块(genesis.block), Channel的配置文件(.tx). 

#+BEGIN_SRC Shell
./network.sh -m up
#+END_SRC
该命令会启动所有成员的容器.

在所有容器都启动完成之后, 启动浏览器通过Channel的管理员admin与该组织交互.
- org1 http://localhost:4000/admin
- org2 http://localhost:4001/admin
- org3 http://localhost:4002/admin

#+BEGIN_SRC Shell
./network.sh -m logs -m example.com
./network.sh -m logs -m a
./network.sh -m logs -m b
#+END_SRC

#+BEGIN_SRC Shell
./network.sh -m down
./network.sh -m clean
#+END_SRC

* 多机部署

部署每个成员的容器, 然后容器之间通过网络连接.

在多机环境下, 容器之间不能通过容器网络来连接, 而是使用真实的网络. 因此, 我们需要在 =network.sh= 文件中指定节点的真实IP地址, 或者通过环境变量来设置:
#+BEGIN_SRC Shell
export IP_ORDERER=54.235.3.243 IP1=54.235.3.231 IP2=54.235.3.232 IP3=54.235.3.233
#+END_SRC

每个成员在各自的主机上生成配置文件:
#+BEGIN_SRC Shell
./network.sh -m generate-peer -o a
./network.sh -m generate-peer -o b
./network.sh -m generate-peer -o c
#+END_SRC
在证书生成之后, 脚本会启动一个 =www docker= 来为其他成员提供服务: Orderer节点下载证书以创建账本, Peer节点下载证书以使用TLS保证通信安全.

然后使用Orderer节点通过从成员那边生成的证书来生成创世区块(genesis.block)和Channel的配置文件(.tx). 在Orderer所在主机执行:
#+BEGIN_SRC Shell
./network.sh -m generate-orderer
./network.sh -m up-orderer
#+END_SRC

当Orderer启动之后, 所有节点在各自主机上启动服务, 与Orderer通信, 创建Channel. 在Fabric中, 一个成员创建Channel, 然后其他成员通过 =channel.block= 来加入Channel. 创建Channel的成员使这些 =channel.block= 文件对通过 =www docker= 连接过来的其他成员有效. 启动Orderer的成员是很重要的, 特别是对那些两两成对的Channel的成员, 比如, Channel =a-b= 的成员 =a= 需要先启动, 创建 =channel.block=, 然后 =b= 才启动, 下载 =channel.block= 然后加入Channel.

每个组织在各自节点上启动成员:
#+BEGIN_SRC Shell
./network.sh -m up-1
./network.sh -m up-2
./network.sh -m up-3
#+END_SRC

* 配置文件

crypto工具使用 =cryptogentemplate-orderer.yaml & cryptogentemplate-peer.yaml= 生成成员的加密材料: 私钥与证书. 这两个配置文件对应官方示例中的 =cryptogen.yaml=.

configtx工具使用 =configtxtemplate.yaml= 生成启动Orderer所需的创世区块(genesis.block), 创建Channel所需的 =.tx=. 这个配置文件对应于官方示例中的 =configtx.yaml=.

API Server 和 Web应用程序使用 =network-config-template.json= 来连接成员的节点和CA.

每个成员组织启动docker容器, 使用 =docker-composetemplate-orderer.yaml & docker-composetemplate-peer.yaml=.

脚本使用 =cli= 容器来创建和加入Channel, 安装和初始化chaincode.

最后通过生成的 =docker-compose.yaml= 开始成员的服务.

* 自定义和扩展

通过编辑 =network.sh= 或设置环境变量, 可以自定义Orderer的名字和组织的名字, 如:
#+BEGIN_SRC Shell
export DOMAIN=myapp.com ORG1=bar ORG2=baz ORG3=foo
#+END_SRC

=common Channel= 包含哪些成员可以自定义, 如果要更改, 可以通过修改 =configtxtemplate.yaml= 这个文件.

组织内的成员数量也可以修改. 修改的位置在 =network.sh= 的 =iterateChannels()= 中.

* chaincode

在 =chaincode-dev= 模式下有一些与chaincode相关的命令, 该模式下, chaincode不是在容器内, 可以单独执行. Peer可以不安装chaincode, 但可以调用它.

在 =dev= 模式下, Channel叫做 =myc=, chaincode叫做 =mycc=, 当然, 我们也可以在 =network.sh= 中修改它们.

启动 =dev= 模式:
#+BEGIN_SRC Shell
./network.sh -m devup
./network.sh -m devinstall
#+END_SRC

设置环境变量:
#+BEGIN_SRC Shell
CORE_CHAINCODE_LOGGING_LEVEL=debug
CORE_PEER_ADDRESS=0.0.0.0:7051
CORE_CHAINCODE_ID_NAME=mycc:0
#+END_SRC

实例化, 调用, 查询:
#+BEGIN_SRC Shell
./network.sh -m devinstantiate
./network.sh -m devinvoke
./network.sh -m devquery
#+END_SRC

可以在不重新编译, 重启开发模式网络的情况下, 对chaincode进行修改, 重新测试.

关闭:
#+BEGIN_SRC Shell
./network.sh -m devdown
#+END_SRC
