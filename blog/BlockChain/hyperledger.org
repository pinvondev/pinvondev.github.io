#+TITLE:       Hyperledger
#+AUTHOR:      pinvon
#+EMAIL:       pinvon@ubuntu
#+DATE:        2018-03-25 日
#+URI:         /blog/%y/%m/%d/hyperledger
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        BlockChain
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 词汇表

***** Anchor Peer(锚节点)

锚节点是通道中能被所有对等节点探测, 并能与之进行通信的一种对等节点. 通道中的每个成员都有一个(或多个, 以防单点故障)锚节点, 允许属于不同成员身份的节点来发现通道中存在的其他节点.

注: 网络中的节点.

***** Block(区块)

在一个通道上, 区块是一组有序交易的集合. 区块往往通过密码学手段(Hash)连接到前一个区块.

***** Chain(链)

链就是区块经过"哈希连接"结构化的交易日志. 对等节点(peer)从共识服务(order service)接收区块, 并根据背书策略和并发冲突标记区块的交易是否有效, 然后将该区块追加到对等节点文件系统的哈希链上.

***** Chaincode(链码)

链码是一个运行在账本上的软件, 可以对资产进行编码, 其中的交易指令(或业务逻辑)也可以用来修改资产.

***** Channel(通道)

通道是构建在"Fabric"网络上的私有区块链, 实现了数据的隔离和保密. 通道特定的账本在通道中是与所有对等节点共享的, 并且交易方必须通过该通道的正确验证才能与账本进行交互. 通道是由一个配置块来定义的.

注: 有点像局部网络.

***** Commitment(提交)

一个通道中的每个对等节点都会验证交易的有序区块, 然后将区块提交(写或追加)到该通道上账本的各个副本, 对等节点也会标记每个区块中的每笔交易的状态是有效还是无效.

注: 采矿成功后, 增加新区块.

***** Concurrency Control Version Check(并发控制版本检查CCVC)

CCVC是保持通道中各对等节点状态同步的一种方法.

对等节点并行执行交易, 在交易提交到账本之前(将交易打包成区块添加到区块链之前), 对等节点会检查交易在执行期间读到的数据是否被修改. 执行后要提交, 在这两个事件之间如果数据被改动, 就会引发CCVC冲突, 该交易会被账本中标记为无效, 不会被写入区块链中.

***** Configuration Block(配置区块)

为系统链或通道定义成员和策略的配置数据. 对某个通道或整个网络的配置修改都将导致生成一个新的配置区块, 并追加到适当的链上.

***** Consensus(共识)

共识是贯穿整个交易流程的广义术语, 用于产生一个对于排序的同意书和确认构成区块的交易集的正确性.

***** Current State(当前状态)

ledger的当前状态表示其chain交易log中所有key的最新值.

***** Ordering Service(排序服务或共识服务)

Ordering Service独立于Peer, 以先到先得的方式为网络上所有的channel做交易排序, 包含与每个Member相关的加密材料.

Orderer为区块链写入操作提供时序保证, 具体实现可以是共识算法或分布式的消息订阅消费系统(kafka).

* 简介

** 分布式账本

去中心化: 在整个区块链网络中, 每个参与者都保存着一个区块链账本的副本.

协作: 所有参与者共同维护着账本.

不可篡改: 加密技术保证交易一旦写入账本, 就无法篡改. 不可篡改性使得信息来源的确认变得容易.

** 智能合约

区块链网络使用智能合约来实现对账本的访问和控制.

智能合约不仅可用于在区块链网络中打包信息, 还可以用于自动执行参与者定义的特定交易操作. 如, 买卖双方可以定义一个智能合约, 以保证当卖方发货的商品运送到达时, 买方支付的货款会自动转账给卖方.

** 共识

共识就是保持网络中所有账本交易的同步流程. 它保证了账本只会在交易双方都确认后才进行更新. 同时在账本更新时, 交易双方能够在账本中的相同位置, 更新一个相同的交易信息.

目前, 我们只需把区块链理解为一个共享的, 通过智能合约更新的多副本交易系统, 同时这个系统通过协作共识机制保证了网络中所有账本副本的同步.

** Hyperledger Fabric

2015年, Linux基金会启动了Hyperledger项目, 目标是发展跨行业的区块链技术. Hyperledger Fabric是Hyperledger的一个区块链项目.

Hyperledger Fabric需要登录才能加入网络.

通道功能: 允许参与者为交易新建一个单独的账本. 当网络中的一些参与者是竞争对手时, 这个功能尤为重要. 因为这些参与者并不希望所有的交易信息(如给部分客户优惠)都对网络中所有参与者公开. 只有在同一个通道中的参与者, 才会拥有该通道中的账本.

共享账本: Hyperledger Fabric的账本子系统包含世界状态和交易记录. 世界状态组件描述了账本在特定时间点的状态, 它是账本的数据库; 交易记录组件记录了产生世界状态当前值的所有交易, 它是世界状态的更新历史.

智能合约: 在Hyperledger Fabric中称为chaincode. 当一个区块链外部的应用程序需要访问账本时, 就会调用chaincode. 一般情况下, chaincode只会访问账本的世界状态, 不会查询交易记录. 目前使用Go编写chaincode.

* 快速入门

** 先决条件

在v1.0.0发行之前, 使用Ubuntu的Vagrant来作为开发环境. 而Docker容器可以为MacOS, Windows, Linux三个平台的开发人员提供一致的体验, 因此, 现在更推荐使用Docker容器进行开发环境的搭建.

本平台为Ubuntu 16.04LTS. 如果是其他系统, 请查看[[http://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html][官网的环境搭建]]

*** Git安装

*** Go语言

安装 Go 1.9 或者更后的版本.

首先到[[https://golang.org/dl/][官网]]下载压缩包. 最好选择稳定版本.

仅介绍Ubuntu 16.04TLS的安装, 其他环境的安装, 请参考[[https://golang.org/doc/install][官网的安装教程]]

#+BEGIN_SRC Shell
# 解压至/usr/local目录
sudo tar -C /usr/local -xzf go1.9.4.linux-amd64.tar.gz

# 打开配置
emacs ~/.bashrc

# 将 /usr/local/go/bin 添加到环境变量
export GOROOT=/usr/local/go
export GOPATH=$HOME/go # 配置GOPATH是为了后面需要
export PATH=$GOPATH/bin:$GOROOT/bin:$PATH

# 使配置生效
source ~/.bashrc
#+END_SRC

测试直接输入 =go=, 会有一些go命令的说明. 如果有异常, 说明没安装成功. 

也可以直接测试文件: 新建文件 test.go, 输入代码:
#+BEGIN_SRC GO
package main
import "fmt"
func main() {
	fmt.Println("hello world")
}
#+END_SRC

运行:
#+BEGIN_SRC Shell
go run test.go
#+END_SRC

如果出现"hello world", 则说明安装成功.


*** Docker

Docker是一个容器, 在这个容器中, 我们可以运行我们的实例. 可以把Docker大致当成一个虚拟机, 但是Docker不需要占用那么多空间.

每个Docker将在本地运行一个与Hyperledger网络相关的服务.

可以使用CLI或终端来安装Docker, 这边我们需要安装两个包: docker-engine和docker-compose.

docker-engine: 基础包, 它使得docker容器需要的所有必须的文件正常运行.

docker-compose: 用于配置Docker.

**** 添加Docker的APT源

#+BEGIN_SRC Shell
# 将官方Docker资源库的GPG密钥添加到系统
sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D

# 将Docker存储库添加到APT源
echo "deb https://apt.dockerproject.org/repo ubuntu-xenial main" | sudo tee /etc/apt/sources.list.d/docker.list

# 更新软件包数据库
sudo apt-get update

# 确保从Docker repo中安装
apt-cache policy docker-engine
#+END_SRC

**** 安装Docker

#+BEGIN_SRC Shell
sudo apt-get install -y docker-engine

# 开启docker服务
sudo service docker start

# 让docker服务开机自启动
sudo systemctl enable docker

# 如果要取消开机自动启动, 则输入
sudo systemctl disable docker

# 测试docker是否在运行
docker

# 使用pip安装docker-compose
sudo pip install docker-compose
#+END_SRC

关于Docker的安装, 到此结束.

默认情况下, 运行docker需要root权限, 也可以用安装docker的用户运行. 但是如果其他用户想要运行docker, 则会出错. 可以通过如下命令, 使用户有权限运行docker:
#+BEGIN_SRC Shell
sudo usermod -aG docker username
#+END_SRC

*** 安装Pip
** 安装Hyperledger Fabric

*** 创建GOPATH

#+BEGIN_SRC Shell
mkdir -p $GOPATH

cd $GOPATH
mkdir src
cd src
mkdir github.com
cd github.com
mkdir hyperledger
cd hyperledger
#+END_SRC

*** 获取Fabric源码

在hyperledger目录下, 执行如下命令:
#+BEGIN_SRC Shell
git clone https://github.com/hyperledger/fabric.git
#+END_SRC


*** 安装Go相关库

安装必要工具:
#+BEGIN_SRC Shell
sudo apt install libtool libltdl-dev
#+END_SRC

如果直接使用 =make docker=, 在国内会碰到许多错误, 比如编译golint时因为下载超时报错. 这是因为hyperledger fabric是使用go语言编写的, 需要依赖一些工具或者第三方库, 但是因为谷歌有些东西被墙了, 所以要自己手动下载并安装.
#+BEGIN_SRC Shell
mkdir -p $GOPATH/src/golang.org/x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/tools.git

# 下载完成后执行以下命令
go get github.com/kardianos/govendor
go get github.com/golang/lint/golint
go get golang.org/x/tools/cmd/goimports
go get github.com/onsi/ginkgo/ginkgo
go get github.com/axw/gocov/...
go get github.com/client9/misspell/cmd/misspell
go get github.com/AlekSi/gocov-xml
go get github.com/golang/protobuf/protoc-gen-go
#+END_SRC

如果出现如下问题:

[[./5.png]]

说明当前用户没有权限来运行docker. 执行以下语句:
#+BEGIN_SRC Shell
sudo usermod -aG docker $USER
# 重启
#+END_SRC
 
*** Orderer节点的编译

Orderer节点容器里面运行的是Orderer服务, 要想生成Orderer镜像, 就需要先编译出Orderer程序.
#+BEGIN_SRC Shell
make orderer
#+END_SRC

*** Peer节点的编译

Chaincode运行在Peer所在的机器上, 需要给Chaincode准备运行的基础环境, 即ccenv和javaenv两个镜像. 由于被墙, 需要先将之前go的工具拷贝进来.

#+BEGIN_SRC Shell
mkdir -p build/docker/gotools/bin/
cp $GOPATH/src/bin/* ./build/docker/gotools/bin/
make peer
#+END_SRC

成功之后显示如下:
[[./7.png]]


使用命令 =docker image= 可查看已安装的镜像文件.

现在, 可以进入 =example/e2e_cli=, 使用脚本, 一键启动程序.
#+BEGIN_SRC Shell
# 开启
./network_setup.sh up [channel-id is optional]

# 关闭
./network_setup.sh down
#+END_SRC

为了加快部署过程, hyperledger提供了一个脚本来执行所有任务. 该脚本会生成配置结果, 本地网络, Chaincode测试.

进入 =examples/e2e_cli= 目录, 从Docker Hub获取镜像:
#+BEGIN_SRC Shell
# 使脚本可执行
chmod +x download-dockerimages.sh

# 执行脚本
./download-dockerimages.sh
#+END_SRC

*** 编译Fabric工具

configtxgen工具用来配置Fabric的通道. 它的配置参数主要由 =configtx.yaml= 文件提供.

cryptogen工具可以快速地根据配置自动批量生成所需要的密钥及证书文件. 它的配置参数主要由 =crypto-config.yaml= 文件提供.

在 =fabric= 目录下, 编译 =configtxgen=:
#+BEGIN_SRC Shell
make configtxgen
#+END_SRC

如果出现下图所示的提示, 说明编译成功.
[[./3.png]]

编译后的执行文件放在 =fabric/build/bin/configtxgen=.

如果出现 =find: `/src/github.com/hyperledger/fabric/core/chaincode/shim': 没有那个文件或目录=, 说明 =GOPATH= 没有配置好, 或者配置了之后没有 =source ~/.bashrc=.

cryptogen工具的编译方式也一样:
#+BEGIN_SRC Shell
make cryptogen
#+END_SRC

编译 configtxlator:
#+BEGIN_SRC Shell
make configxlator
#+END_SRC

*** Docker镜像

前面只是生成了Fabric的二进制文件, 不能直接使用. 需要将这些文件打包到Docker镜像中.


#+BEGIN_SRC Shell
# 生成Orderer镜像
make orderer-docker

# 生成Peer镜像
make peer-docker

# fabric-tools镜像
make tools-docker

# 查看docker镜像文件
docker images
#+END_SRC

*** 其他Docker镜像

CouchDB做状态数据库, Kafka做共识, Zookeeper做Kafka的高可用支持. 直接使用以下命令生成:
#+BEGIN_SRC Shell
make docker
#+END_SRC

** 运行

configtxgen工具会生成两个内容: Orderer的bootstrap block和Fabric的channel configuration transaction.

orderer block: ordering服务的创世区块(第一个区块).

channel transaction: 在 create channel 时会被广播给orderer.

configtx.yaml: 给出网络的定义, 拓扑结构.

crypto-config目录: 包含每个实体的admin证书, ca证书, 签名证书, 私钥等.

generateArtifacts.sh: 该脚本自动为我们生成启动网络所需的配置及创世区块. 如果之前使用过 =network_setup.sh=, 则先将 =channel-artifact目录= 里的可见文件都删除, 隐藏文件不用删, 再将 =crypto-config= 目录直接删除.

生成通道的区块和配置:
#+BEGIN_SRC Shell
cd examples/e2e_cli
./generateArtifacts.sh 
#+END_SRC

成功后会有类似如下的输出:
[[./4.png]]

启动网络:
#+BEGIN_SRC 
cd examples/e2e_cli
./network_setup.sh up [channel-id-optional]
#+END_SRC

出现如下界面, 说明网络启动运行, 并测试成功:

[[./8.png]]

停止网络有两种方法:

第一种:
#+BEGIN_SRC Shell
# 新开一个终端, 进入examples/e2e_cli
rm -f $(docker ps -aq)

# 查看镜像
docker images

# 将dev-peerx.orgx.example字样的镜像文件删除
# 输入其image id的前6位
docker rmi -f 07032a eb54b1 a9ad47

# 删除配置结果
rm ./ channel-artifacts/*.tx
rm -rf crypto-config
#+END_SRC

第二种:
#+BEGIN_SRC Shell
./network_setup.sh down
# 该命令会自动删除启动网络时生成的镜像文件和配置文件
#+END_SRC

** 手动运行

之前是使用脚本一键启动, 关闭. 我们可以手动来做一遍, 这样就明白背后发生了什么事.

进入 =examples/e2e_cli= 目录.

打开 =docker-compose-cli.yaml=, 找到启动 =script.sh= 的语句, 注释掉.
#+BEGIN_SRC Shell
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    # command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT'
#+END_SRC

**** 启动网络

 #+BEGIN_SRC Shell
 docker-compose -f docker-compose-cli.yaml up
 #+END_SRC

**** 创建Channel

Channel在逻辑上将我们自己编写的Chaincode与其他的Chaincode区分开来.

进入Cli镜像:
#+BEGIN_SRC Shell
docker exec -it cli bash
#+END_SRC

仅以peer0节点为例, 修改环境变量:
#+BEGIN_SRC Shell

#+END_SRC
