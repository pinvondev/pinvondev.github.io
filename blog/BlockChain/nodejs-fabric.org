#+TITLE:       Node.js Fabric
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-04-03 二
#+URI:         /blog/%y/%m/%d/nodejs-fabric
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        BlockChain
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 概述

Hypeledger Fabric SDK for Node.js 提供了强大的API, 让我们与区块链进行交互. 使用这些API, 我们可以做到:
- 创建channels
- 将peer加入channel
- 在peer上安装chaincode
- 在channel上实例化chaincode
- 通过chaincode调用事务
- 查询账本

为了安全起见, 在Fabric中需要使用数字签名. 用户通过证书, 要对所有的Fabric请求进行签名(用户对请求进行签名, 再附上从CA获取的数字证书, Fabric使用CA的公钥解开数字证书, 拿到用户的公钥, 这样就能证明数字签名是否真的是用户签的). [[http://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#table-of-contents][关于Fabric CA]].

** fabric-client

- [[https://fabric-sdk-node.github.io/Client.html#createChannel][创建channel]]
- [[https://fabric-sdk-node.github.io/Channel.html#joinChannel][将peer加入channel]]
- [[https://fabric-sdk-node.github.io/Client.html#installChaincode][将chaincode安装到peer]]
- 在channel上实例化chaincode, 包括两步: [[https://fabric-sdk-node.github.io/Channel.html#sendInstantiateProposal][将提案发送到背书节点]] 和 [[https://fabric-sdk-node.github.io/Channel.html#sendTransaction][将提案回复发送到Orderer节点]]
- 提交事务, 包括两步: [[https://fabric-sdk-node.github.io/Channel.html#sendInstantiateProposal][将提案发送到背书节点]] 和 [[https://fabric-sdk-node.github.io/Channel.html#sendTransaction][将提案回复发送到Orderer节点]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryByChaincode][查询chaincode以获得最新的应用程序状态]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryInfo][查询其他的channel状态]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryBlock][查询块(通过number)]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryBlockByHash][查询块(通过hash)]]
- [[https://fabric-sdk-node.github.io/Client.html#queryChannels][peer属于哪些channel]]
- [[https://fabric-sdk-node.github.io/Client.html#queryInstalledChaincodes][peer上安装的所有chaincode]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryInstantiatedChaincodes][peer上实例化的所有chaincode]]
- [[https://fabric-sdk-node.github.io/Channel.html#queryTransaction][查询事务(通过id)]]
- [[https://fabric-sdk-node.github.io/Channel.html#getChannelConfig][channel的配置数据]]
- [[https://fabric-sdk-node.github.io/EventHub.html#connect][与peer事件建立联系]]
- [[https://fabric-sdk-node.github.io/EventHub.html#registerBlockEvent][监听块事件]]
- [[https://fabric-sdk-node.github.io/EventHub.html#registerTxEvent][监听交易事件以获知是否成功写入账本]]
- [[https://fabric-sdk-node.github.io/EventHub.html#registerChaincodeEvent][自定义一些由chaincode产生的事件]]
- [[https://fabric-sdk-node.github.io/User.html][序列化用户类(已经登记, 并由登记证书和签名密钥表示)]]
- 具有多层覆盖的分层配置设置: 文件, 环境变量, 程序参数, 内存中设置
- 内置的日志系统为winston, 也可以使用常用的log4j
- 可插入的CryptoSuite接口描述与Fabric成功交互所需的加密操作. 提供两种实现方式: [[https://fabric-sdk-node.github.io/CryptoSuite_ECDSA_AES.html][Software-based ECDSA]]和[[https://fabric-sdk-node.github.io/CryptoSuite_PKCS11.html][PKCS#11-compliant ECDSA]]
- 可插拔的状态存储接口, 用于保存诸如用户的状态缓存: [[https://fabric-sdk-node.github.io/FileKeyValueStore.html][存储到文件]]和[[https://fabric-sdk-node.github.io/CouchDBKeyValueStore.html][存储到CouchDB]]
- [[https://fabric-sdk-node.github.io/CryptoKeyStore.html][可自定义的加密密钥库]]
- 支持使用TLS(grpcs://)和非TLS(grcp://)与peer和orderer连接. 可查看[[https://fabric-sdk-node.github.io/Remote.html][Remote类]], 它是peers和orderers的父类.

** fabric-ca-client

- [[https://fabric-sdk-node.github.io/FabricCAServices.html#register][注册新用户]]
- [[https://fabric-sdk-node.github.io/FabricCAServices.html#enroll][登记一个用户, 获得Fabric CA签名的登记证书]]
- [[https://fabric-sdk-node.github.io/FabricCAServices.html#revoke][通过登记ID注销用户或注销某证书]]
- [[https://fabric-sdk-node.github.io/FabricCAServices.html][自定义持久化存储]]

* 配置应用程序开发环境

chaincode运行在服务器(背书节点), 客户端使用node.js编写.

** 开发环境组成

*** orderer

orderer节点的主要责任是共识. 那么, 为什么应用程序开发需要orderer?

因为orderer节点维护了整个网络的关键数据, 如: 哪些组织加入了, 哪些channel创建了, 哪个组织加入了哪个channel, 对网络的改变需要遵循哪些策略. 本质上来讲, ordering service掌握了整个网络.

*** peer

peer节点分两种: 背书节点和提交节点. 在配置文件中, 一个节点是否是背书节点, 需要自己配置. 而提交节点则无需配置, 因为所有的peer都是提交节点. 在实际环境中, 一个组织内的节点需要多个, 在开发阶段, 一个组织只配置一个节点, 这个节点既是背书节点, 又是提交节点. 它可以为提交的事务提案进行背书, 可以从账本中获得信息.

另外, peer还要将事件进行广播. 只要账本新增了区块, peer节点就会广播该事件, 组织内的所有应用都可以监听到它.

*** 身份

Hyperledger Fabric网络中的每个操作都必须进行数字签名, 以便进行访问控制. 在v1.0以后, 身份基于公钥基础设施(PKI)标准. 每个orderer, peer, 用户, 交易者都必须有密钥对, 其中公钥包含在CA签名的x.509证书里. 在开发阶段, 为了简便, 我们直接使用一些工具来生成证书.

另外, 还要确定是否要在项目中加入Fabric-CA. 它是一个具有REST API的服务器, 可以支持动态身份管理, 包括注册, 登记(获取证书), 撤销和重新注册, 所以在提供用户身份时非常有用. 注意, 以这种方式配置的身份只能是 =MEMBER=, 而不是 =ADMIN=.

=ADMIN= 可以创建/更新channel, 安装/实例化chaincode, 等等.

如果不需要Fabric-CA, 也没有什么关系, 不过应用程序需要管理用户的证书.

** 前提

*** Docker

*** Docker Compose

*** Nodejs(v6.2.0-6.10.0)

** 准备加密材料

身份由x.509证书建立. 我们涉及到很多身份证明:
- peer需要身份来注册背书
- orderer需要身份来生成交易区块, 然后供给提交节点验证与加入区块链
- 应用程序需要身份来生成交易请求
- Fabric CA需要身份, 这样它们的给证书的签名都能被验证

在开发阶段, 我们直接使用cryptogen工具来生成需要的密钥和证书.

cryptogen工具将自动为Fabric CA节点, orderer, peer生成身份, 这可以用来启动Fabric-CA服务器(如果要将Fabric CA作为项目的一部分). 另外, 它还会生成一个 =ADMIN=, 它具有特殊的操作权限. 最后, 它还生成用于提交交易的 =MEMBER=.

** 创世区块

我们需要使用创世区块来启动网络. 使用configtxgen工具来生成genesis.block.

** 启动网络

使用docker-compose来启动网络.

* 如何创建channel

** 步骤

- 使用configtxgen工具, 生成genesis.block
- 使用configtxgen工具, 生成 *.tx
- 获取channel的可签名的配置文件
- 使用fabric-client SDK注册channel的可签名的配置文件
- 使用fabric-client SDK将channel可签名配置文件和签名发给orderer
- 使用fabric-client SDK将peer加入到channel

** 使用*.tx构建可签名的channel配置


