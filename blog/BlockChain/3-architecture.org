#+TITLE:       三 Fabric架构
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-04-12 四
#+URI:         /blog/%y/%m/%d/三-fabric架构
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        BlockChain
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 架构

[[./34.png]]

在上层提供了标准的gRPC接口, 在API的基础上封装了不同语言的SDK.

区块链强一致性要求, 各个节点之间达成共识需要较长的执行时间, 也是采用异步通信的模式进行开发的, 事件模块可以在触发区块事件或者chaincode事件的时候执行预先定义的回调函数.

** 身份管理 

用户注册和登录系统后, 获取到用户注册证书(ECert). 后续的所有操作都要使用和用户证书相关联的私钥进行签名, 消息接收方首先会进行签名验证, 才进行后续的消息处理.

网络节点也会用到颁发的证书, 如系统启动和网络节点管理等, 都会对用户身份进行认证和授权.

** 账本管理

授权的用户是可以查询账本数据的, 可以通过多种方式查询, 包括根据区块号查询区块, 根据区块哈希查询区块, 根据交易号查询区块, 根据交易号查询交易, 根据channel名称获取查询到的区块链信息.

** 交易管理

=账本数据只能通过交易执行才能得到更新=, 应用程序通过交易管理提交交易提案(proposal), 并获取到交易背书(endorsement)后, 再给ordering service提交交易, 然后打包成区块. SDK提供接口, 利用用户证书本地生成交易号, 背书节点和记账节点都会校验是否存在重复交易.

** 智能合约

通过chaincode执行提交的交易, 实现基于区块链的智能合约业务逻辑. =只有智能合约都能更新账本数据, 其他模块不能直接修改状态数据(world state)=.

** 成员管理

MSP(Membership Service Provider)对成员管理进行了抽象, =一般来说, 一个组织对应一个MSP=, 每个MSP都会建立一套根信任证书体系, 利用PKI对成员身份进行认证, 验证成员用户提交请求的签名. 

MSP结合Fabric-CA或第三方CA系统, 提供成员注册功能, 并对成员身份证书进行管理(如新增, 撤销).

注册的证书分为登记证书(ECert), 交易证书(TCert), TLS证书, 它们分别用于用户身份确认, 交易签名, TLS传输.

** 共识服务

共识机制由3个阶段完成:
1. 客户端向背书节点提交提案, 进行背书签名
2. 客户端将背书后的交易提交给ordering service进行交易排序, 生成区块和排序服务
3. orderer将区块广播给记账节点验证交易, 然后写入本地账本

共识机制, 目的是为了实现同一个链上不同节点区块的一致性, 同时确保区块里的交易有效和有序.

** chaincode服务

chaincode的实现依赖于安全的执行环境, 确保安全的执行过程和用户数据的隔离.

Hyperledger Fabric采用Docker管理普通的chaincode.

** 安全和密码服务

Hyperledger Fabric专门定义了一个BCCSP(BlockChain Cryptographic Service Provider)来实现密钥生成, 哈希运算, 签名验证, 加密解密等基础功能. BCCSP是一个抽象的接口.

** 网络节点架构

节点是区块链的通信主体, 多个不同类型的节点(客户端, Peer, Orderer, CA)可以运行在同一物理服务器上.

如图所示:

[[./35.png]]

*** 客户端节点

客户端或者应用程序代表最终用户操作的实体, 它必须连接到某一个Peer或者Orderer上, 与区块链网络进行通信. 客户端向背书节点提交交易提案, 当收集到足够背书后, 向排序服务广播交易, 进行排序, 生成区块.

*** Peer节点

部分节点是背书节点, 对提案进行背书. 每个chaincode在实例化的时候都会设置背书策略, 指定哪些节点对提案进行背书.

所有Peer节点都是提交节点(Committer, 也有人称为记账节点), 负责验证从Orderer节点广播的区块里的交易, 维护状态数据和账本的副本.

主节点作为组织的代表, 和Orderer节点通信, 负责从Orderer节点获取最新的区块, 并在组织内同步. 主节点可以自己设置, 也可以动态选举产生.

*** Orderer节点

Orderer接收包含背书签名的交易, 对未打包的交易进行排序, 生成区块, 广播给Peer节点.

Ordering Service的multi-channel实现了多链的数据隔离, 保证只有同一个链的Peer节点都能访问链上的数据, 保护用户数据的隐私.

*** CA节点

CA节点是证书颁发机构, 有服务器和客户端. CA节点接收客户端的注册申请, 返回一次性密码用于用户登录, 以便获取身份证书.

在区块链网络上, 所有的操作都会验证用户的身份. CA节点是可选的, 可以用其他成熟的第三方CA颁发证书.

*** 交易流程

交易流程如下图所示:

[[./36.png]]

* 交易详情

** 创建交易提案并发送给背书节点

 客户端签名后的提案, 数据格式如下:
 #+BEGIN_SRC JSON
 SignedProposal:{
     ProposalBytes(Proposal):{
         Header:{
             ChannelHeader:{
                 Type:"HeaderType_ENDORSER_TRANSACTION",
                 TxID:TxId,
                 Timestamp:Timestamp,
                 ChannelId:ChannelId,
                 Extension(ChaincodeHeaderExtension):{
                     PayloadVisibility:PayloadVisibility,
                     ChaincodeId:{
                         Path:Path,
                         Name:Name,
                         Version:Version
                     }
                 },
                 Epoch:Epoch
             },
             SignatureHeader:{
                 Creator:Creator,
                 Nonce:Nonce
             }
         },
         Payload:{
             ChaincodeProposalPayload:{
                 Input(ChaincodeInvocationSpec):{
                     ChaincodeSpec:{
                         Type:Type,
                         ChaincodeId:{
                             Name:Name
                         },
                         Input(ChaincodeInput):{
                             Args:[]
                         }
                     }
                 },
                 TransientMap:TransientMap
             }
         }
     },
     Signature:Signature
 }
 #+END_SRC

 SignProposal = Proposal + Signature;
 Proposal = ChannelHeader + SignatureHeader

 背书节点会根据签名信息 =Signature= 验证其是否是一个有效的交易.

 ChannelHeader: 包含了channel和chaincode调用相关的信息, 如在哪个channel上调用哪个chaincode; TxID是客户端生成的交易号, 跟客户端的身份证书相关, 可以避免交易号的冲突, 背书节点和提交节点都会验证是否重复交易.

 SignatureHeader: 包含客户端的身份证书和一个随机数, 用于验证消息的有效性.

 客户端构造好交易提案请求, 选择背书节点并进行背书签名. 背书节点在背书策略中指定.

** 背书节点模拟交易并生成背书签名

背书节点收到交易提案后, 进行一些验证, 包括:
1. 交易提案的格式是否正确
2. 交易是否提交过
3. 交易签名是否有效(通过MSP)
4. 交易提案的提交者在当前channel是否已授权有写权限

验证通过后, 背书节点会根据当前账本数据, 模拟执行chaincode中的业务逻辑, 并生成 =读写集=, 但实际上并不更新账本数据. 然后背书节点对这些读写集进行签名, 成为提案响应(ProposalResponse), 返回给客户端.

ProposalResponse的结构如下:
#+BEGIN_SRC JSON
ProposalResponse:{
    Version:Version,
    Timestamp:Timestamp,
    Response:{
        Status:Status,
        Message:Message,
        Payload:Payload
    },
    Payload(ProposalResponsePayload):{
        ProposalHash:ProposalHash,
        Extension(ChaincodeAction):{
            Results(TxRwSet):{
                NsRwSets(NsRwSets):[
                    NameSpace:NameSpace,
                    KvRwSet:{
                        Reads(KVRead):[
                            Key:Key,
                            Version:{
                                BlockNum:BlockNum,
                                TxNum:TxNum
                            }
                        ],
                        RangeQueriesInfo(RangeQueriesInfo):[
                            StartKey:StartKey,
                            EndKey:EndKey,
                            ItrExhausted:ItrExhausted,
                            ReadsInfo:ReadsInfo
                        ],
                        Writes(KVWrite):[
                            Key:Key,
                            IsDelete:IsDelete,
                            Value:Value
                        ]
                    }
                ]
            },
            Events(ChaincodeEvent):{
                ChaincodeId:ChaincodeId,
                TxId:TxId,
                EventName:EventName,
                Payload:Payload
            }
            Response:{
                Status:Status,
                Message:Message,
                Payload:Payload
            },
            ChaincodeId:ChaincodeId
        }
    },
    Endorsement:{
        Endorser:Endorser,
        Signature:Signature
    }
}
#+END_SRC
