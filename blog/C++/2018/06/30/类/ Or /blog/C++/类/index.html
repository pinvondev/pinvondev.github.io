<!DOCTYPE html>
<html lang="en">
<head>
  <title>类 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="C++" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">类</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">类</a>
<ul>
<li><a href="#sec-1-1">类定义</a>
<ul>
<li><a href="#sec-1-1-1">考点</a></li>
</ul>
</li>
<li><a href="#sec-1-2">访问控制</a></li>
<li><a href="#sec-1-3">构造函数</a></li>
<li><a href="#sec-1-4">静态成员</a>
<ul>
<li><a href="#sec-1-4-1">考点</a></li>
</ul>
</li>
<li><a href="#sec-1-5">类对象的复制</a></li>
<li><a href="#sec-1-6">常量成员函数</a>
<ul>
<li><a href="#sec-1-6-1">强制类型转换</a></li>
<li><a href="#sec-1-6-2">mutable</a></li>
</ul>
</li>
<li><a href="#sec-1-7">自引用</a></li>
<li><a href="#sec-1-8">内联函数</a></li>
</ul>
</li>
<li><a href="#sec-2">设计一个日期类</a>
<ul>
<li><a href="#sec-2-1">声明</a></li>
<li><a href="#sec-2-2">定义</a></li>
<li><a href="#sec-2-3">具体的类</a></li>
</ul>
</li>
<li><a href="#sec-3">对象</a>
<ul>
<li><a href="#sec-3-1">析构函数</a></li>
<li><a href="#sec-3-2">默认构造函数</a></li>
<li><a href="#sec-3-3">构造和析构</a>
<ul>
<li><a href="#sec-3-3-1">局部对象</a>
<ul>
<li><a href="#sec-3-3-1-1">对象的复制</a></li>
</ul>
</li>
<li><a href="#sec-3-3-2">自由存储</a></li>
<li><a href="#sec-3-3-3">类对象作为成员</a>
<ul>
<li><a href="#sec-3-3-3-1">成员的复制</a></li>
</ul>
</li>
<li><a href="#sec-3-3-4">数组</a></li>
<li><a href="#sec-3-3-5">静态局部存储</a></li>
<li><a href="#sec-3-3-6">非局部存储</a></li>
<li><a href="#sec-3-3-7">临时对象</a></li>
<li><a href="#sec-3-3-8">对象的放置</a></li>
<li><a href="#sec-3-3-9">enum</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">派生类</a>
<ul>
<li><a href="#sec-4-1">引入</a></li>
<li><a href="#sec-4-2">成员函数</a></li>
<li><a href="#sec-4-3">构造函数和析构函数</a></li>
<li><a href="#sec-4-4">复制</a></li>
<li><a href="#sec-4-5">虚函数</a></li>
<li><a href="#sec-4-6">抽象类</a></li>
</ul>
</li>
<li><a href="#sec-5">类层次结构</a>
<ul>
<li><a href="#sec-5-1">多重继承</a></li>
<li><a href="#sec-5-2">虚基类</a></li>
<li><a href="#sec-5-3">访问控制</a></li>
<li><a href="#sec-5-4">运行时类型信息(RTTI, Run Time Type Information)</a>
<ul>
<li><a href="#sec-5-4-1">dynamic_cast</a></li>
<li><a href="#sec-5-4-2">static_cast</a></li>
<li><a href="#sec-5-4-3">类对象的构造和析构</a></li>
<li><a href="#sec-5-4-4">typeid 操作符</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">类</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">类定义</h3>
<div class="outline-text-3" id="text-1-1">
<p>
类定义的形式:
</p>
<div class="org-src-container">

<pre class="src src-C++">class X{ ... };
</pre>
</div>
<p>
一个类定义也常常说成类声明.
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">考点</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>在类定义时, 能否对对象直接初始化?
</li>
</ul>

<p>
不能. 因为在类定义时无法使用构造函数, 因此无法完成对象的初始化.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">访问控制</h3>
<div class="outline-text-3" id="text-1-2">
<p>
class 默认为 private 权限, struct 默认为 public 权限.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">构造函数</h3>
<div class="outline-text-3" id="text-1-3">
<p>
构造函数名与类名相同, 没有返回值, 支持重载.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">静态成员</h3>
<div class="outline-text-3" id="text-1-4">
<p>
静态成员只有唯一的副本, 不像其他成员, 在每个对象中都拥有一份副本. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Date{
    ...
    static Date default_date;
public:
    ...
    static void set_default(...){
        Date::default_date = Date(...);
    }
};
</pre>
</div>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">考点</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>一般数据类型, 静态数据类型的初始化时机.
</li>
</ul>

<p>
一般数据类型必须在类内进行初始化; 静态成员变量必须在类外初始化; 静态成员常量必须在类中初始化(常量在声明时初始化, 所以只能在类中).
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">类对象的复制</h3>
<div class="outline-text-3" id="text-1-5">
<p>
在定义时赋初值时, 调用的是拷贝构造函数; 先定义后赋值, 调用的是重载的赋值运算符.
</p>

<div class="org-src-container">

<pre class="src src-C++">Date d = today;  // 使用拷贝构造函数
Date d;
d = today;  // operator= 重载函数
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">常量成员函数</h3>
<div class="outline-text-3" id="text-1-6">
<p>
在成员函数声明的参数表后面加上 const, 表示这个函数不会修改类的状态.
</p>

<div class="org-src-container">

<pre class="src src-C++">class X{
    int y;
public:
    int year() const;
};

inline int Date::year() const {
    return y++;  // error
}

inline int Date::year() {  // error 需要 const 后缀
    return y;
}

inline int Date::year() const {  // right
    return y;
}
</pre>
</div>

<p>
const 对象, 非 const 对象, 都可以调用 const 成员函数;
</p>

<p>
非 const 成员函数只能调用非 const 对象. 如:
</p>
<pre class="example">
void f(Date&amp; d, const Date&amp; cd) {
	int i = d.year();  // ok
	d.add_year(1);  // ok
	int j = cd.year();  // ok
	cd.add_year(1);  // error 不能修改 const cd 的值
}
</pre>
</div>

<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">强制类型转换</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
有时候, 如果需要在 const 成员函数中修改类的状态, 可以使用蛮力:
</p>
<div class="org-src-container">

<pre class="src src-C++">string Date::string_rep() const {
    Date* th = const_cast&lt;Date*&gt;(this);  // 强制去掉 const
    th-&gt;compute_cache_value();
    th-&gt;cache_valid = true;
    return cache;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">mutable</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
除了强制类型转换之外, 要修改类的状态, 还可以将状态声明成 mutable 的.
</p>

<p>
mutable 表示这个成员不可能是 const, 它以一种能允许更新的方式存储. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Date{
    mutable bool cache_valid;
public:
    string string_rep() cosnt;
};

string Date::string_rep() const {
    cache_valid = true;  // 修改类的状态
    ...
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">自引用</h3>
<div class="outline-text-3" id="text-1-7">
<p>
在一个非静态的成员函数里, this 是一个指针, 指向当时调用该成员函数的对象. 在类 X 的 非 const 成员函数里, this 的类型是 X*, 在类 X 的 const 成员函数里, this 的类型是 const X*.
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">内联函数</h3>
<div class="outline-text-3" id="text-1-8">
<p>
内联函数就是在类定义时, 就将成员函数也一起定义了, 而不仅仅是声明. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Date{
public:
    int day() const { return d; }
};
</pre>
</div>

<p>
为了保持程序一致, 我们建议统一将成员函数的定义放在类定义之后, 所以可以使用 inline 关键字, 表示这个成员函数在类定义时就定义了. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Date{
public:
    int day() const;
};

inline int Date::day() const {
    return d;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">设计一个日期类</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">声明</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-C++">#include&lt;iostream&gt;
using namespace std;
class Date {
public:
    enum Month { jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };
    class Bad_date {};  // 异常类
    Date(int dd=0, Month mm=Month(0), int yy=0);

    // 检查Date的函数
    int day() const;
    Month month() const;
    int year() const;
    string string_rep() const;  // 字符串表示
    void char_rep(char s[]) const;  // C风格字符串表示
    static void set_default(int, Month, int);

    // 修改Date的函数
    Date&amp; add_year(int n);
    Date&amp; add_month(int n);
    Date&amp; add_day(int n);
private:
    int d, m, y;
    static Date default_date;
};
</pre>
</div>
<p>
一个经典的类, 包括以下几组操作:
</p>
<ul class="org-ul">
<li>一个构造函数, 描述这个类型的对象/变量应该如何初始化.
</li>
<li>一组 get 函数, 用于查看对象的状态, 并且应该标记为 const.
</li>
<li>一组 set 函数, 用于改变对象的状态.
</li>
<li>一个拷贝构造函数或重载赋值操作符, 使类可以自由复制.
</li>
<li>一个异常类, 用于报告异常情况.
</li>
</ul>

<p>
在类外, 可以使用 Date::feb 来表示第二个月.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">定义</h3>
<div class="outline-text-3" id="text-2-2">
<p>
每个成员函数, 都会有一个对应的实现. 如构造函数:
</p>
<div class="org-src-container">

<pre class="src src-C++">#include "Date.h"

Date::Date(int dd, Month mm, int yy) {
    if (yy == 0) yy = default_date.year();
    if (mm == 0) mm = default_date.month();
    if (dd == 0) dd = default_date.day();

    int max;

    switch(mm) {
        case feb:
            max = 28+leapyear(yy);
            break;
        case apr: case jun: case sep: case nov:
            max = 30;
            break;
        case jan: case mar: case may: case jul: case aug: case oct: case dec:
            max = 31;
            break;
        default:
            throw Bad_date();
    }
    if (dd&lt;1 || max&lt;dd) throw Bad_date();
    y = yy;
    m = mm;
    d = dd;
}
</pre>
</div>

<p>
另外, 有一些辅助函数, 与类相关, 但未必要定义在类里(定义在类中会让类的界面过于复杂), 因为它们并不需要直接访问有关的表示. 如上面的 leapyear 函数:
</p>
<div class="org-src-container">

<pre class="src src-C++">bool leapyear(int y);
</pre>
</div>

<p>
像这种函数, 我们可以放在与类的声明相同的头文件中, 如 Date.h
</p>

<p>
也可以将类和它的辅助函数放在同一个 namespace 里:
</p>
<div class="org-src-container">

<pre class="src src-C++">namespace Chrono {
    class Date { /* ... */ }
    bool leapyear(int y);
    // ...
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">具体的类</h3>
<div class="outline-text-3" id="text-2-3">
<p>
我们在上面的定义的 Date 类, 是一个具体的类型, 不会带来隐性的时间或者空间上的额外开销.
</p>

<p>
<code>具体类型的大小在编译时已知晓, 因此这种对象可以在运行栈上分配, 无须使用自由存储操作</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">对象</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">析构函数</h3>
<div class="outline-text-3" id="text-3-1">
<p>
析构函数的最常见用途是为了释放构造函数请求的存储空间. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Name {
    const char* s;
};

class Table {
    Name* p;
    size_t sz;
public:
    Table(size_t s=15) { p = new Name[sz = s]; }
    ~Table() { delete[] p; }
    // ...
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">默认构造函数</h3>
<div class="outline-text-3" id="text-3-2">
<p>
如果程序员没有声明构造函数, 则编译器会生成一个默认构造函数, 它将隐式地为 <code>类类型的成员</code> 和它的基类调用有关的默认构造函数.
</p>

<p>
<code>如果程序员自己写了一个带有默认参数值的构造函数, 也可以将这个构造函数认为是默认构造函数</code>, 如上面例子中的 Table 类.
</p>

<p>
考虑如下代码:
</p>
<div class="org-src-container">

<pre class="src src-C++">struct Tables {
    int i;
    int vi[10];
    Table t1;
    Table vt[10];
};

Tables tt;
</pre>
</div>
<p>
Tables里面没有声明构造函数, 因此会调用默认构造函数. 默认构造函数只初始化类类型的成员, 所以它不会去初始化 tt.i, tt.vi, 因为它们不是类类型的对象.
</p>

<p>
const和引用必须在初始化列表中进行初始化, 而不能在构造函数中.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">构造和析构</h3>
<div class="outline-text-3" id="text-3-3">
<p>
下面分情况讨论建立对象和销毁对象的时机.
</p>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">局部对象</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
局部变量(栈上分配), 在程序遇到它时建立, 离开它所出现的块是销毁. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">void f() {
    Table aa;
    // ...
}
</pre>
</div>
<p>
对象 aa 在函数返回时被析构.
</p>
</div>

<div id="outline-container-sec-3-3-1-1" class="outline-5">
<h5 id="sec-3-3-1-1">对象的复制</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<div class="org-src-container">

<pre class="src src-C++">void h() {
    Table t1;
    Table t2 = t1;
    Table t3;
    t3 = t2;
}
</pre>
</div>
<p>
在这个例子中, 默认构造函数调用 2 次, 析构函数调用 3 次:
</p>
<ul class="org-ul">
<li>Table t1: 默认构造函数;
</li>

<li>Table t2 = t1: 默认对象的赋值操作; 按成员赋值, 其中关于指针 p, 做法是 t2.p = t1.p, 没有内存分配, t1.p 和 t2.p 指向同一块内存.
</li>

<li>Table t3: 默认构造函数; 为 t3.p 分配了一块内存.
</li>

<li>t3 = t2: 原来的 t3.p 被 t2.p 覆盖, 此时 t1.p, t2.p, t3.p 指向同一块内存. 而原本的 t3.p 所占用的内存不再有指针指向它, 无法利用到, 资源浪费了.
</li>
</ul>

<p>
在 h() 返回时, 进行了三次析构, 对 t1.p, t2.p, t3.p 所指的同一块内存删除了三次. 这种行为非常危险, 有可能第一次删除后, 该内存马上被利用, 然后又进行了第二次删除.
</p>

<p>
解决办法: 将 Table 的复制定义清楚.
</p>
<div class="org-src-container">

<pre class="src src-C++">class Table {
    Table(const Table&amp;);
    Table&amp; operator=(const Table&amp;);
};

Table::Table(const Table&amp; t) {
    p = new Name[sz=t.sz];
    for (int i=0; i&lt;sz; i++) p[i] = t.p[i];
}

Table&amp; Table::operator=(const Table&amp; t) {
    if (this != &amp;t) {  // 防止自赋值
        delete[] p;
        p = new Name[sz=t.sz];
        for (int i=0; i&lt;sz; i++) p[i] = t.p[i];
    }
    return *this;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">自由存储</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
自由存储对象(堆上分配), 使用 new 运算符建立, delete 运算符销毁.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">类对象作为成员</h4>
<div class="outline-text-4" id="text-3-3-3">
<div class="org-src-container">

<pre class="src src-C++">class Club {
    string name;
    Table members;
    Table officers;
    Date founded;
    // ...
    Club(const string&amp; n, Date fd);
};

Club::Club(const string&amp; n, Date fd)
    : name(n), members(), officers(), founded(fd) {
    // ...
}
</pre>
</div>
<p>
对于引用类型, const类型, 类类型的成员变量, 都建议在初始化列表中进行初始化. 这边重点讨论类类型的成员变量, 为什么要在初始化列表中进行初始化?
</p>

<ul class="org-ul">
<li>必要性. 如果这个类成员变量的构造函数只有带参数这一种, 则它的声明要这样:
</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++">CMember* pm = new CMember;  // Error
CMember* pm = new CMember(2); // OK
</pre>
</div>
<p>
所以, 如果 CMember 的对象是另一个类的成员, 则必须使用初始化列表:
</p>
<div class="org-src-container">

<pre class="src src-C++">CMyClass::CMyClass() : m_member(2) { // ... }
</pre>
</div>

<ul class="org-ul">
<li>效率. 编译器问题确保所有成员对象在构造函数执行之前初始化, 所以会先调用成员的默认构造函数, 完成成员初始化后再进入构造函数体中执行赋值操作. 所以如果在构造函数内赋值, 其实是调用了两次构造函数, 一次是进入构造函数之前, 另一次是在构造函数内部赋值; 如果在初始化列表中初始化, 则在构造函数内部就不再赋值了.
</li>
</ul>

<p>
最后, 类类型的成员变量的构造函数调用顺序, 与它们在类中声明的顺序有关, 与它们在初始化列表中的顺序无关.
</p>
</div>

<div id="outline-container-sec-3-3-3-1" class="outline-5">
<h5 id="sec-3-3-3-1">成员的复制</h5>
<div class="outline-text-5" id="text-3-3-3-1">
<p>
如果程序员没有编写拷贝构造函数和赋值操作, 则会自动生成. 所以如果想要禁止复制行为, 就要明确写出这两个函数, 并声明为私有. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">private:
    Unique_handle(const Unique_handle&amp;);
    Unique_handle&amp; operator=(const Unique_handle&amp;);
</pre>
</div>

<p>
另外, 系统生成的这两种函数, 执行的是浅拷贝, 所以如果确定要使用深拷贝, 需要自己小心编写.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4">数组</h4>
<div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">

<pre class="src src-C++">Table tbl[10];
</pre>
</div>
<p>
这会建立一个包含 10 个 Table 的数组, 并用默认参数 15 调用 Table::Table() 进行初始化.
</p>

<p>
C 风格的数组:
</p>
<div class="org-src-container">

<pre class="src src-C++">Table* t1 = new Table;
Table* t2 = new Table[sz];

delete t1;
delete[] t2;
</pre>
</div>

<p>
改成使用 STL:
</p>
<div class="org-src-container">

<pre class="src src-C++">vector&lt;Table&gt;* p1 = new vector&lt;Table&gt;(10);
delete p1;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5">静态局部存储</h4>
<div class="outline-text-4" id="text-3-3-5">
<div class="org-src-container">

<pre class="src src-C++">void f(int i) {
    static Table tbl;
    // ...
}

int main() {
    f(0);
    f(1);
}
</pre>
</div>
<p>
f(0) 的时候会构造一次, 而 f(1) 时不再构造.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-6" class="outline-4">
<h4 id="sec-3-3-6">非局部存储</h4>
<div class="outline-text-4" id="text-3-3-6">
<p>
在所有函数之外定义的变量(即全局变量, 名字空间的变量, 各个类的 static 变量) 在 main() 执行前完成初始化(构造), 在 main() 结束后析构.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-7" class="outline-4">
<h4 id="sec-3-3-7">临时对象</h4>
<div class="outline-text-4" id="text-3-3-7">
<p>
与临时变量有关的问题都出在以低级的方式去使用高级的数据类型. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">const char* cs = (s1+s2).c_str();
</pre>
</div>
<p>
为了保存 s1+s2 的结果, 将会产生一个临时对象, 然后从这个临时对象中提取一个指向 C 风格字符串的指针. 但是, 在表达式结束时, 这个临时对象被删除, cs 会指向一个已经释放的内存.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-8" class="outline-4">
<h4 id="sec-3-3-8">对象的放置</h4>
<div class="outline-text-4" id="text-3-3-8">
<p>
new 操作符将在堆上创建对象, 如果想要在其他地方创建对象, 可以重载 new 操作符(默认的 new 操作只有一个 size_t 类型的参数):
</p>
<div class="org-src-container">

<pre class="src src-C++">void* operator new(size_t, void* p) { return p; }

// 使用
void* buf = reinterpret_cast&lt;void*&gt;(0xF00F);  // 重要地址
X* p2 = new(buf) X;  // X 是一个类
</pre>
</div>
<p>
其中, new(buf) X 相当于 new(sizeof(X), buf).
</p>

<p>
reinterpret_cast 是一种简单粗暴的类型转换运算符. 在大部分情况下, 它简单地产生一个值, 其二进制与原参数一致, 并且具有所需要的类型.
</p>
</div>
</div>

<div id="outline-container-sec-3-3-9" class="outline-4">
<h4 id="sec-3-3-9">enum</h4>
<div class="outline-text-4" id="text-3-3-9">
<p>
由于 enum 无法知道存储在里面的对象的类型, 所以其成员不能是含构造/析构的成员, 因为无法保护其中的对象. 所以 enum 一般只作为类的实现中的一部分, 由类云维护有关在 enum 中存储的信息.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">派生类</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">引入</h3>
<div class="outline-text-3" id="text-4-1">
<p>
首先考虑一段代码:
</p>
<div class="org-src-container">

<pre class="src src-C++">struct Employee {
    string first_name, family_name;
    char middle_initial;
      Date hiring_date;
      short department;
    // ...
};

struct Manager {
    Employee emp;  // 经理的雇佣记录
    list&lt;Employee*&gt; group;  // 所管理的人员
    short level;
    // ...
};
</pre>
</div>
<p>
一个经理同时也是一个雇员, 所以在 Manager 对象的 emp 成员里存储着 Employee 数据. 但是对于编译器来说, 一个 Manager* 就不是 Employee*.
</p>

<p>
利用派生类, 可以实现, 一个 Manager 同时也是一个 Employee. 
</p>
<div class="org-src-container">

<pre class="src src-C++">struct Manager : public Employee {
    list&lt;Employee*&gt; group;
    short level;
    // ...
};
</pre>
</div>
<p>
由于一个 Manager 同时也是一个 Employee, 所以, 可以使用 Manager 的地方, 都可以使用 Employee 来替代. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">void f(Manager ml, Employee el) {
    list&lt;Employee*&gt; elist;
    elist.push_front(&amp;ml);
    elist.push_front(&amp;el);
    // ...
}
</pre>
</div>

<p>
最后, 基类是一定要有定义的, 不能只声明. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Employee;
class Manager : public Employee { // 错误: Employee 无定义 
    // ...
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">成员函数</h3>
<div class="outline-text-3" id="text-4-2">
<p>
通过 public 继承的派生类, 可以使用基类的公有成员和保护成员, 但不能使用基类的私有成员.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">构造函数和析构函数</h3>
<div class="outline-text-3" id="text-4-3">
<p>
在派生类的构造函数中, 如果基类有构造函数, 则必须调用这些构造函数(基类的构造函数如果没有参数, 则可以省略):
</p>
<div class="org-src-container">

<pre class="src src-C++">class Employee {
    string first_name, family_name;
    short department;
public:
    Employee(const string&amp; n, int d);
};

class Manager : public Employee {
    list&lt;Employee*&gt; group;
    short level;
public:
    Manager(const string&amp; n, int d, int lvl);
};

Employee::Employee(const string&amp; n, int d)
    : family_name(n), department(d) {
    // ...
}

Manager::Manager(const string&amp; n, int d, int lvl)
    : Employee(n, d),  // 初始化基类
      level(lvl) {
    // ...
}
</pre>
</div>
<p>
注意, 派生类的构造函数不能直接去初始化基类的成员, 必须借用基类的构造函数来初始化.
</p>

<p>
<code>类对象的构造顺序: 首先是基类, 然后是成员, 最后是派生类本身; 析构则相反.</code>
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">复制</h3>
<div class="outline-text-3" id="text-4-4">
<p>
类对象的复制由拷贝构造函数和赋值操作定义, 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Employee {
    Employee&amp; operator=(const Employee&amp;);
    Employee(const Employee&amp;);
};

void f(const Manager&amp; m) {
    Employee e = m;  // 调用拷贝构造函数
    e = m;  // 调用赋值操作符
}
</pre>
</div>
<p>
这种复制行为, 只会将 Manager 的 Employee 部分复制过来, 从而产生"切割". 如果使用的是类对象的指针或引用来进行传递, 则可以避免"切割"问题.
</p>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">虚函数</h3>
<div class="outline-text-3" id="text-4-5">
<p>
虚函数使程序员可以在碁类里声明一些能够在各个派生类里重新定义的函数. 编译器和装载程序能保证对象和应用于它们的函数之间的正确对应关系. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Employee {
    string first_name, family_name;
    short department;
public:
    Employee(const string&amp; name, int dept);
    virtual void print() const;
};

void Employee::print() const {  // ...  }
</pre>
</div>
<p>
在派生类中, 虚函数的参数类型不允许修改, 但返回类型可以有稍微改变.
</p>

<p>
虚函数也必须有定义, 纯虚函数则可以不定义.
</p>
<div class="org-src-container">

<pre class="src src-C++">class Manager : public Employee {
public:
    void print() const;
};

// ...
</pre>
</div>
<p>
这样一来, 派生类中的 print() 就会覆盖基类中的 print().
</p>

<p>
除非明确说明需要调用的虚函数的版本(如, Employee::print()), 否则, 在对一个对象调用虚函数时, 被选用的总是那个最适于它的覆盖函数. 这就是 <code>多态性</code>. 一个带有虚函数的类型被称为是一个 <code>多态类型</code>. <code>要在 C++ 里取得多态行为, 被调用的函数就必须是虚函数, 而对象则必须是通过指针或者引用去操作的</code>. 如果直接操作一个对象(而不是通过指针或引用), 它的确切类型就已经为编译器所知, 因此也就不需要运行时的多态性了.
</p>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">抽象类</h3>
<div class="outline-text-3" id="text-4-6">
<p>
纯虚函数就是在虚函数后面加上 =0. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Shape {
public:
    virtual void rotate(int) = 0; 
    virtual void draw() = 0;
    virtual bool is_closed() = 0;
};
</pre>
</div>

<p>
纯虚函数可以不进行定义. 如果一个类里存在纯虚函数, 这个类就是抽象类.
</p>

<p>
抽象类只能用做界面, 作为其他类的基类. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Circle : public Shape {
public:
    void rotate(int) { }
    void draw();
    bool is_closed() { return true; }
};

// ...
</pre>
</div>

<p>
如果抽象类的派生类没有定义抽象类中的所有纯虚函数, 则派生类仍是一个抽象类.
</p>
<div class="org-src-container">

<pre class="src src-C++">class Polygon : public Shape {
public:
    bool is_closed() { return true; }
    // 未定义 draw() 和 rotate()
};
Polygon b;  // Error, Polygon 是个抽象类
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">类层次结构</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">多重继承</h3>
<div class="outline-text-3" id="text-5-1">
<p>
多重继承是指派生类有多个直接基类.
</p>

<p>
多重继承会带来歧义, 如多个基类可能会出现同名的成员函数, 在派生类中, 需要明确指明这个成员函数是哪个基类的, 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">void f(Satellite* sp) {
    debug_info* dip = sp-&gt;get_debug();  // Error
    dip = sp-&gt;Task::get_debug();  // OK
    dip = sp-&gt;Displayed::get_debug();  // OK
}
</pre>
</div>
<p>
也可以在 Satellite 类中直接定义一个 get_debug(), 然后在内部调用两个基类的 get_debug().
</p>

<p>
如果 A 是基类, B 继承自 A, C 继承自 A, D 继承自 B 和 C, 如果在 D 中调用 A 的成员, 就会产生歧义. 因为编译器不知道调用的是 A-&gt;B-&gt;D 路线中的 A, 还是 A-&gt;C-&gt;D 中的 A. 所以, 公共基类不应该表示为两个分离对象, 它们应该用虚基类来表示.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">虚基类</h3>
<div class="outline-text-3" id="text-5-2">
<p>
虚基类就是在继承时, 多加一个 virtual 关键字. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">class A {};
class B : public virtual A {};
class C : public virtual A {};
class D : public B, public C {};
</pre>
</div>
<p>
这个时候, B 和 C 共用同一个基类 A, 而不会保存多个 A 的副本.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">访问控制</h3>
<div class="outline-text-3" id="text-5-3">
<p>
对于成员:
<img src="https://pinvondev.github.io/assets/blog/C++/2018/06/30/类/ Or /blog/C++/类/0.png" alt="0.png" />
</p>

<p>
对于继承:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">public</th>
<th scope="col" class="left">protected</th>
<th scope="col" class="left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">公有继承</td>
<td class="left">public</td>
<td class="left">protected</td>
<td class="left">不可见</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">保护继承</td>
<td class="left">protected</td>
<td class="left">private</td>
<td class="left">不可见</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">私有继承</td>
<td class="left">private</td>
<td class="left">private</td>
<td class="left">不可见</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">运行时类型信息(RTTI, Run Time Type Information)</h3>
<div class="outline-text-3" id="text-5-4">
<p>
RTTI 是指在运行时进行类型识别, C++ 引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型.
</p>
</div>

<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">dynamic_cast</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
dynamic_cast 运算符有两个参数, 一个是 &lt;type&gt;, 一个是 () 里面的指针或引用. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">dynamic_cast&lt;T*&gt; (p)
</pre>
</div>

<p>
例子:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Employee {};  // Manager 内部有 virtual 函数
class Manager : public Employee {};

int main() {
    Manager m;
    Employee&amp; e = m;  // 向上转型, 可以直接转, 也可以用 dynamic_cast
    Manager&amp; new_m = dynamic_cast&lt;Manager&amp;&gt;(e);  // 向下转型, 从 Employee 转到 Manager, 使用 dynamic_cast
}
</pre>
</div>
<p>
换个角度想就很清楚了, 一个 Manager 同时也必定是一个 Employee, 所以从 Manager 转到 Employee 就可以直接转, 而一个 Employee 未必是一个 Manager, 所以从 Employee 转到 Manager 就需要借助运算符 dynamic_cast.
</p>

<p>
dynamic_cast 要求第二个参数必须是指向 <code>多态类</code> 的指针或引用, 否则会出错. 如上面的例子中, Employee 必须包含虚函数.
</p>

<p>
在 C++ 中, 如果一个类中含有虚函数, 则编译器会构建出一个虚函数表来指示这些函数的地址, 如果派生类定义并实现了一个同名函数, 则虚函数表会将该函数指向新的地址.
</p>

<p>
使用 dynamic_cast 后必须进行检查, 因为如果转换失败, 会返回空指针.
</p>

<p>
考虑如下代码:
</p>
<div class="org-src-container">

<pre class="src src-C++">class Component : public virtual Storable { /* ... */ };
class Receiver : public Component { /* ... */ };
class Transmitter : public Component { /* ... */ };
class Radio : public Receiver, public Transmitter { /* ... */ };
</pre>
</div>
<p>
继承图如下所示:
<img src="https://pinvondev.github.io/assets/blog/C++/2018/06/30/类/ Or /blog/C++/类/1.png" alt="1.png" />
</p>

<p>
一个 Radio 对象里包含了两个 Component 对象, 所以如果对一个 Radio 里用 dynamic_cast 从 Storable 出发到 Component, 就会因为歧义性而返回 0. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">void h1(Radio&amp; r) {
    Storable* ps = &amp;r;
    // ...
    Component* pc = dynamic_cast&lt;Component*&gt;(ps);  // pc = 0
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">static_cast</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
dynamic_cast 能从多态性的虚基类强制到某个派生类或者兄弟类, 而 static_cast 不检查被强制的对象, 所以它做不到这些:
</p>
<div class="org-src-container">

<pre class="src src-C++">void g(Radio&amp; r) {
    Receiver* prec = &amp;r;    // Receiver 是 Radio 的常规基类
    Radio* pr = static&lt;Radio*&gt;(prec);   // 可以, 不检查
    pr = dynamic_cast&lt;Radio*&gt;(prec);    // 可以, 运行时检查

    Storable* ps = &amp;r;  // Storable 是 Radio 的虚基类
    pr = static_cast&lt;Radio*&gt;(ps);   // 错误, 不能从虚基类强制
    pr = dynamic_cast&lt;Radio*&gt;(ps);  // 可以, 运行时检查
}
</pre>
</div>
<p>
尽管 dynamic_cast 会带来一些额外的开销, 但还是更加推荐使用 dynamic_cast 来在类的层次结构中进行强制转换, 因为它比 static_cast 更加安全. 但有一种情况, 必须使用 static_cast.
</p>

<p>
dynamic_cast 不能从 void* 出发进行强制, 因为它必须去查看对象, 以确定其类型:
</p>
<div class="org-src-container">

<pre class="src src-C++">Radio* f(void* p) {
    Storable* ps = static_cast&lt;Storable*&gt;(p);  // 相信程序员
    return dynamic_cast&lt;Radio*&gt;(ps);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">类对象的构造和析构</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
不要在构造和析构函数中调用虚函数. 如果在派生类的构造函数中调用了虚函数, 此时由于派生类对象正在被构造, 所以调用的虚函数只能是基类的虚函数, 而不是派生类的实现版本.
</p>
</div>
</div>

<div id="outline-container-sec-5-4-4" class="outline-4">
<h4 id="sec-5-4-4">typeid 操作符</h4>
<div class="outline-text-4" id="text-5-4-4">
<p>
typeid 是一个运算符, 而不是函数, 这点与 sizeof 一样.
</p>

<p>
typeid 用来在运行时取得变量的类型. 如:
</p>
<div class="org-src-container">

<pre class="src src-C++">int ia=3;
if(typeid(ia) == typeid(int)) {
    cout &lt;&lt; "int" &lt;&lt; endl;
}
</pre>
</div>

<p>
C++ 为了支持 RTTI, 提供了两个操作符: dynamic_cast 和 typeid. typeid 操作符的返回结果是 type_info 类的对象的引用(在 typeinfo 头文件中定义). type_info 的确定定义与编译器有关.
</p>

<p>
type_info 将默认构造函数, 拷贝构造函数和赋值操作符都定义为 private, 所以不能定义或复制 type_info 类型的对象. 要想创建 type_info 对象, 只能使用 typeid 操作符, 所以如果把 typeid 当成函数, 它就是 type_info 类的友元函数.
</p>

<p>
typeid() 常用于找出由一个引用或者指针所引用的对象的确切类型, 如果一个多态类型的指针或引用的操作对象的值是 0, typeid() 将抛出一个 bad_typeid 异常. <code>如果 typeid() 的操作对象的类型不是多态的, 其结果在编译时就会确定.</code>
</p>

<p>
除了和上面的例子一样, 用 == 来检测 type_info 对象是否相等之外, 还可以直接获取类的名字:
</p>
<div class="org-src-container">

<pre class="src src-C++">#include &lt;typeinfo&gt;
void g(Component* p) {
    cout &lt;&lt; typeid(*p).name();
}
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-06-30</span>
            <span title="last modification date" class="post-info">2018-07-10</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/c++">C++</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_url = "https://pinvondev.github.io/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div></body>
</html>
