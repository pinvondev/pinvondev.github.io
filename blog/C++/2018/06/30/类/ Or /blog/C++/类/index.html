<!DOCTYPE html>
<html lang="en">
<head>
  <title>类 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="C++" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">类</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org303f9cd">类</a>
<ul>
<li><a href="#org7136180">类定义</a>
<ul>
<li><a href="#orgb128ea3">考点</a></li>
</ul>
</li>
<li><a href="#orged438b3">访问控制</a></li>
<li><a href="#orgd895063">构造函数</a></li>
<li><a href="#org997061e">静态成员</a>
<ul>
<li><a href="#org01700f0">考点</a></li>
</ul>
</li>
<li><a href="#org67af936">类对象的复制</a></li>
<li><a href="#org20d5314">常量成员函数</a>
<ul>
<li><a href="#orga06490f">强制类型转换</a></li>
<li><a href="#org13e4916">mutable</a></li>
</ul>
</li>
<li><a href="#org9c44976">自引用</a></li>
<li><a href="#orgb90a21c">内联函数</a></li>
</ul>
</li>
<li><a href="#org44d6470">设计一个日期类</a>
<ul>
<li><a href="#orgb0405ab">声明</a></li>
<li><a href="#orgdfd11cc">定义</a></li>
<li><a href="#orgbe08f15">具体的类</a></li>
</ul>
</li>
<li><a href="#org864e450">对象</a>
<ul>
<li><a href="#org3138ca2">析构函数</a></li>
<li><a href="#org1e859c0">默认构造函数</a></li>
<li><a href="#orgb8a8737">构造和析构</a>
<ul>
<li><a href="#org22b66c3">局部对象</a>
<ul>
<li><a href="#org408c5c0">对象的复制</a></li>
</ul>
</li>
<li><a href="#org6f26fbe">自由存储</a></li>
<li><a href="#org65fb0d7">类对象作为成员</a>
<ul>
<li><a href="#org222181c">成员的复制</a></li>
</ul>
</li>
<li><a href="#orgaca1e61">数组</a></li>
<li><a href="#org26d770c">静态局部存储</a></li>
<li><a href="#orgdfd78d7">非局部存储</a></li>
<li><a href="#orgf0fc4fc">临时对象</a></li>
<li><a href="#orgd3fb10f">对象的放置</a></li>
<li><a href="#org1282e06">enum</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org303f9cd" class="outline-2">
<h2 id="org303f9cd">类</h2>
<div class="outline-text-2" id="text-org303f9cd">
</div>
<div id="outline-container-org7136180" class="outline-3">
<h3 id="org7136180">类定义</h3>
<div class="outline-text-3" id="text-org7136180">
<p>
类定义的形式:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">X</span>{ ... };
</pre>
</div>
<p>
一个类定义也常常说成类声明.
</p>
</div>

<div id="outline-container-orgb128ea3" class="outline-4">
<h4 id="orgb128ea3">考点</h4>
<div class="outline-text-4" id="text-orgb128ea3">
<ul class="org-ul">
<li>在类定义时, 能否对对象直接初始化?</li>
</ul>

<p>
不能. 因为在类定义时无法使用构造函数, 因此无法完成对象的初始化.
</p>
</div>
</div>
</div>

<div id="outline-container-orged438b3" class="outline-3">
<h3 id="orged438b3">访问控制</h3>
<div class="outline-text-3" id="text-orged438b3">
<p>
class 默认为 private 权限, struct 默认为 public 权限.
</p>
</div>
</div>

<div id="outline-container-orgd895063" class="outline-3">
<h3 id="orgd895063">构造函数</h3>
<div class="outline-text-3" id="text-orgd895063">
<p>
构造函数名与类名相同, 没有返回值, 支持重载.
</p>
</div>
</div>

<div id="outline-container-org997061e" class="outline-3">
<h3 id="org997061e">静态成员</h3>
<div class="outline-text-3" id="text-org997061e">
<p>
静态成员只有唯一的副本, 不像其他成员, 在每个对象中都拥有一份副本. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
    ...
    <span style="color: #FF1493;">static</span> Date default_date;
<span style="color: #FF1493;">public</span>:
    ...
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> set_default(...){
        <span style="color: #AF87FF;">Date</span>::default_date = Date(...);
    }
};
</pre>
</div>
</div>

<div id="outline-container-org01700f0" class="outline-4">
<h4 id="org01700f0">考点</h4>
<div class="outline-text-4" id="text-org01700f0">
<ul class="org-ul">
<li>一般数据类型, 静态数据类型的初始化时机.</li>
</ul>

<p>
一般数据类型必须在类内进行初始化; 静态成员变量必须在类外初始化; 静态成员常量必须在类中初始化(常量在声明时初始化, 所以只能在类中).
</p>
</div>
</div>
</div>

<div id="outline-container-org67af936" class="outline-3">
<h3 id="org67af936">类对象的复制</h3>
<div class="outline-text-3" id="text-org67af936">
<p>
在定义时赋初值时, 调用的是拷贝构造函数; 先定义后赋值, 调用的是重载的赋值运算符.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">d</span> = today;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20351;&#29992;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">d</span>;
d = today;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">operator= &#37325;&#36733;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org20d5314" class="outline-3">
<h3 id="org20d5314">常量成员函数</h3>
<div class="outline-text-3" id="text-org20d5314">
<p>
在成员函数声明的参数表后面加上 const, 表示这个函数不会修改类的状态.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">X</span>{
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span>;
};

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #FF1493;">return</span> y++;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">error</span>
}

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">error &#38656;&#35201; const &#21518;&#32512;</span>
    <span style="color: #FF1493;">return</span> y;
}

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span> {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">right</span>
    <span style="color: #FF1493;">return</span> y;
}
</pre>
</div>

<p>
const 对象, 非 const 对象, 都可以调用 const 成员函数;
</p>

<p>
非 const 成员函数只能调用非 const 对象. 如:
</p>
<pre class="example">
void f(Date&amp; d, const Date&amp; cd) {
    int i = d.year();  // ok
    d.add_year(1);  // ok
    int j = cd.year();  // ok
    cd.add_year(1);  // error 不能修改 const cd 的值
}
</pre>
</div>

<div id="outline-container-orga06490f" class="outline-4">
<h4 id="orga06490f">强制类型转换</h4>
<div class="outline-text-4" id="text-orga06490f">
<p>
有时候, 如果需要在 const 成员函数中修改类的状态, 可以使用蛮力:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">string</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #5FD7FF;">Date</span>* <span style="color: #FF8C00;">th</span> = <span style="color: #FF1493;">const_cast</span>&lt;<span style="color: #5FD7FF;">Date</span>*&gt;(<span style="color: #FF1493;">this</span>);  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#24378;&#21046;&#21435;&#25481; const</span>
    th-&gt;compute_cache_value();
    th-&gt;cache_valid = <span style="color: #AF87FF;">true</span>;
    <span style="color: #FF1493;">return</span> cache;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org13e4916" class="outline-4">
<h4 id="org13e4916">mutable</h4>
<div class="outline-text-4" id="text-org13e4916">
<p>
除了强制类型转换之外, 要修改类的状态, 还可以将状态声明成 mutable 的.
</p>

<p>
mutable 表示这个成员不可能是 const, 它以一种能允许更新的方式存储. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
    <span style="color: #FF1493;">mutable</span> <span style="color: #5FD7FF;">bool</span> <span style="color: #FF8C00;">cache_valid</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">string</span> <span style="color: #87D700;">string_rep</span>() cosnt;
};

<span style="color: #5FD7FF;">string</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span> {
    cache_valid = <span style="color: #AF87FF;">true</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20462;&#25913;&#31867;&#30340;&#29366;&#24577;</span>
    ...
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9c44976" class="outline-3">
<h3 id="org9c44976">自引用</h3>
<div class="outline-text-3" id="text-org9c44976">
<p>
在一个非静态的成员函数里, this 是一个指针, 指向当时调用该成员函数的对象. 在类 X 的 非 const 成员函数里, this 的类型是 X*, 在类 X 的 const 成员函数里, this 的类型是 const X*.
</p>
</div>
</div>

<div id="outline-container-orgb90a21c" class="outline-3">
<h3 id="orgb90a21c">内联函数</h3>
<div class="outline-text-3" id="text-orgb90a21c">
<p>
内联函数就是在类定义时, 就将成员函数也一起定义了, 而不仅仅是声明. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span> { <span style="color: #FF1493;">return</span> d; }
};
</pre>
</div>

<p>
为了保持程序一致, 我们建议统一将成员函数的定义放在类定义之后, 所以可以使用 inline 关键字, 表示这个成员函数在类定义时就定义了. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span>;
};

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #FF1493;">return</span> d;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org44d6470" class="outline-2">
<h2 id="org44d6470">设计一个日期类</h2>
<div class="outline-text-2" id="text-org44d6470">
</div>
<div id="outline-container-orgb0405ab" class="outline-3">
<h3 id="orgb0405ab">声明</h3>
<div class="outline-text-3" id="text-orgb0405ab">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">#include</span><span style="color: #CDC673;">&lt;iostream&gt;</span>
<span style="color: #FF1493;">using</span> <span style="color: #FF1493;">namespace</span> <span style="color: #AF87FF;">std</span>;
<span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span> {
<span style="color: #FF1493;">public</span>:
    <span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">Month</span> { <span style="color: #FF8C00;">jan</span>=1, <span style="color: #FF8C00;">feb</span>, <span style="color: #FF8C00;">mar</span>, <span style="color: #FF8C00;">apr</span>, <span style="color: #FF8C00;">may</span>, <span style="color: #FF8C00;">jun</span>, <span style="color: #FF8C00;">jul</span>, <span style="color: #FF8C00;">aug</span>, <span style="color: #FF8C00;">sep</span>, <span style="color: #FF8C00;">oct</span>, <span style="color: #FF8C00;">nov</span>, <span style="color: #FF8C00;">dec</span> };
    <span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Bad_date</span> {};  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#24322;&#24120;&#31867;</span>
    <span style="color: #87D700;">Date</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">dd</span>=0, <span style="color: #5FD7FF;">Month</span> <span style="color: #FF8C00;">mm</span>=Month(0), <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">yy</span>=0);

    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#26816;&#26597;Date&#30340;&#20989;&#25968;</span>
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">Month</span> <span style="color: #87D700;">month</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">string</span> <span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#23383;&#31526;&#20018;&#34920;&#31034;</span>
    <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">char_rep</span>(<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">s</span>[]) <span style="color: #FF1493;">const</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">C&#39118;&#26684;&#23383;&#31526;&#20018;&#34920;&#31034;</span>
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">set_default</span>(<span style="color: #5FD7FF;">int</span>, <span style="color: #5FD7FF;">Month</span>, <span style="color: #5FD7FF;">int</span>);

    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20462;&#25913;Date&#30340;&#20989;&#25968;</span>
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_year</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_month</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_day</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
<span style="color: #FF1493;">private</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">d</span>, <span style="color: #FF8C00;">m</span>, <span style="color: #FF8C00;">y</span>;
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">default_date</span>;
};
</pre>
</div>
<p>
一个经典的类, 包括以下几组操作:
</p>
<ul class="org-ul">
<li>一个构造函数, 描述这个类型的对象/变量应该如何初始化.</li>
<li>一组 get 函数, 用于查看对象的状态, 并且应该标记为 const.</li>
<li>一组 set 函数, 用于改变对象的状态.</li>
<li>一个拷贝构造函数或重载赋值操作符, 使类可以自由复制.</li>
<li>一个异常类, 用于报告异常情况.</li>
</ul>

<p>
在类外, 可以使用 Date::feb 来表示第二个月.
</p>
</div>
</div>

<div id="outline-container-orgdfd11cc" class="outline-3">
<h3 id="orgdfd11cc">定义</h3>
<div class="outline-text-3" id="text-orgdfd11cc">
<p>
每个成员函数, 都会有一个对应的实现. 如构造函数:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">"Date.h"</span>

<span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">Date</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">dd</span>, <span style="color: #5FD7FF;">Month</span> <span style="color: #FF8C00;">mm</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">yy</span>) {
    <span style="color: #FF1493;">if</span> (yy == 0) yy = default_date.year();
    <span style="color: #FF1493;">if</span> (mm == 0) mm = default_date.month();
    <span style="color: #FF1493;">if</span> (dd == 0) dd = default_date.day();

    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">max</span>;

    <span style="color: #FF1493;">switch</span>(mm) {
        <span style="color: #FF1493;">case</span> feb:
            max = 28+leapyear(yy);
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">case</span> apr: <span style="color: #FF1493;">case</span> jun: <span style="color: #FF1493;">case</span> sep: <span style="color: #FF1493;">case</span> nov:
            max = 30;
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">case</span> jan: <span style="color: #FF1493;">case</span> mar: <span style="color: #FF1493;">case</span> may: <span style="color: #FF1493;">case</span> jul: <span style="color: #FF1493;">case</span> aug: <span style="color: #FF1493;">case</span> oct: <span style="color: #FF1493;">case</span> dec:
            max = 31;
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">default</span>:
            <span style="color: #FF1493;">throw</span> <span style="color: #5FD7FF;">Bad_date</span>();
    }
    <span style="color: #FF1493;">if</span> (dd&lt;1 || max&lt;dd) <span style="color: #FF1493;">throw</span> <span style="color: #5FD7FF;">Bad_date</span>();
    y = yy;
    m = mm;
    d = dd;
}
</pre>
</div>

<p>
另外, 有一些辅助函数, 与类相关, 但未必要定义在类里(定义在类中会让类的界面过于复杂), 因为它们并不需要直接访问有关的表示. 如上面的 leapyear 函数:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">bool</span> <span style="color: #87D700;">leapyear</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>);
</pre>
</div>

<p>
像这种函数, 我们可以放在与类的声明相同的头文件中, 如 Date.h
</p>

<p>
也可以将类和它的辅助函数放在同一个 namespace 里:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">namespace</span> <span style="color: #AF87FF;">Chrono</span> {
    <span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span> { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">... */</span> }
    <span style="color: #5FD7FF;">bool</span> <span style="color: #87D700;">leapyear</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>);
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbe08f15" class="outline-3">
<h3 id="orgbe08f15">具体的类</h3>
<div class="outline-text-3" id="text-orgbe08f15">
<p>
我们在上面的定义的 Date 类, 是一个具体的类型, 不会带来隐性的时间或者空间上的额外开销.
</p>

<p>
<code>具体类型的大小在编译时已知晓, 因此这种对象可以在运行栈上分配, 无须使用自由存储操作</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org864e450" class="outline-2">
<h2 id="org864e450">对象</h2>
<div class="outline-text-2" id="text-org864e450">
</div>
<div id="outline-container-org3138ca2" class="outline-3">
<h3 id="org3138ca2">析构函数</h3>
<div class="outline-text-3" id="text-org3138ca2">
<p>
析构函数的最常见用途是为了释放构造函数请求的存储空间. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Name</span> {
    <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span>* <span style="color: #FF8C00;">s</span>;
};

<span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Table</span> {
    <span style="color: #5FD7FF;">Name</span>* <span style="color: #FF8C00;">p</span>;
    <span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">sz</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #87D700;">Table</span>(<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">s</span>=15) { p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz = s]; }
    ~<span style="color: #87D700;">Table</span>() { <span style="color: #FF1493;">delete</span>[] p; }
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1e859c0" class="outline-3">
<h3 id="org1e859c0">默认构造函数</h3>
<div class="outline-text-3" id="text-org1e859c0">
<p>
如果程序员没有声明构造函数, 则编译器会生成一个默认构造函数, 它将隐式地为 <code>类类型的成员</code> 和它的基类调用有关的默认构造函数.
</p>

<p>
<code>如果程序员自己写了一个带有默认参数值的构造函数, 也可以将这个构造函数认为是默认构造函数</code>, 如上面例子中的 Table 类.
</p>

<p>
考虑如下代码:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">Tables</span> {
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>;
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">vi</span>[10];
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t1</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">vt</span>[10];
};

<span style="color: #5FD7FF;">Tables</span> <span style="color: #FF8C00;">tt</span>;
</pre>
</div>
<p>
Tables里面没有声明构造函数, 因此会调用默认构造函数. 默认构造函数只初始化类类型的成员, 所以它不会去初始化 tt.i, tt.vi, 因为它们不是类类型的对象.
</p>

<p>
const和引用必须在初始化列表中进行初始化, 而不能在构造函数中.
</p>
</div>
</div>

<div id="outline-container-orgb8a8737" class="outline-3">
<h3 id="orgb8a8737">构造和析构</h3>
<div class="outline-text-3" id="text-orgb8a8737">
<p>
下面分情况讨论建立对象和销毁对象的时机.
</p>
</div>

<div id="outline-container-org22b66c3" class="outline-4">
<h4 id="org22b66c3">局部对象</h4>
<div class="outline-text-4" id="text-org22b66c3">
<p>
局部变量(栈上分配), 在程序遇到它时建立, 离开它所出现的块是销毁. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">f</span>() {
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">aa</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
<p>
对象 aa 在函数返回时被析构.
</p>
</div>

<div id="outline-container-org408c5c0" class="outline-5">
<h5 id="org408c5c0">对象的复制</h5>
<div class="outline-text-5" id="text-org408c5c0">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">h</span>() {
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t1</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t2</span> = t1;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t3</span>;
    t3 = t2;
}
</pre>
</div>
<p>
在这个例子中, 默认构造函数调用 2 次, 析构函数调用 3 次:
</p>
<ul class="org-ul">
<li>Table t1: 默认构造函数;</li>

<li>Table t2 = t1: 默认对象的赋值操作; 按成员赋值, 其中关于指针 p, 做法是 t2.p = t1.p, 没有内存分配, t1.p 和 t2.p 指向同一块内存.</li>

<li>Table t3: 默认构造函数; 为 t3.p 分配了一块内存.</li>

<li>t3 = t2: 原来的 t3.p 被 t2.p 覆盖, 此时 t1.p, t2.p, t3.p 指向同一块内存. 而原本的 t3.p 所占用的内存不再有指针指向它, 无法利用到, 资源浪费了.</li>
</ul>

<p>
在 h() 返回时, 进行了三次析构, 对 t1.p, t2.p, t3.p 所指的同一块内存删除了三次. 这种行为非常危险, 有可能第一次删除后, 该内存马上被利用, 然后又进行了第二次删除.
</p>

<p>
解决办法: 将 Table 的复制定义清楚.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Table</span> {
    <span style="color: #87D700;">Table</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp;);
    <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp;);
};

<span style="color: #AF87FF;">Table</span>::<span style="color: #87D700;">Table</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF8C00;">t</span>) {
    p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz=t.sz];
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>=0; i&lt;sz; i++) p[i] = t.p[i];
}

<span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #AF87FF;">Table</span>::<span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF8C00;">t</span>) {
    <span style="color: #FF1493;">if</span> (<span style="color: #FF1493;">this</span> != &amp;t) {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#38450;&#27490;&#33258;&#36171;&#20540;</span>
        <span style="color: #FF1493;">delete</span>[] p;
        p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz=t.sz];
        <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>=0; i&lt;sz; i++) p[i] = t.p[i];
    }
    <span style="color: #FF1493;">return</span> *<span style="color: #FF1493;">this</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6f26fbe" class="outline-4">
<h4 id="org6f26fbe">自由存储</h4>
<div class="outline-text-4" id="text-org6f26fbe">
<p>
自由存储对象(堆上分配), 使用 new 运算符建立, delete 运算符销毁.
</p>
</div>
</div>

<div id="outline-container-org65fb0d7" class="outline-4">
<h4 id="org65fb0d7">类对象作为成员</h4>
<div class="outline-text-4" id="text-org65fb0d7">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Club</span> {
    <span style="color: #5FD7FF;">string</span> <span style="color: #FF8C00;">name</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">members</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">officers</span>;
    <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">founded</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
    <span style="color: #87D700;">Club</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">string</span>&amp; <span style="color: #FF8C00;">n</span>, <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">fd</span>);
};

<span style="color: #AF87FF;">Club</span>::<span style="color: #87D700;">Club</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">string</span>&amp; <span style="color: #FF8C00;">n</span>, <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">fd</span>)
    : name(n), members(), officers(), founded(fd) {
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
<p>
对于引用类型, const类型, 类类型的成员变量, 都建议在初始化列表中进行初始化. 这边重点讨论类类型的成员变量, 为什么要在初始化列表中进行初始化?
</p>

<ul class="org-ul">
<li>必要性. 如果这个类成员变量的构造函数只有带参数这一种, 则它的声明要这样:</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">CMember</span>* <span style="color: #FF8C00;">pm</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">CMember</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">Error</span>
<span style="color: #5FD7FF;">CMember</span>* <span style="color: #FF8C00;">pm</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">CMember</span>(2); <span style="color: #8B8878;">// </span><span style="color: #8B8878;">OK</span>
</pre>
</div>
<p>
所以, 如果 CMember 的对象是另一个类的成员, 则必须使用初始化列表:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #AF87FF;">CMyClass</span>::<span style="color: #87D700;">CMyClass</span>() : m_member(2) { <span style="color: #8B8878;">// </span><span style="color: #8B8878;">... }</span>
</pre>
</div>

<ul class="org-ul">
<li>效率. 编译器问题确保所有成员对象在构造函数执行之前初始化, 所以会先调用成员的默认构造函数, 完成成员初始化后再进入构造函数体中执行赋值操作. 所以如果在构造函数内赋值, 其实是调用了两次构造函数, 一次是进入构造函数之前, 另一次是在构造函数内部赋值; 如果在初始化列表中初始化, 则在构造函数内部就不再赋值了.</li>
</ul>

<p>
最后, 类类型的成员变量的构造函数调用顺序, 与它们在类中声明的顺序有关, 与它们在初始化列表中的顺序无关.
</p>
</div>

<div id="outline-container-org222181c" class="outline-5">
<h5 id="org222181c">成员的复制</h5>
<div class="outline-text-5" id="text-org222181c">
<p>
如果程序员没有编写拷贝构造函数和赋值操作, 则会自动生成. 所以如果想要禁止复制行为, 就要明确写出这两个函数, 并声明为私有. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">private</span>:
    Unique_handle(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Unique_handle</span>&amp;);
    <span style="color: #5FD7FF;">Unique_handle</span>&amp; <span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Unique_handle</span>&amp;);
</pre>
</div>

<p>
另外, 系统生成的这两种函数, 执行的是浅拷贝, 所以如果确定要使用深拷贝, 需要自己小心编写.
</p>
</div>
</div>
</div>

<div id="outline-container-orgaca1e61" class="outline-4">
<h4 id="orgaca1e61">数组</h4>
<div class="outline-text-4" id="text-orgaca1e61">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">tbl</span>[10];
</pre>
</div>
<p>
这会建立一个包含 10 个 Table 的数组, 并用默认参数 15 调用 Table::Table() 进行初始化.
</p>

<p>
C 风格的数组:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Table</span>* <span style="color: #FF8C00;">t1</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Table</span>;
<span style="color: #5FD7FF;">Table</span>* <span style="color: #FF8C00;">t2</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Table</span>[sz];

<span style="color: #FF1493;">delete</span> t1;
<span style="color: #FF1493;">delete</span>[] t2;
</pre>
</div>

<p>
改成使用 STL:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">vector</span>&lt;Table&gt;* <span style="color: #FF8C00;">p1</span> = <span style="color: #FF1493;">new</span> vector&lt;Table&gt;(10);
<span style="color: #FF1493;">delete</span> p1;
</pre>
</div>
</div>
</div>

<div id="outline-container-org26d770c" class="outline-4">
<h4 id="org26d770c">静态局部存储</h4>
<div class="outline-text-4" id="text-org26d770c">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">f</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>) {
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">tbl</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">main</span>() {
    f(0);
    f(1);
}
</pre>
</div>
<p>
f(0) 的时候会构造一次, 而 f(1) 时不再构造.
</p>
</div>
</div>

<div id="outline-container-orgdfd78d7" class="outline-4">
<h4 id="orgdfd78d7">非局部存储</h4>
<div class="outline-text-4" id="text-orgdfd78d7">
<p>
在所有函数之外定义的变量(即全局变量, 名字空间的变量, 各个类的 static 变量) 在 main() 执行前完成初始化(构造), 在 main() 结束后析构.
</p>
</div>
</div>

<div id="outline-container-orgf0fc4fc" class="outline-4">
<h4 id="orgf0fc4fc">临时对象</h4>
<div class="outline-text-4" id="text-orgf0fc4fc">
<p>
与临时变量有关的问题都出在以低级的方式去使用高级的数据类型. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span>* <span style="color: #FF8C00;">cs</span> = (s1+s2).c_str();
</pre>
</div>
<p>
为了保存 s1+s2 的结果, 将会产生一个临时对象, 然后从这个临时对象中提取一个指向 C 风格字符串的指针. 但是, 在表达式结束时, 这个临时对象被删除, cs 会指向一个已经释放的内存.
</p>
</div>
</div>

<div id="outline-container-orgd3fb10f" class="outline-4">
<h4 id="orgd3fb10f">对象的放置</h4>
<div class="outline-text-4" id="text-orgd3fb10f">
<p>
new 操作符将在堆上创建对象, 如果想要在其他地方创建对象, 可以重载 new 操作符(默认的 new 操作只有一个 size_t 类型的参数):
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span>* <span style="color: #FF1493;">operator</span> <span style="color: #FF1493;">new</span>(<span style="color: #5FD7FF;">size_t</span>, <span style="color: #5FD7FF;">void</span>* <span style="color: #FF8C00;">p</span>) { <span style="color: #FF1493;">return</span> p; }

<span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20351;&#29992;</span>
<span style="color: #5FD7FF;">void</span>* <span style="color: #FF8C00;">buf</span> = <span style="color: #FF1493;">reinterpret_cast</span>&lt;<span style="color: #5FD7FF;">void</span>*&gt;(0xF00F);  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#37325;&#35201;&#22320;&#22336;</span>
<span style="color: #5FD7FF;">X</span>* <span style="color: #FF8C00;">p2</span> = <span style="color: #FF1493;">new</span>(buf) <span style="color: #5FD7FF;">X</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">X &#26159;&#19968;&#20010;&#31867;</span>
</pre>
</div>
<p>
其中, new(buf) X 相当于 new(sizeof(X), buf).
</p>

<p>
reinterpret_cast 是一种简单粗暴的类型转换运算符. 在大部分情况下, 它简单地产生一个值, 其二进制与原参数一致, 并且具有所需要的类型.
</p>
</div>
</div>

<div id="outline-container-org1282e06" class="outline-4">
<h4 id="org1282e06">enum</h4>
<div class="outline-text-4" id="text-org1282e06">
<p>
由于 enum 无法知道存储在里面的对象的类型, 所以其成员不能是含构造/析构的成员, 因为无法保护其中的对象. 所以 enum 一般只作为类的实现中的一部分, 由类云维护有关在 enum 中存储的信息.
</p>
</div>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-06-30</span>
            <span title="last modification date" class="post-info">2018-07-05</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/c++">C++</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_url = "https://pinvondev.github.io/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
            <script type="text/javascript" src="/media/js/love.js"></script>
</div>

  </div></body>
</html>
