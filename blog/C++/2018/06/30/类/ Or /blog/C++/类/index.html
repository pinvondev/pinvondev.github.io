<!DOCTYPE html>
<html lang="en">
<head>
  <title>类 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="C++" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">类</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5cfc833">类</a>
<ul>
<li><a href="#orgfcfdf0e">类定义</a>
<ul>
<li><a href="#orge54badd">考点</a></li>
</ul>
</li>
<li><a href="#org818017c">访问控制</a></li>
<li><a href="#org4f9ebed">构造函数</a></li>
<li><a href="#orgca72ad0">静态成员</a>
<ul>
<li><a href="#orgd443f72">考点</a></li>
</ul>
</li>
<li><a href="#orgc55ef04">类对象的复制</a></li>
<li><a href="#orga30af5f">常量成员函数</a>
<ul>
<li><a href="#org9f4cfed">强制类型转换</a></li>
<li><a href="#org5ef5f16">mutable</a></li>
</ul>
</li>
<li><a href="#org7d5104c">自引用</a></li>
<li><a href="#org3780d35">内联函数</a></li>
</ul>
</li>
<li><a href="#orgf4ebc42">设计一个日期类</a>
<ul>
<li><a href="#orgd208f93">声明</a></li>
<li><a href="#orgdd5285b">定义</a></li>
<li><a href="#org89344a3">具体的类</a></li>
</ul>
</li>
<li><a href="#org778a618">对象</a>
<ul>
<li><a href="#org111e034">析构函数</a></li>
<li><a href="#orgbe22eba">默认构造函数</a></li>
<li><a href="#org826e939">构造和析构</a>
<ul>
<li><a href="#orgc457193">局部对象</a>
<ul>
<li><a href="#org7aac8b2">对象的复制</a></li>
</ul>
</li>
<li><a href="#orgf1afb1f">自由存储</a></li>
<li><a href="#orgb8efe44">类对象作为成员</a>
<ul>
<li><a href="#orgec50a9d">成员的复制</a></li>
</ul>
</li>
<li><a href="#org7317f8f">数组</a></li>
<li><a href="#orgb0b60bb">静态局部存储</a></li>
<li><a href="#orga6df076">非局部存储</a></li>
<li><a href="#orgf4bf493">局部变量</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5cfc833" class="outline-2">
<h2 id="org5cfc833">类</h2>
<div class="outline-text-2" id="text-org5cfc833">
</div>
<div id="outline-container-orgfcfdf0e" class="outline-3">
<h3 id="orgfcfdf0e">类定义</h3>
<div class="outline-text-3" id="text-orgfcfdf0e">
<p>
类定义的形式:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">X</span>{ ... };
</pre>
</div>
<p>
一个类定义也常常说成类声明.
</p>
</div>

<div id="outline-container-orge54badd" class="outline-4">
<h4 id="orge54badd">考点</h4>
<div class="outline-text-4" id="text-orge54badd">
<ul class="org-ul">
<li>在类定义时, 能否对对象直接初始化?</li>
</ul>

<p>
不能. 因为在类定义时无法使用构造函数, 因此无法完成对象的初始化.
</p>
</div>
</div>
</div>

<div id="outline-container-org818017c" class="outline-3">
<h3 id="org818017c">访问控制</h3>
<div class="outline-text-3" id="text-org818017c">
<p>
class 默认为 private 权限, struct 默认为 public 权限.
</p>
</div>
</div>

<div id="outline-container-org4f9ebed" class="outline-3">
<h3 id="org4f9ebed">构造函数</h3>
<div class="outline-text-3" id="text-org4f9ebed">
<p>
构造函数名与类名相同, 没有返回值, 支持重载.
</p>
</div>
</div>

<div id="outline-container-orgca72ad0" class="outline-3">
<h3 id="orgca72ad0">静态成员</h3>
<div class="outline-text-3" id="text-orgca72ad0">
<p>
静态成员只有唯一的副本, 不像其他成员, 在每个对象中都拥有一份副本. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
    ...
    <span style="color: #FF1493;">static</span> Date default_date;
<span style="color: #FF1493;">public</span>:
    ...
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> set_default(...){
        <span style="color: #AF87FF;">Date</span>::default_date = Date(...);
    }
};
</pre>
</div>
</div>

<div id="outline-container-orgd443f72" class="outline-4">
<h4 id="orgd443f72">考点</h4>
<div class="outline-text-4" id="text-orgd443f72">
<ul class="org-ul">
<li>一般数据类型, 静态数据类型的初始化时机.</li>
</ul>

<p>
一般数据类型必须在类内进行初始化; 静态成员变量必须在类外初始化; 静态成员常量必须在类中初始化(常量在声明时初始化, 所以只能在类中).
</p>
</div>
</div>
</div>

<div id="outline-container-orgc55ef04" class="outline-3">
<h3 id="orgc55ef04">类对象的复制</h3>
<div class="outline-text-3" id="text-orgc55ef04">
<p>
在定义时赋初值时, 调用的是拷贝构造函数; 先定义后赋值, 调用的是重载的赋值运算符.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">d</span> = today;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20351;&#29992;&#25335;&#36125;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">d</span>;
d = today;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">operator= &#37325;&#36733;&#20989;&#25968;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga30af5f" class="outline-3">
<h3 id="orga30af5f">常量成员函数</h3>
<div class="outline-text-3" id="text-orga30af5f">
<p>
在成员函数声明的参数表后面加上 const, 表示这个函数不会修改类的状态.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">X</span>{
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span>;
};

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #FF1493;">return</span> y++;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">error</span>
}

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">error &#38656;&#35201; const &#21518;&#32512;</span>
    <span style="color: #FF1493;">return</span> y;
}

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span> {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">right</span>
    <span style="color: #FF1493;">return</span> y;
}
</pre>
</div>

<p>
const 对象, 非 const 对象, 都可以调用 const 成员函数;
</p>

<p>
非 const 成员函数只能调用非 const 对象. 如:
</p>
<pre class="example">
void f(Date&amp; d, const Date&amp; cd) {
    int i = d.year();  // ok
    d.add_year(1);  // ok
    int j = cd.year();  // ok
    cd.add_year(1);  // error 不能修改 const cd 的值
}
</pre>
</div>

<div id="outline-container-org9f4cfed" class="outline-4">
<h4 id="org9f4cfed">强制类型转换</h4>
<div class="outline-text-4" id="text-org9f4cfed">
<p>
有时候, 如果需要在 const 成员函数中修改类的状态, 可以使用蛮力:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">string</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #5FD7FF;">Date</span>* <span style="color: #FF8C00;">th</span> = <span style="color: #FF1493;">const_cast</span>&lt;<span style="color: #5FD7FF;">Date</span>*&gt;(<span style="color: #FF1493;">this</span>);  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#24378;&#21046;&#21435;&#25481; const</span>
    th-&gt;compute_cache_value();
    th-&gt;cache_valid = <span style="color: #AF87FF;">true</span>;
    <span style="color: #FF1493;">return</span> cache;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ef5f16" class="outline-4">
<h4 id="org5ef5f16">mutable</h4>
<div class="outline-text-4" id="text-org5ef5f16">
<p>
除了强制类型转换之外, 要修改类的状态, 还可以将状态声明成 mutable 的.
</p>

<p>
mutable 表示这个成员不可能是 const, 它以一种能允许更新的方式存储. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
    <span style="color: #FF1493;">mutable</span> <span style="color: #5FD7FF;">bool</span> <span style="color: #FF8C00;">cache_valid</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">string</span> <span style="color: #87D700;">string_rep</span>() cosnt;
};

<span style="color: #5FD7FF;">string</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span> {
    cache_valid = <span style="color: #AF87FF;">true</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20462;&#25913;&#31867;&#30340;&#29366;&#24577;</span>
    ...
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7d5104c" class="outline-3">
<h3 id="org7d5104c">自引用</h3>
<div class="outline-text-3" id="text-org7d5104c">
<p>
在一个非静态的成员函数里, this 是一个指针, 指向当时调用该成员函数的对象. 在类 X 的 非 const 成员函数里, this 的类型是 X*, 在类 X 的 const 成员函数里, this 的类型是 const X*.
</p>
</div>
</div>

<div id="outline-container-org3780d35" class="outline-3">
<h3 id="org3780d35">内联函数</h3>
<div class="outline-text-3" id="text-org3780d35">
<p>
内联函数就是在类定义时, 就将成员函数也一起定义了, 而不仅仅是声明. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span> { <span style="color: #FF1493;">return</span> d; }
};
</pre>
</div>

<p>
为了保持程序一致, 我们建议统一将成员函数的定义放在类定义之后, 所以可以使用 inline 关键字, 表示这个成员函数在类定义时就定义了. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span>{
<span style="color: #FF1493;">public</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span>;
};

<span style="color: #FF1493;">inline</span> <span style="color: #5FD7FF;">int</span> <span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span> {
    <span style="color: #FF1493;">return</span> d;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf4ebc42" class="outline-2">
<h2 id="orgf4ebc42">设计一个日期类</h2>
<div class="outline-text-2" id="text-orgf4ebc42">
</div>
<div id="outline-container-orgd208f93" class="outline-3">
<h3 id="orgd208f93">声明</h3>
<div class="outline-text-3" id="text-orgd208f93">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">#include</span><span style="color: #CDC673;">&lt;iostream&gt;</span>
<span style="color: #FF1493;">using</span> <span style="color: #FF1493;">namespace</span> <span style="color: #AF87FF;">std</span>;
<span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span> {
<span style="color: #FF1493;">public</span>:
    <span style="color: #FF1493;">enum</span> <span style="color: #5FD7FF;">Month</span> { <span style="color: #FF8C00;">jan</span>=1, <span style="color: #FF8C00;">feb</span>, <span style="color: #FF8C00;">mar</span>, <span style="color: #FF8C00;">apr</span>, <span style="color: #FF8C00;">may</span>, <span style="color: #FF8C00;">jun</span>, <span style="color: #FF8C00;">jul</span>, <span style="color: #FF8C00;">aug</span>, <span style="color: #FF8C00;">sep</span>, <span style="color: #FF8C00;">oct</span>, <span style="color: #FF8C00;">nov</span>, <span style="color: #FF8C00;">dec</span> };
    <span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Bad_date</span> {};  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#24322;&#24120;&#31867;</span>
    <span style="color: #87D700;">Date</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">dd</span>=0, <span style="color: #5FD7FF;">Month</span> <span style="color: #FF8C00;">mm</span>=Month(0), <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">yy</span>=0);

    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#26816;&#26597;Date&#30340;&#20989;&#25968;</span>
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">day</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">Month</span> <span style="color: #87D700;">month</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">year</span>() <span style="color: #FF1493;">const</span>;
    <span style="color: #5FD7FF;">string</span> <span style="color: #87D700;">string_rep</span>() <span style="color: #FF1493;">const</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#23383;&#31526;&#20018;&#34920;&#31034;</span>
    <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">char_rep</span>(<span style="color: #5FD7FF;">char</span> <span style="color: #FF8C00;">s</span>[]) <span style="color: #FF1493;">const</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">C&#39118;&#26684;&#23383;&#31526;&#20018;&#34920;&#31034;</span>
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">set_default</span>(<span style="color: #5FD7FF;">int</span>, <span style="color: #5FD7FF;">Month</span>, <span style="color: #5FD7FF;">int</span>);

    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#20462;&#25913;Date&#30340;&#20989;&#25968;</span>
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_year</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_month</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
    <span style="color: #5FD7FF;">Date</span>&amp; <span style="color: #87D700;">add_day</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">n</span>);
<span style="color: #FF1493;">private</span>:
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">d</span>, <span style="color: #FF8C00;">m</span>, <span style="color: #FF8C00;">y</span>;
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">default_date</span>;
};
</pre>
</div>
<p>
一个经典的类, 包括以下几组操作:
</p>
<ul class="org-ul">
<li>一个构造函数, 描述这个类型的对象/变量应该如何初始化.</li>
<li>一组 get 函数, 用于查看对象的状态, 并且应该标记为 const.</li>
<li>一组 set 函数, 用于改变对象的状态.</li>
<li>一个拷贝构造函数或重载赋值操作符, 使类可以自由复制.</li>
<li>一个异常类, 用于报告异常情况.</li>
</ul>

<p>
在类外, 可以使用 Date::feb 来表示第二个月.
</p>
</div>
</div>

<div id="outline-container-orgdd5285b" class="outline-3">
<h3 id="orgdd5285b">定义</h3>
<div class="outline-text-3" id="text-orgdd5285b">
<p>
每个成员函数, 都会有一个对应的实现. 如构造函数:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">#include</span> <span style="color: #CDC673;">"Date.h"</span>

<span style="color: #AF87FF;">Date</span>::<span style="color: #87D700;">Date</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">dd</span>, <span style="color: #5FD7FF;">Month</span> <span style="color: #FF8C00;">mm</span>, <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">yy</span>) {
    <span style="color: #FF1493;">if</span> (yy == 0) yy = default_date.year();
    <span style="color: #FF1493;">if</span> (mm == 0) mm = default_date.month();
    <span style="color: #FF1493;">if</span> (dd == 0) dd = default_date.day();

    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">max</span>;

    <span style="color: #FF1493;">switch</span>(mm) {
        <span style="color: #FF1493;">case</span> feb:
            max = 28+leapyear(yy);
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">case</span> apr: <span style="color: #FF1493;">case</span> jun: <span style="color: #FF1493;">case</span> sep: <span style="color: #FF1493;">case</span> nov:
            max = 30;
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">case</span> jan: <span style="color: #FF1493;">case</span> mar: <span style="color: #FF1493;">case</span> may: <span style="color: #FF1493;">case</span> jul: <span style="color: #FF1493;">case</span> aug: <span style="color: #FF1493;">case</span> oct: <span style="color: #FF1493;">case</span> dec:
            max = 31;
            <span style="color: #FF1493;">break</span>;
        <span style="color: #FF1493;">default</span>:
            <span style="color: #FF1493;">throw</span> <span style="color: #5FD7FF;">Bad_date</span>();
    }
    <span style="color: #FF1493;">if</span> (dd&lt;1 || max&lt;dd) <span style="color: #FF1493;">throw</span> <span style="color: #5FD7FF;">Bad_date</span>();
    y = yy;
    m = mm;
    d = dd;
}
</pre>
</div>

<p>
另外, 有一些辅助函数, 与类相关, 但未必要定义在类里(定义在类中会让类的界面过于复杂), 因为它们并不需要直接访问有关的表示. 如上面的 leapyear 函数:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">bool</span> <span style="color: #87D700;">leapyear</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>);
</pre>
</div>

<p>
像这种函数, 我们可以放在与类的声明相同的头文件中, 如 Date.h
</p>

<p>
也可以将类和它的辅助函数放在同一个 namespace 里:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">namespace</span> <span style="color: #AF87FF;">Chrono</span> {
    <span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Date</span> { <span style="color: #8B8878;">/* </span><span style="color: #8B8878;">... */</span> }
    <span style="color: #5FD7FF;">bool</span> <span style="color: #87D700;">leapyear</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">y</span>);
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org89344a3" class="outline-3">
<h3 id="org89344a3">具体的类</h3>
<div class="outline-text-3" id="text-org89344a3">
<p>
我们在上面的定义的 Date 类, 是一个具体的类型, 不会带来隐性的时间或者空间上的额外开销.
</p>

<p>
<code>具体类型的大小在编译时已知晓, 因此这种对象可以在运行栈上分配, 无须使用自由存储操作</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org778a618" class="outline-2">
<h2 id="org778a618">对象</h2>
<div class="outline-text-2" id="text-org778a618">
</div>
<div id="outline-container-org111e034" class="outline-3">
<h3 id="org111e034">析构函数</h3>
<div class="outline-text-3" id="text-org111e034">
<p>
析构函数的最常见用途是为了释放构造函数请求的存储空间. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Name</span> {
    <span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">char</span>* <span style="color: #FF8C00;">s</span>;
};

<span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Table</span> {
    <span style="color: #5FD7FF;">Name</span>* <span style="color: #FF8C00;">p</span>;
    <span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">sz</span>;
<span style="color: #FF1493;">public</span>:
    <span style="color: #87D700;">Table</span>(<span style="color: #5FD7FF;">size_t</span> <span style="color: #FF8C00;">s</span>=15) { p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz = s]; }
    ~<span style="color: #87D700;">Table</span>() { <span style="color: #FF1493;">delete</span>[] p; }
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbe22eba" class="outline-3">
<h3 id="orgbe22eba">默认构造函数</h3>
<div class="outline-text-3" id="text-orgbe22eba">
<p>
如果程序员没有声明构造函数, 则编译器会生成一个默认构造函数, 它将隐式地为 <code>类类型的成员</code> 和它的基类调用有关的默认构造函数.
</p>

<p>
<code>如果程序员自己写了一个带有默认参数值的构造函数, 也可以将这个构造函数认为是默认构造函数</code>, 如上面例子中的 Table 类.
</p>

<p>
考虑如下代码:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">struct</span> <span style="color: #5FD7FF;">Tables</span> {
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>;
    <span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">vi</span>[10];
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t1</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">vt</span>[10];
};

<span style="color: #5FD7FF;">Tables</span> <span style="color: #FF8C00;">tt</span>;
</pre>
</div>
<p>
Tables里面没有声明构造函数, 因此会调用默认构造函数. 默认构造函数只初始化类类型的成员, 所以它不会去初始化 tt.i, tt.vi, 因为它们不是类类型的对象.
</p>

<p>
const和引用必须在初始化列表中进行初始化, 而不能在构造函数中.
</p>
</div>
</div>

<div id="outline-container-org826e939" class="outline-3">
<h3 id="org826e939">构造和析构</h3>
<div class="outline-text-3" id="text-org826e939">
<p>
下面分情况讨论建立对象和销毁对象的时机.
</p>
</div>

<div id="outline-container-orgc457193" class="outline-4">
<h4 id="orgc457193">局部对象</h4>
<div class="outline-text-4" id="text-orgc457193">
<p>
局部变量(栈上分配), 在程序遇到它时建立, 离开它所出现的块是销毁. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">f</span>() {
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">aa</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
<p>
对象 aa 在函数返回时被析构.
</p>
</div>

<div id="outline-container-org7aac8b2" class="outline-5">
<h5 id="org7aac8b2">对象的复制</h5>
<div class="outline-text-5" id="text-org7aac8b2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">h</span>() {
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t1</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t2</span> = t1;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">t3</span>;
    t3 = t2;
}
</pre>
</div>
<p>
在这个例子中, 默认构造函数调用 2 次, 析构函数调用 3 次:
</p>
<ul class="org-ul">
<li>Table t1: 默认构造函数;</li>

<li>Table t2 = t1: 默认对象的赋值操作; 按成员赋值, 其中关于指针 p, 做法是 t2.p = t1.p, 没有内存分配, t1.p 和 t2.p 指向同一块内存.</li>

<li>Table t3: 默认构造函数; 为 t3.p 分配了一块内存.</li>

<li>t3 = t2: 原来的 t3.p 被 t2.p 覆盖, 此时 t1.p, t2.p, t3.p 指向同一块内存. 而原本的 t3.p 所占用的内存不再有指针指向它, 无法利用到, 资源浪费了.</li>
</ul>

<p>
在 h() 返回时, 进行了三次析构, 对 t1.p, t2.p, t3.p 所指的同一块内存删除了三次. 这种行为非常危险, 有可能第一次删除后, 该内存马上被利用, 然后又进行了第二次删除.
</p>

<p>
解决办法: 将 Table 的复制定义清楚.
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Table</span> {
    <span style="color: #87D700;">Table</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp;);
    <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp;);
};

<span style="color: #AF87FF;">Table</span>::<span style="color: #87D700;">Table</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF8C00;">t</span>) {
    p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz=t.sz];
    <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>=0; i&lt;sz; i++) p[i] = t.p[i];
}

<span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #AF87FF;">Table</span>::<span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Table</span>&amp; <span style="color: #FF8C00;">t</span>) {
    <span style="color: #FF1493;">if</span> (<span style="color: #FF1493;">this</span> != &amp;t) {  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">&#38450;&#27490;&#33258;&#36171;&#20540;</span>
        <span style="color: #FF1493;">delete</span>[] p;
        p = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Name</span>[sz=t.sz];
        <span style="color: #FF1493;">for</span> (<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>=0; i&lt;sz; i++) p[i] = t.p[i];
    }
    <span style="color: #FF1493;">return</span> *<span style="color: #FF1493;">this</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf1afb1f" class="outline-4">
<h4 id="orgf1afb1f">自由存储</h4>
<div class="outline-text-4" id="text-orgf1afb1f">
<p>
自由存储对象(堆上分配), 使用 new 运算符建立, delete 运算符销毁.
</p>
</div>
</div>

<div id="outline-container-orgb8efe44" class="outline-4">
<h4 id="orgb8efe44">类对象作为成员</h4>
<div class="outline-text-4" id="text-orgb8efe44">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">class</span> <span style="color: #5FD7FF;">Club</span> {
    <span style="color: #5FD7FF;">string</span> <span style="color: #FF8C00;">name</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">members</span>;
    <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">officers</span>;
    <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">founded</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
    <span style="color: #87D700;">Club</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">string</span>&amp; <span style="color: #FF8C00;">n</span>, <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">fd</span>);
};

<span style="color: #AF87FF;">Club</span>::<span style="color: #87D700;">Club</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">string</span>&amp; <span style="color: #FF8C00;">n</span>, <span style="color: #5FD7FF;">Date</span> <span style="color: #FF8C00;">fd</span>)
    : name(n), members(), officers(), founded(fd) {
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}
</pre>
</div>
<p>
对于引用类型, const类型, 类类型的成员变量, 都建议在初始化列表中进行初始化. 这边重点讨论类类型的成员变量, 为什么要在初始化列表中进行初始化?
</p>

<ul class="org-ul">
<li>必要性. 如果这个类成员变量的构造函数只有带参数这一种, 则它的声明要这样:</li>
</ul>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">CMember</span>* <span style="color: #FF8C00;">pm</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">CMember</span>;  <span style="color: #8B8878;">// </span><span style="color: #8B8878;">Error</span>
<span style="color: #5FD7FF;">CMember</span>* <span style="color: #FF8C00;">pm</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">CMember</span>(2); <span style="color: #8B8878;">// </span><span style="color: #8B8878;">OK</span>
</pre>
</div>
<p>
所以, 如果 CMember 的对象是另一个类的成员, 则必须使用初始化列表:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #AF87FF;">CMyClass</span>::<span style="color: #87D700;">CMyClass</span>() : m_member(2) { <span style="color: #8B8878;">// </span><span style="color: #8B8878;">... }</span>
</pre>
</div>

<ul class="org-ul">
<li>效率. 编译器问题确保所有成员对象在构造函数执行之前初始化, 所以会先调用成员的默认构造函数, 完成成员初始化后再进入构造函数体中执行赋值操作. 所以如果在构造函数内赋值, 其实是调用了两次构造函数, 一次是进入构造函数之前, 另一次是在构造函数内部赋值; 如果在初始化列表中初始化, 则在构造函数内部就不再赋值了.</li>
</ul>

<p>
最后, 类类型的成员变量的构造函数调用顺序, 与它们在类中声明的顺序有关, 与它们在初始化列表中的顺序无关.
</p>
</div>

<div id="outline-container-orgec50a9d" class="outline-5">
<h5 id="orgec50a9d">成员的复制</h5>
<div class="outline-text-5" id="text-orgec50a9d">
<p>
如果程序员没有编写拷贝构造函数和赋值操作, 则会自动生成. 所以如果想要禁止复制行为, 就要明确写出这两个函数, 并声明为私有. 如:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #FF1493;">private</span>:
    Unique_handle(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Unique_handle</span>&amp;);
    <span style="color: #5FD7FF;">Unique_handle</span>&amp; <span style="color: #FF1493;">operator</span><span style="color: #87D700;">=</span>(<span style="color: #FF1493;">const</span> <span style="color: #5FD7FF;">Unique_handle</span>&amp;);
</pre>
</div>

<p>
另外, 系统生成的这两种函数, 执行的是浅拷贝, 所以如果确定要使用深拷贝, 需要自己小心编写.
</p>
</div>
</div>
</div>

<div id="outline-container-org7317f8f" class="outline-4">
<h4 id="org7317f8f">数组</h4>
<div class="outline-text-4" id="text-org7317f8f">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">tbl</span>[10];
</pre>
</div>
<p>
这会建立一个包含 10 个 Table 的数组, 并用默认参数 15 调用 Table::Table() 进行初始化.
</p>

<p>
C 风格的数组:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">Table</span>* <span style="color: #FF8C00;">t1</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Table</span>;
<span style="color: #5FD7FF;">Table</span>* <span style="color: #FF8C00;">t2</span> = <span style="color: #FF1493;">new</span> <span style="color: #5FD7FF;">Table</span>[sz];

<span style="color: #FF1493;">delete</span> t1;
<span style="color: #FF1493;">delete</span>[] t2;
</pre>
</div>

<p>
改成使用 STL:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">vector</span>&lt;Table&gt;* <span style="color: #FF8C00;">p1</span> = <span style="color: #FF1493;">new</span> vector&lt;Table&gt;(10);
<span style="color: #FF1493;">delete</span> p1;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0b60bb" class="outline-4">
<h4 id="orgb0b60bb">静态局部存储</h4>
<div class="outline-text-4" id="text-orgb0b60bb">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5FD7FF;">void</span> <span style="color: #87D700;">f</span>(<span style="color: #5FD7FF;">int</span> <span style="color: #FF8C00;">i</span>) {
    <span style="color: #FF1493;">static</span> <span style="color: #5FD7FF;">Table</span> <span style="color: #FF8C00;">tbl</span>;
    <span style="color: #8B8878;">// </span><span style="color: #8B8878;">...</span>
}

<span style="color: #5FD7FF;">int</span> <span style="color: #87D700;">main</span>() {
    f(0);
    f(1);
}
</pre>
</div>
<p>
f(0) 的时候会构造一次, 而 f(1) 时不再构造.
</p>
</div>
</div>

<div id="outline-container-orga6df076" class="outline-4">
<h4 id="orga6df076">非局部存储</h4>
<div class="outline-text-4" id="text-orga6df076">
<ul class="org-ul">
<li>数组元素, 在数组建立时建立, 在数组销毁时销毁.</li>
<li>局部静态对象, 在程序第一次遇到它的声明时建立一次, 在程序终止时销毁.</li>
<li>全局对象, 名字空间对象, 类的静态对象, 在程序开始时建立一次, 在程序终止时销毁一次.</li>
<li>临时对象, 作为表达式求值的一部分被建立, 在表达式的最后被销毁.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf4bf493" class="outline-4">
<h4 id="orgf4bf493">局部变量</h4>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-06-30</span>
            <span title="last modification date" class="post-info">2018-07-02</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/c++">C++</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_url = "https://pinvondev.github.io/blog/C++/2018/06/30/类/ Or /blog/C++/类/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
            <script type="text/javascript" src="/media/js/love.js"></script>
</div>

  </div></body>
</html>
