#+TITLE:       数字签名与数字证书
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-04-06 五
#+URI:         /blog/%y/%m/%d/数字签名与数字证书
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        密码学
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 通俗解释

1. B有一对密钥, 分别是公钥和私钥.
2. B把公钥送给他的朋友们: A, C, D.
3. A给B写信. 写完后用B的公钥加密, 就可达到保密的效果.
4. B收到A的信. 用私钥解密, 可以看到信的内容. 只要B的私钥不泄露, 就算信在别人手中, 信件内容也无法破解.
5. B给A回信, 采用数字签名. 先将回件的内容用Hash函数生成内容摘要, 再用私钥对摘要加密, 生成数字签名. (其实数字签名是对内容直接用私钥加密, 但是一般情况下, 信息较大, 直接加密的话运算量很大, 所以一般会先对信息提取摘要, 算法有SHA-256等, 再对摘要用私钥加密)
6. B将数字签名附在信件下面, 发给A.
7. A收到信后, 取下数字签名, 用B的公钥解密, 得到信件的摘要. 由此证明, 信确实是B发出的.
8. A再对信件本身使用Hash函数, 将得到的结果, 与B给的摘要进行对比, 如果两者一致, 就证明这封信未被修改.
9. C想欺骗A, C偷偷使用A的电脑, 用自己的公钥换走了B的公钥. 此时, A实际拥有的是C的公钥. 因此, C就可以冒充B, 用自己的私钥做成数字签名, 写信给A.
10. A感觉不对劲, 发现自己无法确定公钥是否真的属于B. 于是, A要求B去证书中心(CA), 为公钥做认证. 证书中心用自己的私钥, 对B的公钥和一些相关信息一起加密, 生成数字证书. 如图1所示.
11. B拿到数字证书以后, 就可以放心了, 以后再给A写信, 只要在签名的同时, 再附上数字证书就行了.
12. A收到信后, 用CA的公钥解开数字证书, 拿到B的公钥, 然后就能证明数字签名是否真的是B签的.

#+CAPTION: 图1
[[./0.png]]

** 实例(https, 主要用于网页加密)

1. Client向Server发出加密请求.
2. Server用自己的私钥加密网页后, 连同本身的数字证书, 一起发给Client.
3. Client(浏览器)在证书管理器中有"受信任的根证书颁发机构"列表. Client会根据该列表, 查看解开数字证书的公钥是否在列表之内.
4. 如果数字证书记载的网址, 与正在浏览的网址不一致, 就说明该证书可能被冒用, 浏览器会发出警告.
5. 如果该数字证书不是由受信任的机构颁发的, 浏览器会发出另一种警告.
6. 如果数字证书是可靠的, Client就可以使用证书中的Server公钥, 对信息进行加密, 然后与服务器交换加密信息.
