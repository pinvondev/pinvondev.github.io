<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Emacs Lisp 教程 - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="Tutorial" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Emacs Lisp 教程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb8dec4d">声明</a></li>
<li><a href="#orgec84b35">执行程序</a></li>
<li><a href="#org940483b">基础知识</a>
<ul>
<li><a href="#org11fc41b">函数和变量</a>
<ul>
<li><a href="#org6101bfb">函数</a></li>
<li><a href="#orgc1ea935">全局变量</a></li>
<li><a href="#orgb79a113">局部变量</a></li>
<li><a href="#org3ef0a34">lambda表达式</a></li>
</ul>
</li>
<li><a href="#orgfb2b56b">控制结构</a>
<ul>
<li><a href="#orgbeace20">顺序执行</a></li>
<li><a href="#org461c3c3">条件判断</a></li>
<li><a href="#org42ca866">循环</a></li>
</ul>
</li>
<li><a href="#org287f9ff">逻辑运算</a></li>
</ul>
</li>
<li><a href="#org8a52b59">数字</a>
<ul>
<li><a href="#orgc07ea83">测试函数</a></li>
<li><a href="#orgda550b4">数的比较</a></li>
<li><a href="#org3012dfd">数的转换</a></li>
<li><a href="#orgd006292">数的运算</a></li>
</ul>
</li>
<li><a href="#org1cbbc62">字符和字符串</a>
<ul>
<li><a href="#org32a8ed2">字符</a></li>
<li><a href="#orgdea640a">测试函数</a></li>
<li><a href="#org91de28a">构造函数</a></li>
<li><a href="#org77e7c0e">字符串比较</a></li>
<li><a href="#org40fb964">转换函数</a></li>
<li><a href="#org1073c22">查找和替换</a></li>
</ul>
</li>
<li><a href="#org8036f7d">cons cell和列表</a>
<ul>
<li><a href="#org837f109">读入cons cell</a></li>
<li><a href="#orgc2b001a">列表和cons cell的关系</a></li>
<li><a href="#orgef92eeb">测试函数</a></li>
<li><a href="#orgd9eb760">构造函数</a></li>
<li><a href="#org00f86b6">增加元素到列表</a></li>
<li><a href="#org09f500d">把列表当作数组</a></li>
<li><a href="#orgfd67077">修改cons cell的内容</a></li>
<li><a href="#orgf6467b3">把列表当堆栈用</a></li>
<li><a href="#orge14a6a6">重排列表</a></li>
<li><a href="#orgd3f434a">把列表当关联表</a></li>
<li><a href="#org4ea3cda">遍历列表</a></li>
</ul>
</li>
<li><a href="#org7be56d7">数组和序列</a>
<ul>
<li><a href="#org417b2b7">测试函数</a></li>
<li><a href="#orgf1d3d94">序列的通用函数</a></li>
<li><a href="#orga3545ba">数组操作</a></li>
</ul>
</li>
<li><a href="#orgde490b2">符号</a>
<ul>
<li><a href="#org31a844f">创建符号</a></li>
<li><a href="#orge22bde3">符号的组成</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb8dec4d" class="outline-2">
<h2 id="orgb8dec4d">声明</h2>
<div class="outline-text-2" id="text-orgb8dec4d">
<p>
学习自<a href="http://smacs.github.io/elisp/">happierbee</a>写的教程.
</p>
</div>
</div>

<div id="outline-container-orgec84b35" class="outline-2">
<h2 id="orgec84b35">执行程序</h2>
<div class="outline-text-2" id="text-orgec84b35">
<p>
在*scratch*中, 写完一行代码后, 在代码最后面键入C-j, 或者C-x C-e.
</p>
</div>
</div>

<div id="outline-container-org940483b" class="outline-2">
<h2 id="org940483b">基础知识</h2>
<div class="outline-text-2" id="text-org940483b">
</div>
<div id="outline-container-org11fc41b" class="outline-3">
<h3 id="org11fc41b">函数和变量</h3>
<div class="outline-text-3" id="text-org11fc41b">
</div>
<div id="outline-container-org6101bfb" class="outline-4">
<h4 id="org6101bfb">函数</h4>
<div class="outline-text-4" id="text-org6101bfb">
<p>
函数的例子:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(defun hello-world (name)
  "say hello to user whose name is NAME."
  (message "Hello, %s" name))

;; 调用
(hello-world "Emacser")
</pre>
</div>
<p>
函数的返回值是函数里的最后一个表达式.
</p>
</div>
</div>

<div id="outline-container-orgc1ea935" class="outline-4">
<h4 id="orgc1ea935">全局变量</h4>
<div class="outline-text-4" id="text-orgc1ea935">
<p>
由于Elisp中函数是全局的, 所以变量也很容易成为全局变量.
</p>
</div>

<ul class="org-ul">
<li><a id="orgc8a3f74"></a>setq<br />
<div class="outline-text-5" id="text-orgc8a3f74">
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo "I am Emacser") ;; "I am Emacser"
(message foo) ;; "I am Emacser"
</pre>
</div>
</div>
</li>

<li><a id="orgf719c52"></a>defvar<br />
<div class="outline-text-5" id="text-orgf719c52">
<p>
defvar也可以定义变量, 但是如果定义的变量在之前有赋过值, 则不起作用. 另外, defvar可以为变量提供文档字符串, 即可以使用C-h v来查看变量的说明.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(defvar variable-name value
    "document string")

;; 例子
(defvar foo "Did I have a value"
  "A demo variable")
(message foo) ;; "I am Emacser", 因为之前已经用setq对foo赋过值

(defvar bar "I am bar"
  "A demo variable name")
(message bar) ;; "I am bar", 由于之前没有对bar赋值, 因此本次生效
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgb79a113" class="outline-4">
<h4 id="orgb79a113">局部变量</h4>
<div class="outline-text-4" id="text-orgb79a113">
<p>
Elisp中使用 <code>let</code> 或 <code>let*</code> 来对局部变量进行绑定.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(defun circle-area (radix)
  (let ((pi 3.1415926)
        area)
    (setq area (* pi radix radix))
    (message "直径为 %.2f 的圆面积是 %.2f" radix area)))
(circle-area 3)
;; 或者
(defun circle-area (radix)
  (let* ((pi 3.1415926)
         (area (* pi radix radix)))
    (message "直径为 %.2f 的圆面积是 %.2f" radix area)))
</pre>
</div>
<p>
let*和let的使用形式完全相同, 区别在于let*在声明中就能使用前面声明的变量.
</p>
</div>
</div>

<div id="outline-container-org3ef0a34" class="outline-4">
<h4 id="org3ef0a34">lambda表达式</h4>
<div class="outline-text-4" id="text-org3ef0a34">
<div class="org-src-container">
<pre class="src src-Elisp">(lambda (arguments-list)
    "documentation string"
    body)
;; 调用
(funcall (lambda (name)
    (message "Hello %s" name)) "Emacser")
</pre>
</div>
<p>
也可以把lambda表达式赋值给一个变量, 再用funcall来调用:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo (lambda (name)
    (message "Hello %s" name)))
(funcall foo "Emacser")
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfb2b56b" class="outline-3">
<h3 id="orgfb2b56b">控制结构</h3>
<div class="outline-text-3" id="text-orgfb2b56b">
</div>
<div id="outline-container-orgbeace20" class="outline-4">
<h4 id="orgbeace20">顺序执行</h4>
<div class="outline-text-4" id="text-orgbeace20">
<p>
使用progn.
</p>
</div>
</div>

<div id="outline-container-org461c3c3" class="outline-4">
<h4 id="org461c3c3">条件判断</h4>
<div class="outline-text-4" id="text-org461c3c3">
<div class="org-src-container">
<pre class="src src-Elisp">(if condition true_body false_body)
</pre>
</div>

<p>
还有一个条件判断的方法, 有点像C中的switch-case, 结构如下:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(cond (case1 body)
    (case2 body)
    ...
    (t body)) ;; 前面的情况都不符合时, 执行这条语句

;; 例子
(defun fib (n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (fib (- n 1)) (fib (- n 2))))))
(fib 10) ;; returns 55
</pre>
</div>
</div>
</div>

<div id="outline-container-org42ca866" class="outline-4">
<h4 id="org42ca866">循环</h4>
<div class="outline-text-4" id="text-org42ca866">
<div class="org-src-container">
<pre class="src src-Elisp">(while condition body)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org287f9ff" class="outline-3">
<h3 id="org287f9ff">逻辑运算</h3>
<div class="outline-text-3" id="text-org287f9ff">
<p>
and和or具有短路性质, or常用于设置函数的默认参数, and用于参数检查. 如:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(defun hello-world (&amp;optional name)
  (or name (setq name "Emacser"))
  (message "Hello %s" name))
(hello-world) ;; "Hello Emacser"
(hello-world "Vim") ;; "Hello Vim"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-Elisp">(defun square-number-p (n)
  (and (&gt;= n 0) (= (/ n (sqrt n)) (sqrt n)))) ;; (n &gt;= 0) &amp;&amp; (n/sqrt(n))  == (sqrt(n))
(square-number-p -1) ;; nil
(square-number-p 25) ;; t
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8a52b59" class="outline-2">
<h2 id="org8a52b59">数字</h2>
<div class="outline-text-2" id="text-org8a52b59">
<p>
emacs的数字分为整数和浮点数.
</p>
</div>

<div id="outline-container-orgc07ea83" class="outline-3">
<h3 id="orgc07ea83">测试函数</h3>
<div class="outline-text-3" id="text-orgc07ea83">
<p>
是否为整数类型: integerp
是否为浮点数类型: floatp
是否为数字类型: numberp
是否为0: zerop
是否为非负整数: wholenump
</p>
</div>
</div>

<div id="outline-container-orgda550b4" class="outline-3">
<h3 id="orgda550b4">数的比较</h3>
<div class="outline-text-3" id="text-orgda550b4">
<p>
由于Elisp中的赋值是setq函数, 所以=就是比较两个数字是否相等. 还有一些跟比较有关的操作符: &gt;, &lt;, &gt;=, &lt;=
</p>

<p>
由于精度的原因, 如果比较两个浮点数, 一般结果都是不相等, 正确的比较, 应该在一定的误差内进行比较.
</p>

<p>
eql可以比较两个数字的值和类型是否都一致.
</p>

<p>
注意, 不等号是/=.
</p>
</div>
</div>

<div id="outline-container-org3012dfd" class="outline-3">
<h3 id="org3012dfd">数的转换</h3>
<div class="outline-text-3" id="text-org3012dfd">
<p>
整数-&gt;浮点数: float
浮点数-&gt;整数: 向上取整(ceiling), 向下取整(floor), 四舍五入(round)
</p>
</div>
</div>

<div id="outline-container-orgd006292" class="outline-3">
<h3 id="orgd006292">数的运算</h3>
<div class="outline-text-3" id="text-orgd006292">
<p>
与其他语言类似.
没有++和--, 可以这样写: (setq foo (1+ foo))和(setq foo (1- foo))
取余: %或mod函数, %要求第1个参数为整数, 而mod则没有这个要求
绝对值: abs
三角函数: sin, cos, tan, asin, acos, atan
开方: sqrt
指数: exp是以e为底的指数运算, expt可以自己指定底数
对数: log, 底数默认为e, 也可以自己指定 (log arg &amp;optional base)
随机数: random, (random t)可以产生新种子
</p>
</div>
</div>
</div>

<div id="outline-container-org1cbbc62" class="outline-2">
<h2 id="org1cbbc62">字符和字符串</h2>
<div class="outline-text-2" id="text-org1cbbc62">
<p>
Elisp中的字符串是有序的字符数组, 和C不同的是, Elisp中的字符串可以容纳任何字符, 包括\0.
</p>
</div>

<div id="outline-container-org32a8ed2" class="outline-3">
<h3 id="org32a8ed2">字符</h3>
<div class="outline-text-3" id="text-org32a8ed2">
<p>
字符的读入语法, 是在字符前加问号:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">?A ;; 65
?\a ;; 转义字符, 7
?\C-i ;; 表示键入的Ctrl-i, 9
?\M-A ;; 表示键入的Alt-A
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdea640a" class="outline-3">
<h3 id="orgdea640a">测试函数</h3>
<div class="outline-text-3" id="text-orgdea640a">
<p>
是否为字符串: stringp; 没有charp, 因为字符就是整数.
string-or-null-p: 对象是一个字符或nil时, 返回t
char-or-string-p: 对象是否为字符串或字符
</p>

<p>
Elisp没有测试字符串是否为空的函数, 需要自定义:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(defun string-emptyp (str)
    (not (string&lt; "" str)))
</pre>
</div>
</div>
</div>

<div id="outline-container-org91de28a" class="outline-3">
<h3 id="org91de28a">构造函数</h3>
<div class="outline-text-3" id="text-org91de28a">
<div class="org-src-container">
<pre class="src src-Elisp">(make-string 5 ?x) ;; "xxxxx"
(string ?a ?b ?c) ;; "abc"
(substring "0123456789" 3 5) ;; "34"
(concat "0" "1") ;; "01"
</pre>
</div>
</div>
</div>

<div id="outline-container-org77e7c0e" class="outline-3">
<h3 id="org77e7c0e">字符串比较</h3>
<div class="outline-text-3" id="text-org77e7c0e">
<p>
char-equal: 比较两个字符是否相等. 通常case-fold-search都是t, 表示忽略大小写
string=: 字符串比较; string-equal是别名
string&lt;: 按字典序比较, string-less是别名
空字符串小于所有字符串, length可以检测字符串长度, 所以也可以用length来判断字符串是否为空.
</p>
</div>
</div>

<div id="outline-container-org40fb964" class="outline-3">
<h3 id="org40fb964">转换函数</h3>
<div class="outline-text-3" id="text-org40fb964">
<p>
string-to-char: 只返回字符串的第一个字符
char-to-string: 字符转字符串
string-to-number
number-to-string: 只能转10进制的数字, 若要输出其他进制, 可以用format函数, (format "%#o" 256)
concat: 可以把一个字符构成的列表或向量转成字符串
vconcat: 可以把字符串转成列表
downcase/upcase: 大小写转换
capitalize: 第1个字符大写, 其他小写
upcase-initials: 第1个字符大写, 其他不管
</p>
</div>
</div>

<div id="outline-container-org1073c22" class="outline-3">
<h3 id="org1073c22">查找和替换</h3>
<div class="outline-text-3" id="text-org1073c22">
<p>
(string-match regexp string &amp;optional start): 从指定位置对字符串进行正则表达式匹配.
</p>

<p>
有时需要对正则表达式进行处理:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(string-match "2*" "232*3=696")  ;; 0
(string-match (regexp-quote "2*") "232*3=696")  ;;  2
</pre>
</div>

<p>
(replace-match newtext &amp;optional fixedcase literal string subexp): 替换函数
如: (replace-match "x" nil nil str 0)
</p>
</div>
</div>
</div>
<div id="outline-container-org8036f7d" class="outline-2">
<h2 id="org8036f7d">cons cell和列表</h2>
<div class="outline-text-2" id="text-org8036f7d">
<p>
cons cell是一种数据结构, 仅包含两个元素, 第一个叫CAR, 第二个叫CDR. CAR和CDR可以引用任何对象.
</p>
</div>

<div id="outline-container-org837f109" class="outline-3">
<h3 id="org837f109">读入cons cell</h3>
<div class="outline-text-3" id="text-org837f109">
<div class="org-src-container">
<pre class="src src-Elisp">'(1 . 2)  ;;  (1 . 2)
</pre>
</div>

<p>
cons cell前面有个单引号的意思: 
eval-last-sexp的步骤: 读入前一个S-表达式, 然后对这个表达式求值. 
数字和字符串是一类特殊的S-表达式, 它们求值前和求值后都不变, 也称为自求值表达式.
'其实是quote函数, 它的作用是将参数返回, 而不求值.
</p>
</div>
</div>

<div id="outline-container-orgc2b001a" class="outline-3">
<h3 id="orgc2b001a">列表和cons cell的关系</h3>
<div class="outline-text-3" id="text-orgc2b001a">
<p>
<code>列表 = cons cell + 空表</code>
</p>
<div class="org-src-container">
<pre class="src src-Elisp">'()  ;;  nil
</pre>
</div>

<p>
空表不是cons cell, 因为它没有CAR和CDR两个部分. 如果一个cons cell为(1 . nil), 则可以简写成(1).
</p>

<p>
假如有以下cons cell:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">'(1 . (2 . (3 . nil)))  ;;  (1 2 3)
</pre>
</div>
<p>
可以看出, 这个cons cell内部又嵌套了两个cons cell. 读入后输出是一个列表.
</p>
</div>
</div>

<div id="outline-container-orgef92eeb" class="outline-3">
<h3 id="orgef92eeb">测试函数</h3>
<div class="outline-text-3" id="text-orgef92eeb">
<div class="org-src-container">
<pre class="src src-Elisp">(consp '(1 . 3))  ;;  t
(consp '(1 3))  ;;  t
(consp '(1 3 4))  ;;  t
(consp nil)  ;;  nil
(listp '(1 3 4))  ;;  t
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd9eb760" class="outline-3">
<h3 id="orgd9eb760">构造函数</h3>
<div class="outline-text-3" id="text-orgd9eb760">
<p>
生成一个cons cell可以用cons函数.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(cons 1 3)  ;;  (1 . 3)
</pre>
</div>

<p>
在列表前面增加元素:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo '(a b))  ;;  (a b)
(cons 'x foo)  ;;  (x a b)
</pre>
</div>

<p>
也可以使用宏push来加入元素:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(push 'x foo)  ;;  (x a b)
</pre>
</div>

<p>
list函数可以生成一个列表:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(list 1 2 3)  ;;  (1 2 3)
</pre>
</div>

<p>
前面几个例子中, 产生一个列表, 经常要用到quote函数, 直接使用cons或list函数来产生列表, 与使用quote函数来产生列表, 有什么区别?
</p>
<div class="org-src-container">
<pre class="src src-Elisp">'((+ 1 2) 3)  ;;  ((+ 1 2) 3)
(list (+ 1 2) 3)  ;;  (3 3)
</pre>
</div>
<p>
可以看出, quote是直接把参数返回, 而不进行求值; 而list是对参数求值后再生成一个列表.
</p>
</div>
</div>

<div id="outline-container-org00f86b6" class="outline-3">
<h3 id="org00f86b6">增加元素到列表</h3>
<div class="outline-text-3" id="text-org00f86b6">
<p>
在列表前增加元素:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo '(a b))  ;;  (a b)
(cons 'x foo)  ;;  (x a b)
</pre>
</div>

<p>
在列表后增加元素:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(append '(a b) '(c))  ;;  (a b c)
</pre>
</div>

<p>
append的参数也不一定就非要列表, 也可以是其他对象:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(append '(a b) 'c)  ;;  (a b . c)
</pre>
</div>
<p>
对这个结果再使用append函数, 会报错.
</p>

<p>
append函数还可以将向量转成列表:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(append [a b] "cd" nil)  ;;  (a b 99 100)

;;  nil是必须的, 否则结果如下

(append [a b] "cd")  ;;  (a b . "cd")
</pre>
</div>
</div>
</div>

<div id="outline-container-org09f500d" class="outline-3">
<h3 id="org09f500d">把列表当作数组</h3>
<div class="outline-text-3" id="text-org09f500d">
<p>
对于一个列表, 可以使用car函数取第一个元素, cadr函数取第二个元素, cdr取剩下的元素.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(car '(0 1 2 3 4 5))  ;;  0
(cadr '(0 1 2 3 4 5))  ;;  1
(cdr '(0 1 2 3 4 5))  ;;  (1 2 3 4 5)
</pre>
</div>

<p>
取第n个元素, 可以使用nth函数:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(nth 3 '(0 1 2 3 4 5))  ;;  3
</pre>
</div>

<p>
<code>列表是由链表这种数据结构来实现的, 不适合随机访问, 如果经常要使用这些操作, 还是要用数组更合适</code>.
</p>
</div>
</div>

<div id="outline-container-orgfd67077" class="outline-3">
<h3 id="orgfd67077">修改cons cell的内容</h3>
<div class="outline-text-3" id="text-orgfd67077">
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo '(a b c))  ;;  (a b c)
(setcar foo 'x)  ;;  x
foo  ;;  (x b c)
(setcdr foo '(y z))  ;;  (y z)
foo  ;;  (x y z)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf6467b3" class="outline-3">
<h3 id="orgf6467b3">把列表当堆栈用</h3>
<div class="outline-text-3" id="text-orgf6467b3">
<p>
后进先出
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo nil)  ;;  nil
(push 'a foo)  ;;  (a)
(push 'b foo)  ;;  (b a)
(pop foo)  ;;  b
</pre>
</div>
</div>
</div>

<div id="outline-container-orge14a6a6" class="outline-3">
<h3 id="orge14a6a6">重排列表</h3>
<div class="outline-text-3" id="text-orge14a6a6">
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo '(a b c))  ;;  (a b c)
(reverse foo)  ;;  (c b a)
</pre>
</div>

<p>
sort函数是个破坏性函数, 有可能会在不知不觉间丢失列表元素.
</p>
</div>
</div>

<div id="outline-container-orgd3f434a" class="outline-3">
<h3 id="orgd3f434a">把列表当关联表</h3>
<div class="outline-text-3" id="text-orgd3f434a">
<p>
关联表(association list)指的是键值对. Elisp中有hash table, 但是hash table有几个缺点:
</p>

<ol class="org-ol">
<li>hash table里的关键字key是无序的, 而关联表的关键字可以按想要的顺序排列.</li>
<li>hash table没有列表那样丰富的函数可用.</li>
<li>hash table没有读入语法和输入形式, 这对于调试和使用都会带来许多不便.</li>
</ol>

<p>
hash table的优点是效率较高.
</p>

<p>
关联表的键放在CAR中, 对应的数据放在CDR中.
</p>

<p>
使用assq(对应eq)和assoc(对应equal)两个函数来查询键所对应的值, 再使用cdr来得到对应的数据.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(assoc "a" '(("a" 97) ("b" 98)))  ;;  ("a" 97)
(cdr (assoc "a" '(("a" 97) ("b" 98))))  ;;  (97)

(assq 'a '((a . 97) (b . 98)))  ;;  (a . 97)
(cdr (assq 'a '((a . 97) (b . 98))))  ;;  97
</pre>
</div>

<p>
assoc-default可以一次性完成这样的操作:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(assoc-default "a" '(("a" 97) ("b" 98)))  ;;  (97)
</pre>
</div>

<p>
已知值, 查找对应的键:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(rassoc '(97) '(("a" 97) ("b" 98) ))  ;;  ("a" 97)
(rassq '97 '((a . 97) (b . 98)))  ;;  (a . 97)
</pre>
</div>

<p>
修改关键字对应值的方法:
</p>
<ol class="org-ol">
<li>使用cons把新的键值对加到列表的前端. 但是这样会让列表越来越长, 浪费空间.</li>
<li>使用setcdr来更改键对应的值, 但是这要先确定键值对在这个列表中, 否则会出错.</li>
<li>用assoc查找对应的元素, 再用delq删除该数据, 最后用cons加到列表中.</li>
</ol>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo '(("a" . 97) ("b" . 98)))  ;;  (("a" . 97) ("b" . 98))

;;  使用setcdr来修改
(if (setq bar (assoc "a" foo))
    (setcdr bar "this is a")
  (setq foo (cons '("a" . "this is a") foo)))  ;;  "this is a"
foo  ;;  (("a" . "this is a") ("b" . 98))

;;  使用assoc, delq, cons来修改
(setq foo (cons '("a" . 97)
                (delq (assoc "a" foo) foo)))  ;;  (("a" . 97) ("b" . 98))
</pre>
</div>
<p>
推荐使用最后一种, 代码简洁.
</p>
</div>
</div>

<div id="outline-container-org4ea3cda" class="outline-3">
<h3 id="org4ea3cda">遍历列表</h3>
<div class="outline-text-3" id="text-org4ea3cda">
<p>
使用函数mapc或mapcar来遍历列表. 它们的第一个参数是一个函数, 该函数只接受一个参数, 每次处理列表里的一个元素. 区别是: 前者返回的还是输入的列表, 后者返回的是函数返回值构成的列表.
</p>
<div class="org-src-container">
<pre class="src src-Elsip">(mapc '1+ '(1 2 3))  ;;  (1 2 3)
(mapcar '1+ '(1 2 3))  ;;  (2 3 4)
</pre>
</div>

<p>
还有一种遍历列表的方法: dolist.
语法结构: (dolist (var list [result]) body...)
</p>

<p>
var是一个临时变量, 在body里可以用来得到列表中元素的值. 如果不指定返回值, 则返回nil.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(dolist (foo '(1 2 3))
  (1+ foo))  ;;  nil
(setq bar nil)
(dolist (foo '(1 2 3) bar)
  (push (1+ foo) bar))  ;;  (4 3 2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7be56d7" class="outline-2">
<h2 id="org7be56d7">数组和序列</h2>
<div class="outline-text-2" id="text-org7be56d7">
<p>
序列=数组+列表
数组=字符串+向量+char table和boolean vector
</p>

<ol class="org-ol">
<li>数组的第一个元素下标为0.</li>
<li>数组内的元素可以在常数时间内访问.</li>
<li>数组在创建后无法改变长度.</li>
<li>用aref访问数组, aset设置数组.</li>
</ol>

<p>
向量可以看成是通用的数组, 它的元素是任意对象.
</p>

<p>
字符串是特殊数组, 它的元素是字符.
</p>
</div>

<div id="outline-container-org417b2b7" class="outline-3">
<h3 id="org417b2b7">测试函数</h3>
<div class="outline-text-3" id="text-org417b2b7">
<p>
sequencep: 测试是否为序列
arrayp: 测试是否为数组
</p>
</div>
</div>

<div id="outline-container-orgf1d3d94" class="outline-3">
<h3 id="orgf1d3d94">序列的通用函数</h3>
<div class="outline-text-3" id="text-orgf1d3d94">
<p>
length: 得到序列长度, 不适用于点列表或环形列表
safe-length: 可以用于点列表和环形列表
elt: 取得序列的第n个元素
nth: 取得列表的第n个元素
aref: 取得数组的第n个元素
</p>
</div>
</div>

<div id="outline-container-orga3545ba" class="outline-3">
<h3 id="orga3545ba">数组操作</h3>
<div class="outline-text-3" id="text-orga3545ba">
<p>
创建数组, 法一:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(vector 'foo 23 [bar baz] "rats")  ;;  [foo 23 [bar baz] "rats"]
</pre>
</div>

<p>
创建数组, 法二:
</p>
<div class="org-src-container">
<pre class="src src-Elisp">foo  ;;  (a b)
[foo]  ;;  [foo]
(vector foo)  ;;  [(a b)]
</pre>
</div>

<p>
make-vector: 生成相同元素的向量
fillarray: 把整个数组用某元素填充
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(make-vector 9 'Z)  ;;  [Z Z Z Z Z Z Z Z Z]
(fillarray (make-vector 3 'Z) 5)  ;;  [5 5 5]
</pre>
</div>

<p>
aref和aset可以用于访问和修改数组的元素, 如果使用下标超出数组长度, 则会出错.
</p>

<p>
vconcat可以把多个序列连成一个向量, 但是这个序列必须是真列表. <code>这是把列表转换成向量的方法, 向量转列表使用append</code>
</p>

<div class="org-src-container">
<pre class="src src-Elisp">(vconcat [A B C] "aa" '(foo (6 7)))  ;;  [A B C 97 97 foo (6 7)]
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgde490b2" class="outline-2">
<h2 id="orgde490b2">符号</h2>
<div class="outline-text-2" id="text-orgde490b2">
<p>
符号是有名字的对象, 通过符号, 可以得到和这个符号相关联的信息, 如值, 函数, 属性列表等等.
</p>

<p>
符号的命名规则: 可包含任何字符, 大多数符号含有字母, 数字和标点(-+=*/). 名字前缀要能把符号名和数字区分开来, 如果需要的话, 可以用\来表示这是一个符号.
</p>

<div class="org-src-container">
<pre class="src src-Elisp">(symbolp '+1)  ;;  nil
(symbolp '\+1)  ;;  t
(symbol-name '\+1)  ;;  "+1"
</pre>
</div>
</div>

<div id="outline-container-org31a844f" class="outline-3">
<h3 id="org31a844f">创建符号</h3>
<div class="outline-text-3" id="text-org31a844f">
<p>
Elisp中会有一个表来保存符号, 这个表称为obarray, 是一个向量.
</p>

<p>
当Emacs创建一个符号时, 首先会对这个名字求hash值, 得到一个obarray的下标.
</p>

<p>
当Elisp读入一个符号时, 通常会先查找这个符号是否在obarray中出现过, 没出现则将该符号加入到obarray中, intern函数完成查找并加入的过程. 我们也可以指定一个obarray来装符号.
</p>

<p>
intern-soft与intern不同的是, 当名字不在obarray中时, intern-soft会返回nil, 而intern会加入到obarray中.
</p>

<p>
为了不污染obarray, 下面的例子使用名为foo的obarray来保存符号. 如果没有foo这个参数, 则会在obarray中进行, 结果相同.
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(setq foo (make-vector 10 0))  ;;  [0 0 0 0 0 0 0 0 0 0]
(intern-soft "abc" foo)  ;;  nil
foo  ;;  [0 0 0 0 0 0 0 0 0 0]
(intern "abc" foo)  ;;  abc
foo  ;;  [0 0 0 0 0 0 0 0 0 abc]
(intern-soft "abc" foo)  ;;  abc
</pre>
</div>

<p>
Elisp每读入一个符号, 都会intern到obarray中, 如果想避免, 则在符号名前加 <code>#:</code>
</p>
<div class="org-src-container">
<pre class="src src-Elisp">(intern-soft "abcd")  ;;  nil
'#:abcd
(intern-soft "abcd")  ;;  nil
</pre>
</div>

<p>
(unintern name &amp;optional obarray): 将name从obarray中去除, 成功去除返回t, 没有查到对应的符号则返回nil.
</p>
</div>
</div>

<div id="outline-container-orge22bde3" class="outline-3">
<h3 id="orge22bde3">符号的组成</h3>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-01-15</span>
        <span title="last modification date" class="post-info">2018-01-16</span>
        <span title="tags" class="post-info"><a href="/tags/emacs/">Emacs</a></span>
        <span title="author" class="post-info">Pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/01/15/emacs-lisp-教程";
          var disqus_url = "http://pinvondev.github.io/blog/2018/01/15/emacs-lisp-教程";
          var disqus_shortname = 'pw lin';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:pinvon &lt;at&gt; Inspiron">Pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
