<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Docker从入门到实践-笔记 - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="&lt;TODO: insert your keywords here&gt;" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Docker从入门到实践-笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8dc4fc2">Docker简介</a>
<ul>
<li>
<ul>
<li><a href="#orgf06c067">什么是Docker</a></li>
<li><a href="#orgc6da075">Docker的好处</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org29ca090">基本概念</a>
<ul>
<li>
<ul>
<li><a href="#org23d1cc9">镜像</a></li>
<li><a href="#org8000558">容器</a></li>
<li><a href="#org641af91">仓库(Docker Registry)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9dc9324">安装Docker</a>
<ul>
<li>
<ul>
<li><a href="#org2249c73">卸载旧版本</a></li>
<li><a href="#orgb4d9992">安装</a></li>
<li><a href="#org742f667">使用镜像加速器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2438ba6">使用镜像</a>
<ul>
<li>
<ul>
<li><a href="#org67376a5">获取镜像</a></li>
<li><a href="#orgb889ee5">列出镜像</a></li>
<li><a href="#orgdd28a40">删除本地镜像</a></li>
<li><a href="#org6a33059">使用Dockerfile定制镜像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4003938">操作容器</a>
<ul>
<li>
<ul>
<li><a href="#org6b0fb1f">启动</a></li>
<li><a href="#org689defe">后台运行</a></li>
<li><a href="#org791c761">终止容器</a></li>
<li><a href="#org3c66c96">进入容器</a></li>
<li><a href="#org1f4a5d9">导入导出</a></li>
<li><a href="#org3275d32">删除容器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2c99f37">访问仓库</a>
<ul>
<li>
<ul>
<li><a href="#org92fa2d4">Docker Hub</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8dc4fc2" class="outline-2">
<h2 id="org8dc4fc2">Docker简介</h2>
<div class="outline-text-2" id="text-org8dc4fc2">
</div>
<div id="outline-container-orgf06c067" class="outline-4">
<h4 id="orgf06c067">什么是Docker</h4>
<div class="outline-text-4" id="text-orgf06c067">
<p>
传统虚拟机技术: 虚拟出一套硬件后, 在其上运行一个完整操作系统, 在该系统上再运行所需应用进程.
</p>

<p>
Docker: 容器内的应用进程直接运行在宿主的内核上, 容器内没有自己的内核, 也没有进行硬件虚拟, 比传统虚拟机更为轻便.
</p>

<p>
如图所示:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/docker从入门到实践-笔记/0.png" alt="0.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc6da075" class="outline-4">
<h4 id="orgc6da075">Docker的好处</h4>
<div class="outline-text-4" id="text-orgc6da075">
<p>
更高效的利用系统资源: 不需要进行硬件虚拟及运行完整操作系统等额外开销.
</p>

<p>
更快速的启动时间: 秒级.
</p>

<p>
一致的运行环境: 提供了除内核外一致的运行时环境.
</p>

<p>
更轻松的迁移
</p>

<p>
更轻松的维护和扩展: Docker团队和许多开源项目团队一起维护了一大批高质量的<a href="https://store.docker.com/search?q=&amp;source=verified&amp;type=image">官方镜像</a>, 既可直接在生产环境使用, 又可以作为基础进一步定制.
</p>
</div>
</div>
</div>

<div id="outline-container-org29ca090" class="outline-2">
<h2 id="org29ca090">基本概念</h2>
<div class="outline-text-2" id="text-org29ca090">
</div>
<div id="outline-container-org23d1cc9" class="outline-4">
<h4 id="org23d1cc9">镜像</h4>
<div class="outline-text-4" id="text-org23d1cc9">
<p>
操作系统分为内核和用户空间, 对于Linux而言, 内核启动后会挂载root文件系统为其提供用户空间支持.
</p>

<p>
Docker镜像就相当于是一个root文件系统. 如官方镜像 ubuntu:16.04 就包含了完整的一套Ubuntu16.04最小系统的root文件系统.
</p>

<p>
Docker镜像就是一个特殊的文件系统, 提供了容器运行时所需的文件与配置参数.
</p>
</div>
</div>

<div id="outline-container-org8000558" class="outline-4">
<h4 id="org8000558">容器</h4>
<div class="outline-text-4" id="text-org8000558">
<p>
镜像和容器的关系, 就像是面向对象程序设计中的类和实例的关系一样. 镜像是静态的定义, 容器是镜像运行时的实体, 容器可以被创建, 启动, 停止, 删除, 暂停等.
</p>
</div>
</div>

<div id="outline-container-org641af91" class="outline-4">
<h4 id="org641af91">仓库(Docker Registry)</h4>
<div class="outline-text-4" id="text-org641af91">
<p>
镜像构建完成后, 可以很容易地在当前宿主机器上运行, 而如果需要在其他主机上使用该镜像, 就需要一个集中的存储, 分发镜像的服务, Docker Registry就是这样的服务.
</p>

<p>
一个Docker Registry中可以包含多个仓库(Repository), 每个仓库可包含多个标签(Tag), 每个标签对应一个镜像. 一般Repository对应一个软件, Tag对应该软件的版本.
</p>

<p>
我们可以通过 <code>&lt;Repository&gt;:&lt;Tag&gt;</code> 来指定具体使用该软件的哪个版本. 如果不给出标签, 将以 <code>latest</code> 作为默认标签. 如: <code>ubuntu:16.04</code>. 如果只写 <code>ubuntu</code>, 则被当成 <code>ubuntu:latest</code>.
</p>

<p>
Docker Registry公开服务是开放给用户使用, 允许用户管理镜像的Registry服务, 如<a href="https://hub.docker.com/">Docker Hub</a>.
</p>

<p>
国内访问这些服务可能会比较慢. 国内有些云服务商提供了针对Docker Hub的镜像服务, 这些镜像服务常被称为加速器, 如<a href="https://cr.console.aliyun.com/#/accelerator">阿里云加速器</a>, <a href="https://www.daocloud.io/mirror#accelerator-doc">DaoCloud加速器</a>.
</p>

<p>
除了公开服务, 也可以自己搭建私有服务.
</p>
</div>
</div>
</div>



<div id="outline-container-org9dc9324" class="outline-2">
<h2 id="org9dc9324">安装Docker</h2>
<div class="outline-text-2" id="text-org9dc9324">
<p>
以Ubuntu为例.
</p>
</div>

<div id="outline-container-org2249c73" class="outline-4">
<h4 id="org2249c73">卸载旧版本</h4>
<div class="outline-text-4" id="text-org2249c73">
<div class="org-src-container">
<pre class="src src-Shell">sudo apt-get remove docker docker-engine docker.io
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4d9992" class="outline-4">
<h4 id="orgb4d9992">安装</h4>
<div class="outline-text-4" id="text-orgb4d9992">
<div class="org-src-container">
<pre class="src src-Shell"># 将官方Docker资源库的GPG密钥添加到系统
sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D

# 将Docker存储库添加到APT源
echo "deb https://apt.dockerproject.org/repo ubuntu-xenial main" | sudo tee /etc/apt/sources.list.d/docker.list

# 更新软件包数据库
sudo apt-get update

# 确保从Docker repo中安装
apt-cache policy docker-engine

sudo apt-get install -y docker-engine

# 开启docker服务
sudo service docker start

# 让docker服务开机自启动
sudo systemctl enable docker

# 如果要取消开机自动启动, 则输入
sudo systemctl disable docker

# 使用pip安装docker-compose
sudo pip install docker-compose

# 将当前用户加入docker组
sudo usermod -aG docker $USER

# 注销 重新登录

# 测试docker是否在运行
docker
</pre>
</div>
</div>
</div>

<div id="outline-container-org742f667" class="outline-4">
<h4 id="org742f667">使用镜像加速器</h4>
<div class="outline-text-4" id="text-org742f667">
<p>
对于Ubuntu 16.04LTS, 在 <code>/etc/docker/daemon.json</code> 中写入如下内容(若文件不存在则新建):
</p>
<div class="org-src-container">
<pre class="src src-JSON">{
  "registry-mirrors": [
    "https://registry.docker-cn.com"
  ]
}
</pre>
</div>

<p>
重启服务:
</p>
<div class="org-src-container">
<pre class="src src-Shell">sudo systemctl daemon-reload
sudo systemctl restart docker
</pre>
</div>

<p>
检查加速器是否生效, 输入 <code>docker info</code>, 如果有如下内容, 说明生效(由于我用的是阿里云加速器, 所以显示的是阿里云的网址):
</p>
<div class="org-src-container">
<pre class="src src-Shell">Registry Mirrors:
 https://obou6wyb.mirror.aliyuncs.com/
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2438ba6" class="outline-2">
<h2 id="org2438ba6">使用镜像</h2>
<div class="outline-text-2" id="text-org2438ba6">
</div>
<div id="outline-container-org67376a5" class="outline-4">
<h4 id="org67376a5">获取镜像</h4>
<div class="outline-text-4" id="text-org67376a5">
<p>
从Docker镜像仓库获取镜像的命令是 <code>docker pull [选项] [Docker Registry地址[:端口号]/]仓库名[:标签]</code>.
</p>

<p>
Docker Registry地址[:端口号]中的地址一般是 &lt;域名/IP&gt;[:端口号], 默认地址是Docker Hub.
</p>

<p>
仓库名: &lt;用户名&gt;/&lt;软件名&gt;, 对于Docker Hub, 可以不给出用户名.
</p>

<p>
如: <code>docker pull ubuntu:16.04</code>.
</p>

<p>
当然, 如果配置了加速器, 则默认是从加速器下载, 而不是Docker Hub.
</p>

<p>
运行: <code>docker run -it --rm ubuntu:16.04 bash</code>.
再如: <code>docker run -it --rm hyperledger/fabric-peer:latest bash</code>.
</p>

<p>
-it: i表示交互式操作, t表示终端.
-rm: 退出容器后将其删除. 如果不想删除, 这个参数可以不加, 最后在需要删除时使用命令docker rm.
bash: 表示使用bash shell.
</p>
</div>
</div>

<div id="outline-container-orgb889ee5" class="outline-4">
<h4 id="orgb889ee5">列出镜像</h4>
<div class="outline-text-4" id="text-orgb889ee5">
<p>
<code>docker images</code>.
</p>

<p>
体积与Docker Hub上显示的不同, 是因为Docker Hub显示的是压缩后的体积.
</p>

<p>
总体积并非所有镜像文件的总和, 因为Docker镜像是多层存储结构, 可以继承复用.
</p>

<p>
如果有镜像的仓库名和标签都是&lt;none&gt;, 说明这是虚悬镜像, 主要是因为新旧镜像同名, 旧镜像名称会被取消. 一般来说可以随意删除. 删除命令: <code>docker image prune</code>.
</p>

<p>
只列出部分镜像: <code>docker images ls ubuntu</code>.
</p>
</div>
</div>

<div id="outline-container-orgdd28a40" class="outline-4">
<h4 id="orgdd28a40">删除本地镜像</h4>
<div class="outline-text-4" id="text-orgdd28a40">
<div class="org-src-container">
<pre class="src src-Shell">docker image rmi [image-id]
</pre>
</div>
<p>
<code>image-id</code> 是前几位, 而不需要所有都输入.
</p>
</div>
</div>

<div id="outline-container-org6a33059" class="outline-4">
<h4 id="org6a33059">使用Dockerfile定制镜像</h4>
<div class="outline-text-4" id="text-org6a33059">
<p>
镜像的定制, 实际上是定制每一层所添加的配置和文件.
</p>

<p>
Dockerfile 是一个文本文件, 其内包含了一条条的指令, 每一条指令构建一层, 因此每一条指令的内容, 就是描述该层应当如何构建.
</p>

<p>
创建文件夹, 新建Dockerfile文件:
</p>
<div class="org-src-container">
<pre class="src src-Shell">mkdir mynginx
cd mynginx
touch Dockerfile
</pre>
</div>

<p>
内容为:
</p>
<div class="org-src-container">
<pre class="src src-Dockerfile">FROM nginx
RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
</pre>
</div>

<p>
定制镜像, 意思是以一个镜像为基础进行定制. <code>FROM</code> 就是指定基础镜像. 这在Dockerfile中是必备指令, 并且是第一条指令.
</p>

<p>
如果以 <code>FROM scratch</code> 开头, 说明不以任何镜像为基础.
</p>

<p>
<code>RUN</code> 指令用来执行命令行命令, 就像是直接在命令行中输入的命令一样.
</p>

<p>
Dockerfile会为每一条指令建立一层.
</p>

<p>
构建镜像: 在Dockerfile目录中执行 <code>docker build -t nginx:v3 .</code>. <code>-t</code> 参数指定镜像名称.
</p>

<p>
关于Dockerfile的具体内容, 有时间再继续学习.
</p>
</div>
</div>
</div>

<div id="outline-container-org4003938" class="outline-2">
<h2 id="org4003938">操作容器</h2>
<div class="outline-text-2" id="text-org4003938">
</div>
<div id="outline-container-org6b0fb1f" class="outline-4">
<h4 id="org6b0fb1f">启动</h4>
<div class="outline-text-4" id="text-org6b0fb1f">
<div class="org-src-container">
<pre class="src src-Shell">docker run -it ubuntu:16.04 bash
</pre>
</div>
</div>
</div>

<div id="outline-container-org689defe" class="outline-4">
<h4 id="org689defe">后台运行</h4>
<div class="outline-text-4" id="text-org689defe">
<p>
后台运行使用 <code>-d</code> 参数.
</p>

<p>
后台运行时, 如果有相关的输出信息, 并不会输出到宿主机器.
</p>

<div class="org-src-container">
<pre class="src src-Shell">docker run -d ubuntu:17.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"

# 查看输出信息
docker container logs
</pre>
</div>
</div>
</div>

<div id="outline-container-org791c761" class="outline-4">
<h4 id="org791c761">终止容器</h4>
<div class="outline-text-4" id="text-org791c761">
<div class="org-src-container">
<pre class="src src-Shell">docker container stop [container name]

# 终止状态的窗口可以用以下命令查看
docker container ls -a

# 处于终止状态的容器的启动
docker container start [container name]

# 重启
docker container restart [container name]
</pre>
</div>
</div>
</div>

<div id="outline-container-org3c66c96" class="outline-4">
<h4 id="org3c66c96">进入容器</h4>
<div class="outline-text-4" id="text-org3c66c96">
<div class="org-src-container">
<pre class="src src-Shell">docker exec -it [container name] bash
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f4a5d9" class="outline-4">
<h4 id="org1f4a5d9">导入导出</h4>
<div class="outline-text-4" id="text-org1f4a5d9">
<p>
导出:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker container ls -a

# 记住要导出的容器id

docker export 7691a814370e &gt; ubuntu.tar
</pre>
</div>

<p>
导入:
</p>
<div class="org-src-container">
<pre class="src src-Shell">cat ubuntu | docker import - test/ubuntu:v1.0
</pre>
</div>
</div>
</div>

<div id="outline-container-org3275d32" class="outline-4">
<h4 id="org3275d32">删除容器</h4>
<div class="outline-text-4" id="text-org3275d32">
<div class="org-src-container">
<pre class="src src-Shell"># 删除一个处于终止状态的容器
docker container rm test

# 清理所有处于终止状态的容器
docker container ls -a
docker container prune
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2c99f37" class="outline-2">
<h2 id="org2c99f37">访问仓库</h2>
<div class="outline-text-2" id="text-org2c99f37">
<p>
仓库(Repository)是集中存放镜像的地方.
</p>

<p>
注册服务器(Registry)是管理仓库的具体服务器. 每个服务器上有许多仓库, 每个仓库里有许多镜像.
</p>

<p>
如 dl.dockerpool.com/ubuntu, dl.dockerpool.com是注册服务器地址, ubuntu是仓库名.
</p>
</div>

<div id="outline-container-org92fa2d4" class="outline-4">
<h4 id="org92fa2d4">Docker Hub</h4>
<div class="outline-text-4" id="text-org92fa2d4">
<p>
注册: <a href="https://cloud.docker.com/">注册Docker账号</a>
</p>

<p>
登录: docker login
</p>

<p>
退出: docker logout
</p>

<p>
查找镜像: docker search
</p>

<p>
拉取镜像: docker pull
</p>

<p>
如:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker search centos

# 返回很多centos相关镜像

# 选择其中一个拉取
docker pull centos
</pre>
</div>

<p>
推送: 
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker username/ubuntu:17.10
docker search username
</pre>
</div>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-03-28</span>
        <span title="last modification date" class="post-info">2018-03-28</span>
        <span title="tags" class="post-info"><a href="/tags/docker/">Docker</a></span>
        <span title="author" class="post-info">Pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/03/28/docker从入门到实践-笔记";
          var disqus_url = "http://pinvondev.github.io/blog/2018/03/28/docker从入门到实践-笔记";
          var disqus_shortname = 'pinvon';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:pinvon &lt;at&gt; Inspiron">Pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
