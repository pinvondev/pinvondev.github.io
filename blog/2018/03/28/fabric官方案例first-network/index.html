<!DOCTYPE html>
<html lang="en">
<head>
  <title>Fabric官方案例first-network - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;TODO: insert your description here&gt;" />
  <meta name="keywords" content="BlockChain" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="http://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="http://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="http://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="http://pinvondev.github.io/years/">Years</a></li>
        <li><a href="http://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="http://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="http://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="http://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Fabric官方案例first-network</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb298911">准备</a>
<ul>
<li>
<ul>
<li><a href="#org92e6f9c">下载源代码</a></li>
</ul>
</li>
<li><a href="#org1cf9f0f">下载工具</a>
<ul>
<li><a href="#org42128aa">使用脚本下载</a></li>
<li><a href="#orgbadcc81">编译过Fabric的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5832250">一键运行</a></li>
<li><a href="#org18957f6">手动运行</a>
<ul>
<li>
<ul>
<li><a href="#org082a7ff">cryptogen工具</a></li>
<li><a href="#org96d7654">configtxgen工具(配置交易生成器)</a></li>
<li><a href="#orgf4354ba">使用工具</a></li>
<li><a href="#orga704209">启动网络</a></li>
<li><a href="#org3d879a9">设置环境变量</a></li>
<li><a href="#org1bf956a">创建/加入Channel</a></li>
<li><a href="#orge933238">关于Channel.</a></li>
<li><a href="#orge7b9b04">更新锚节点</a></li>
<li><a href="#org2b332e6">Chaincode的安装与初始化</a></li>
<li><a href="#org673c717">查询</a></li>
<li><a href="#orgb41009a">调用</a></li>
<li><a href="#org62ea86a">背后的原理</a></li>
<li><a href="#orge425d60">总结</a></li>
<li><a href="#org0993cc3">查看日志</a></li>
<li><a href="#org67eba43">CouchDB</a></li>
<li><a href="#org7c501dd">数据持久化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgb298911" class="outline-2">
<h2 id="orgb298911">准备</h2>
<div class="outline-text-2" id="text-orgb298911">
<p>
注: 使用的版本为1.1.0
</p>
</div>

<div id="outline-container-org92e6f9c" class="outline-4">
<h4 id="org92e6f9c">下载源代码</h4>
<div class="outline-text-4" id="text-org92e6f9c">
<div class="org-src-container">
<pre class="src src-Shell">git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples

# 如果想切换到其他版本, 则输入以下命令. 我直接使用主分支的版本, 因此不切换
git checkout {TAG}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1cf9f0f" class="outline-3">
<h3 id="org1cf9f0f">下载工具</h3>
<div class="outline-text-3" id="text-org1cf9f0f">
<p>
想要运行这里的官方案例, 需要准备一些工具. 你可以使用脚本下载, 如果编译过Fabric的, 也可以选另一种方式, 因为如果编译过, 已经有很多镜像文件了, 不需要使用脚本重新下载.
</p>
</div>

<div id="outline-container-org42128aa" class="outline-4">
<h4 id="org42128aa">使用脚本下载</h4>
<div class="outline-text-4" id="text-org42128aa">
<p>
可以直接执行以下命令:
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 能翻墙
curl -sSL https://goo.gl/6wtTN5 | bash -s 1.1.0

# 不能翻墙
curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/master/scripts/bootstrap.sh | bash -s 1.1.0
</pre>
</div>

<p>
也可以直接到这个网站, 将脚本复制下来, 放在 <code>fabric-samples</code> 根目录下的 <code>bootstrap.sh</code> 中, 这个文件要自己创建.
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 让其可执行
chmod +x ./bootstrap.sh
./bootstrap.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbadcc81" class="outline-4">
<h4 id="orgbadcc81">编译过Fabric的</h4>
<div class="outline-text-4" id="text-orgbadcc81">
<p>
如果有根据<a href="https://pinvondev.github.io/blog/2018/03/25/hyperledger/">编译</a>所说的进行编译过, 可以先打开 <code>bootstrap.sh</code>, 在里面查找 <code>dockerFabricPull()</code> 方法, 将该方法以后(包括该方法)的内容全部注释. 添加两句:
</p>
<div class="org-src-container">
<pre class="src src-Shell">echo ${ARCH}
echo ${VERSION}
./bootstrap.sh
</pre>
</div>
<p>
查看输出, 根据输出的信息用浏览器到以下两个网站去下载. (终端的curl太慢了)
</p>

<p>
<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/">https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/</a>
</p>

<p>
<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/">https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/</a>
</p>

<p>
下载完后解压到 <code>fabric-samples/bin/</code> 目录下, 如果没有 <code>bin目录</code>, 则创建一个. 这里的工具, 有几个也可以在 <code>fabric/build/docker/bin</code> 里面找到, 直接复制过去也行.
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-org5832250" class="outline-2">
<h2 id="org5832250">一键运行</h2>
<div class="outline-text-2" id="text-org5832250">
<div class="org-src-container">
<pre class="src src-Shell">cd first-network

# 生成配置
./byfn.sh -m generate

# 启动网络
./byfn.sh -m up

# 关闭网络
./byfn.sh -m down
</pre>
</div>
<p>
如果成功, 可以看到类似下面两个图中的内容.
</p>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/9.png" alt="9.png" />
</p>
</div>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/10.png" alt="10.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org18957f6" class="outline-2">
<h2 id="org18957f6">手动运行</h2>
<div class="outline-text-2" id="text-org18957f6">
</div>
<div id="outline-container-org082a7ff" class="outline-4">
<h4 id="org082a7ff">cryptogen工具</h4>
<div class="outline-text-4" id="text-org082a7ff">
<p>
cryptogen工具为网络节点生成证书信息(x509证书). 这些证书是节点身份的代表, 它们使得我们可以在网络中交易时进行签名/验证身份.
</p>

<p>
cryptogen工具根据 <code>crypto-config.yaml</code> 文件里的配置进行工具, 这个文件包含了网络拓扑, 并且使得我们可以为Organizations和属于Organizations的节点生成证书与密钥. 每个Organization都有唯一的根证书(ca-cert), 它将组件(peers, orders)绑定到Organization. 通过为每个Organization颁发唯一的CA证书, 我们可以模仿一个典型的区块链网络, 这个网络中的成员将使用自己的数字证书获取授权. Hyperledger Fabric中的交易和通信, 都是通过存储在 <code>keystore</code> 中的实体的私钥签名, 然后使用公钥进行身份验证.
</p>

<p>
去掉 <code>crypto-config.yaml</code> 中的注释部分, 可以清楚地看清其内容.
</p>
<div class="org-src-container">
<pre class="src src-Shell">sed '/#/d' crypto-config.yaml &gt; cryp.yaml
emacs cryp.yaml
</pre>
</div>
<p>
可以看到, 里面的内容如下:
</p>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/11.png" alt="11.png" />
</p>
</div>

<p>
<code>crypto-config.yaml</code> 中的 <code>count</code> 表示Organization中的 <code>peer</code> 的数量.
</p>

<p>
还要注意 OrdererOrgs 下的 Name, Domain, Specs 这些字段. 网络实体的命名规则为: {Hostname}.{Domain}
</p>

<p>
因此, Orderer节点的命名为 orderer.example.com, MSP ID为Orderer.
</p>

<p>
使用 <code>cryptogen</code> 生成的数字证书和密钥信息保存在 <code>crypto-config</code> 文件夹中.
</p>
</div>
</div>

<div id="outline-container-org96d7654" class="outline-4">
<h4 id="org96d7654">configtxgen工具(配置交易生成器)</h4>
<div class="outline-text-4" id="text-org96d7654">
<p>
configtxgen会生成4个配置信息:
</p>
<ol class="org-ol">
<li>orderer genesis block</li>
<li>channel configuration transaction</li>
<li>两个 anchor peer transactions</li>
</ol>

<p>
其中, orderer block是Orderer Service的创世区块. Channel configuration transaction文件在Channel创建的时候广播给Order. Anchor peer transactions指定了每个Organization在此Channel上的代表节点.
</p>

<p>
configtxgen的配置文件是 <code>configtx.yaml</code>. 去掉其中的注释可以看得更清晰些.
</p>

<p>
该配置文件定义了3个成员: 一个Ordering Service组织(Organization) OrdererOrg, 两个节点组织 Org1 和 Org2, 每个组织由2个Peer组成. 每个组织还指定了Anchor Peer(peer0.org1.example.com和peer0.org2.example.com). 还为每个成员指定了MSP文件夹, 用来存储每个组织在orderer genesis block中指定的根证书, 有了这些证书, 任意和Ordering service通信的节点都可以对其数字签名进行验证.
</p>
</div>
</div>

<div id="outline-container-orgf4354ba" class="outline-4">
<h4 id="orgf4354ba">使用工具</h4>
<div class="outline-text-4" id="text-orgf4354ba">
<p>
其实怎么去使用这些工具, 在一键式脚本 <code>byfn.sh</code> 中都有写明. 如根据 <code>crypto-config.yaml</code> 中的配置来生成用于相关数字证书, 可以查看 <code>generateCerts()</code> 中的写法.
</p>

<p>
手动执行, 可加深了解.
</p>

<p>
创建数字证书:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/cryptogen generate --config=./crypto-config.yaml
</pre>
</div>
<p>
生成的数字证书存放在 <code>crypto-config</code> 文件夹中.
</p>

<p>
生成Ordering Service的创世区块:
设置环境变量 <code>FABRIC_CFG_PATH</code>, 告诉configtxgen工具, 要到哪里去寻找配置文件 <code>configtx.yaml</code>:
</p>
<div class="org-src-container">
<pre class="src src-Shell">export FABRIC_CFG_PATH=${PWD}
../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</pre>
</div>
<p>
这样, Ordering Service的创世区块就生成了, 放在 <code>channel-artifacts</code> 目录中.
</p>

<p>
创建Channel配置交易:
</p>
<div class="org-src-container">
<pre class="src src-Shell">export CHANNEL_NAME=mychannel  &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
</pre>
</div>

<p>
创建Channel上Org1的anchor peer:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
</pre>
</div>

<p>
创建Channel上Org2的anchor peer:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
</pre>
</div>

<p>
到此为止, 我们有了Channel, Org1, Org2, Org1的anchor peer, Org2的anchor peer
</p>
</div>
</div>

<div id="outline-container-orga704209" class="outline-4">
<h4 id="orga704209">启动网络</h4>
<div class="outline-text-4" id="text-orga704209">
<p>
我们使用docker-compose脚本来启动网络, 该脚本使用之前下载的镜像文件, 通过 <code>genesis.block</code> 引导Orderer.
</p>

<div class="org-src-container">
<pre class="src src-Shell">docker-compose -f docker-compose-cli.yaml up -d
</pre>
</div>
<p>
如果不使用 <code>-d</code>, 则日志会实时显示, 这样需要新开一个终端做接下来的工作. 使用了 <code>-d</code> 就表示后台执行.
</p>

<p>
启动CLI容器, CLI容器主要用来发送一些管理命令.
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker start cli
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d879a9" class="outline-4">
<h4 id="org3d879a9">设置环境变量</h4>
<div class="outline-text-4" id="text-org3d879a9">
<p>
为了能在 <code>peer0.org1.example.com</code> 上执行下面的CLI命令, 需要先配置几个环境变量, 这些环境变量已经默认在CLI容器里设置好了, 可以直接使用. 但是, 如果想发送命令到其他的Peers或Orderer中使用, 则需要相应的设置对应的环境变量. 
</p>
<div class="org-src-container">
<pre class="src src-Shell"># Environment variables for PEER0

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID="Org1MSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
</pre>
</div>
</div>
</div>

<div id="outline-container-org1bf956a" class="outline-4">
<h4 id="org1bf956a">创建/加入Channel</h4>
<div class="outline-text-4" id="text-org1bf956a">
<p>
我们可以使用configtxgen工具来创建Channel.
</p>

<p>
首先进行CLI容器:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker exec -it cli bash
</pre>
</div>

<p>
之前, 我们使用configtxgen创建了Channel的配置交易channel.tx, 现在将它作为参数传递给Orderer, 作为创建Channel请求的一部分.
</p>

<p>
创建Channel的命令包含一些参数. <code>-c</code> 表示Channel名字, <code>-f</code> 表示Channel配置交易, 这边是channel.tx, 当然你也可以挂载你自己的配置交易, 名字也可以不一样, <code>--cafile</code> 允许我们验证TLS握手, 参数为证书根路径.
</p>

<p>
注: 不使用SSL/TLS的HTTP通信, 就是不加密的通信. SSL/TSL协议的基本过程为:
</p>
<ol class="org-ol">
<li>Client向Server索要并验证公钥</li>
<li>双方协商生成"对话密钥"</li>
<li>双方采用"对话密钥"进行加密</li>
</ol>
<p>
前两步就是握手阶段.
</p>
<div class="org-src-container">
<pre class="src src-Shell">export CHANNEL_NAME=mychannel
peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>
<p>
该命令返回一个创世区块, 我们准备把它加入到Channel. 在CLI容器当前目录下, 会生成一个mychannel.block的区块. 如图所示:
</p>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/18.png" alt="18.png" />
</p>
</div>

<p>
将 peer0.org1.example.com 加到 channel 中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer channel join -b mychannel.block
</pre>
</div>
<p>
如果要将其他节点加入Channel, 需要修改相应的环境变量. 这边以加入 peer0.org2.example.com 到Channel为例.
</p>
<div class="org-src-container">
<pre class="src src-Shell">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:7051 
CORE_PEER_LOCALMSPID="Org2MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
peer channel join -b mychannel.block
</pre>
</div>
<p>
注意, 这会改掉原有的环境变量. 如果全部写在一行去执行, 则不会改变默认的环境变量.
</p>
</div>
</div>

<div id="outline-container-orge933238" class="outline-4">
<h4 id="orge933238">关于Channel.</h4>
<div class="outline-text-4" id="text-orge933238">
<p>
在Fabric中, Channel是很重要的概念. 一个Peer要想与另一个Peer发生交易, 必须处于同一个Channel中, 账本与Channel也是一对一的关系. Channel需要使用 <code>peer channel ...</code> 这样的命令进行维护.
</p>

<p>
create(Channel在Orderer结点内部): <code>peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel.tx</code>
</p>

<p>
join(加入一个Channel): <code>peer channel join -b mychannel.block</code>
</p>

<p>
update(更新channel的某Org的配置): <code>peer channel update -o orderer.example.com:7050 -c mychannel -f ./Org1MSPanchors.tx</code>
</p>

<p>
Channel分成System Channel和Application Channel. 通过 <code>peer channel ...</code> 命令维护的都是Application Channel. 对Application Channel发起维护命令的Peer节点, 必须是提交的配置文件中所配置的Org中的一员, 提交的配置文件一般为 channel.tx, mychannel.block, Org1MSPanchors.tx. 本质的意思是说, 该Peer节点要持有该组织所颁发的证书.
</p>

<p>
create, join, update 三个命令, 都使用了配置文件.
</p>

<ol class="org-ol">
<li>channel.tx: 这是创建Application Channel的配置文件. channel.tx由configtxgen工具根据指定的profile从configtx.yaml中读取配置数据, profile指的是configtx.yaml中Profiles项下定义的某一个配置项. configtx.yaml文件规定了Channel中包含哪些组织, 创建Channel的命令会根据configtx.yaml生成配置信息, 导入到channel.tx中.</li>

<li>mychannel.block: 它是Application Channel的创世区块. 通过 <code>peer channel create</code> 生成. channel.tx只是配置原型, 在create过程中, 会根据System Channel的配置进行详细填补, 最后生成一个block. 要想加入Application Channel, 就要先获取这个Channel的genesis block.</li>

<li>Org1MSPanchors.tx: 更新组织的配置文件, 由configtxgen工具根据Org ID从configtx.yaml中指定的profile项生成. <code>configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</code> 是指从configtx.yaml的Profiles下的TwoOrgsChannel项中获取Org ID为Org1MSP的组织的配置数据, 更新mychannel后, 把获取生成的配置数据导入到./Org1MSPanchors.tx文件中.</li>
</ol>
</div>
</div>

<div id="outline-container-orge7b9b04" class="outline-4">
<h4 id="orge7b9b04">更新锚节点</h4>
<div class="outline-text-4" id="text-orge7b9b04">
<div class="org-src-container">
<pre class="src src-Shell">peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>

<p>
将Org2的锚节点定义为 peer0.org2.example.com:
</p>
<div class="org-src-container">
<pre class="src src-Shell">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:7051 
CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>
</div>
</div>

<div id="outline-container-org2b332e6" class="outline-4">
<h4 id="org2b332e6">Chaincode的安装与初始化</h4>
<div class="outline-text-4" id="text-org2b332e6">
<p>
应用程序通过Chaincode与BlockChain交互. 因此, 我们要在每个Peer上安装Chaincode来执行交易, 并在Channel中对其实例化.
</p>

<p>
将Go语言编写的Chaincode放在Peer的文件系统中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/
</pre>
</div>

<p>
将Node.js语言编写的Chaincode放在Peer的文件系统中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode install -n mycc -v 1.0 -l node -p /opt/gopath/src/github.com/chaincode/chaincode_example02/node/
</pre>
</div>

<p>
然后, 在Channel上进行实例化. 实例化会先初始化Chaincode, 为Chaincode设置背书策略, 为目标Peer启动Chaincode容器. <code>-P</code> 参数指定了在Chaincode上, 一个交易被认可所需要的背书级别.
</p>

<p>
如果策略是 <code>-P "OR ('Org0MSP.peer','Org1MSP.peer')"</code>, 表示Org1或Org2中的Peer认可, 就认可该交易. 如果把OR改成AND, 就表示需要两个都认可, 交易才会被认可.
</p>

<p>
实例化Go语言的Chaincode:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.peer','Org2MSP.peer')"
</pre>
</div>

<p>
实例化Node.js语言的Chaincode:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.peer','Org2MSP.peer')"
</pre>
</div>
</div>
</div>

<div id="outline-container-org673c717" class="outline-4">
<h4 id="org673c717">查询</h4>
<div class="outline-text-4" id="text-org673c717">
<p>
假设我们要查询 <code>a</code> 的值, 以确认Chaincode是否已实例化, state DB是否已填充. 查询的语法如下:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'
</pre>
</div>

<p>
查询结果如下图所示:
</p>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/19.png" alt="19.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb41009a" class="outline-4">
<h4 id="orgb41009a">调用</h4>
<div class="outline-text-4" id="text-orgb41009a">
<p>
假设我们要从 <code>a</code> 里面减去10给 <code>b</code>.
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}'
</pre>
</div>

<p>
此时, 再次查询 <code>a</code> 的值, 应该会从100变为90.
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'
</pre>
</div>


<div class="figure">
<p><img src="http://pinvondev.github.io/assets/blog/2018/03/28/fabric官方案例first-network/20.png" alt="20.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org62ea86a" class="outline-4">
<h4 id="org62ea86a">背后的原理</h4>
<div class="outline-text-4" id="text-org62ea86a">
<p>
以上所说的步骤, 就是 <code>script.sh</code> 文件中的 <code>./byfn.sh up</code>. 现在, 使用 <code>./byfn.sh down</code> 来关闭它们.
</p>

<p>
总结一下, 主要步骤包含以下几点:
</p>
<ol class="org-ol">
<li><code>script.sh</code> 被拷贝到CLI容器中. <code>script.sh</code> 使用设定的Channel名字和Channel的配置文件 <code>channel.tx</code> 作为参数执行 <code>createChannel</code> 命令.</li>
<li><code>createChannel</code> 输出创世区块, 以 <code>channel_name.block</code> 命名. 该区块保存在Peer的文件系统里, 包含了 <code>channel.tx</code> 所指定的Channel的配置信息.</li>
<li><code>joinChannel</code> 被执行. 它使用 <code>channel_name.block</code> 作为输入, 将四个Peer节点加入到Channel, 并建立一个以 <code>channel_name.block</code> 为起始块的链.</li>
<li>现在的Channel = 2 * Org = 4 * Peer. 其中, Org1 = peer0.org1.example.com + peer1.org1.example.com, Org2 = peer0.org2.example.com + peer1.org2.example.com</li>
<li>将Org1MSPanchor.tx, Org2MSPanchor.tx, Channel作为参数给Ordering Service, 更新Org1MSP的Anchor Peer(peer0.org1.example.com)和Org2MSP的Anchor Peer(peer0.org2.example.com).</li>
<li>在peer0.org2.example.com上实例化Chaincode,  实例化过程将添加Chaincode到Channel上, 并启动Peer节点对应的容器, 初始化和Chaincode有关的键值对. 在这边, 初始化的值为["a", "100", "b", "200"]. 实例化后会启动一个名为 <code>dev-peer0.org2.example.com-mycc-1.0</code> 的容器.</li>
<li>实例化过程还会以背书策略为参数.</li>
<li>在peer0.org1.example.com上查询 <code>a</code> 的值. 之前, Chaincode已经安装在peer0.org1.example.com上了, 因此查询操作会启动一个名为 <code>dev-peer0.org1.example.com-mycc-1.0</code> 的容器.</li>
<li>在peer0.org1.example.com上执行转账.</li>
<li>发送查询到peer1.org2.example.com. 这时会启动第3个容器 <code>dev-peer1.org2.example.com-mycc-1.0</code>.</li>
</ol>
</div>
</div>

<div id="outline-container-orge425d60" class="outline-4">
<h4 id="orge425d60">总结</h4>
<div class="outline-text-4" id="text-orge425d60">
<p>
要想对账本进行操作, 需要先在Peer上安装Chaincode. Chaincode容器在需要时(如查询)才会启动. Channel中每个Peer都有账本的副本, 存储了不可改变的, 序列化的记录区块和State Database用于保存当前的Fabric状态. 没有安装Chaincode的Peer也会同步账本.
</p>
</div>
</div>

<div id="outline-container-org0993cc3" class="outline-4">
<h4 id="org0993cc3">查看日志</h4>
<div class="outline-text-4" id="text-org0993cc3">
<p>
CLI容器的日志:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker logs -f cli
</pre>
</div>

<p>
Chaincode的日志:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker logs dev-peer0.org2.example.com-mycc-1.0
</pre>
</div>
</div>
</div>

<div id="outline-container-org67eba43" class="outline-4">
<h4 id="org67eba43">CouchDB</h4>
<div class="outline-text-4" id="text-org67eba43">
<p>
状态数据库使用goleveldb或CouchDB. 默认为goleveldb.
</p>
</div>
</div>

<div id="outline-container-org7c501dd" class="outline-4">
<h4 id="org7c501dd">数据持久化</h4>
<div class="outline-text-4" id="text-org7c501dd">
<p>
如果要在Peer容器中进行数据持久化, 可以将docker容器内相应的目录挂载到宿主机器的一个目录中. 如, 添加下面的内容到 <code>docker-compose-base.yaml</code> 的Peer的约定中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">volumes:
 - /var/hyperledger/peer0:/var/hyperledger/production
</pre>
</div>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-03-28</span>
            <span title="last modification date" class="post-info">2018-03-30</span>
            <span title="tags" class="post-info">:<a href="http://pinvondev.github.io/tags/blockchain">BlockChain</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="http://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/2018/03/28/fabric官方案例first-network";
         var disqus_url = "http://pinvondev.github.io/blog/2018/03/28/fabric官方案例first-network";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="http://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div></body>
</html>
