<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Fabric官方案例first-network - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="&lt;TODO: insert your keywords here&gt;" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Fabric官方案例first-network</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbb5b1bf">准备</a>
<ul>
<li>
<ul>
<li><a href="#org4ec4b4d">下载源代码</a></li>
</ul>
</li>
<li><a href="#org2c81531">下载工具</a>
<ul>
<li><a href="#org43e74e4">使用脚本下载</a></li>
<li><a href="#orgdf27caf">编译过Fabric的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0009962">一键运行</a></li>
<li><a href="#orgc3c65e3">手动运行</a>
<ul>
<li>
<ul>
<li><a href="#org7114b27">cryptogen工具</a></li>
<li><a href="#orgdcb448d">configtxgen工具(配置交易生成器)</a></li>
<li><a href="#org668187c">使用工具</a></li>
<li><a href="#orgffd5ae1">启动网络</a></li>
<li><a href="#org7de4993">设置环境变量</a></li>
<li><a href="#org5f297e9">创建/加入Channel</a></li>
<li><a href="#org134f260">关于Channel.</a></li>
<li><a href="#org6510d9a">更新锚节点</a></li>
<li><a href="#org0eb0a46">Chaincode的安装与初始化</a></li>
<li><a href="#org81cf3bd">查询</a></li>
<li><a href="#orgfa2714b">调用</a></li>
<li><a href="#org9ba9966">背后的原理</a></li>
<li><a href="#org8b7a4bc">总结</a></li>
<li><a href="#org031f31c">查看日志</a></li>
<li><a href="#org6c2a856">CouchDB</a></li>
<li><a href="#org3b05e66">数据持久化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgbb5b1bf" class="outline-2">
<h2 id="orgbb5b1bf">准备</h2>
<div class="outline-text-2" id="text-orgbb5b1bf">
<p>
注: 使用的版本为1.1.0
</p>
</div>

<div id="outline-container-org4ec4b4d" class="outline-4">
<h4 id="org4ec4b4d">下载源代码</h4>
<div class="outline-text-4" id="text-org4ec4b4d">
<div class="org-src-container">
<pre class="src src-Shell">git clone https://github.com/hyperledger/fabric-samples.git
cd fabric-samples

# 如果想切换到其他版本, 则输入以下命令. 我直接使用主分支的版本, 因此不切换
git checkout {TAG}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2c81531" class="outline-3">
<h3 id="org2c81531">下载工具</h3>
<div class="outline-text-3" id="text-org2c81531">
<p>
想要运行这里的官方案例, 需要准备一些工具. 你可以使用脚本下载, 如果编译过Fabric的, 也可以选另一种方式, 因为如果编译过, 已经有很多镜像文件了, 不需要使用脚本重新下载.
</p>
</div>

<div id="outline-container-org43e74e4" class="outline-4">
<h4 id="org43e74e4">使用脚本下载</h4>
<div class="outline-text-4" id="text-org43e74e4">
<p>
可以直接执行以下命令:
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 能翻墙
curl -sSL https://goo.gl/6wtTN5 | bash -s 1.1.0

# 不能翻墙
curl -sSL https://raw.githubusercontent.com/hyperledger/fabric/master/scripts/bootstrap.sh | bash -s 1.1.0
</pre>
</div>

<p>
也可以直接到这个网站, 将脚本复制下来, 放在 <code>fabric-samples</code> 根目录下的 <code>bootstrap.sh</code> 中, 这个文件要自己创建.
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 让其可执行
chmod +x ./bootstrap.sh
./bootstrap.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf27caf" class="outline-4">
<h4 id="orgdf27caf">编译过Fabric的</h4>
<div class="outline-text-4" id="text-orgdf27caf">
<p>
如果有根据<a href="https://pinvondev.github.io/blog/2018/03/25/hyperledger/">编译</a>所说的进行编译过, 可以先打开 <code>bootstrap.sh</code>, 在里面查找 <code>dockerFabricPull()</code> 方法, 将该方法以后(包括该方法)的内容全部注释. 添加两句:
</p>
<div class="org-src-container">
<pre class="src src-Shell">echo ${ARCH}
echo ${VERSION}
./bootstrap.sh
</pre>
</div>
<p>
查看输出, 根据输出的信息用浏览器到以下两个网站去下载. (终端的curl太慢了)
</p>

<p>
<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/">https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/</a>
</p>

<p>
<a href="https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/">https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric-ca/hyperledger-fabric-ca/</a>
</p>

<p>
下载完后解压到 <code>fabric-samples/bin/</code> 目录下, 如果没有 <code>bin目录</code>, 则创建一个. 这里的工具, 有几个也可以在 <code>fabric/build/docker/bin</code> 里面找到, 直接复制过去也行.
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-org0009962" class="outline-2">
<h2 id="org0009962">一键运行</h2>
<div class="outline-text-2" id="text-org0009962">
<div class="org-src-container">
<pre class="src src-Shell">cd first-network

# 生成配置
./byfn.sh -m generate

# 启动网络
./byfn.sh -m up

# 关闭网络
./byfn.sh -m down
</pre>
</div>
<p>
如果成功, 可以看到类似下面两个图中的内容.
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/9.png" alt="9.png" />
</p>
</div>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/10.png" alt="10.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-orgc3c65e3" class="outline-2">
<h2 id="orgc3c65e3">手动运行</h2>
<div class="outline-text-2" id="text-orgc3c65e3">
</div>
<div id="outline-container-org7114b27" class="outline-4">
<h4 id="org7114b27">cryptogen工具</h4>
<div class="outline-text-4" id="text-org7114b27">
<p>
cryptogen工具为网络节点生成证书信息(x509证书). 这些证书是节点身份的代表, 它们使得我们可以在网络中交易时进行签名/验证身份.
</p>

<p>
cryptogen工具根据 <code>crypto-config.yaml</code> 文件里的配置进行工具, 这个文件包含了网络拓扑, 并且使得我们可以为Organizations和属于Organizations的节点生成证书与密钥. 每个Organization都有唯一的根证书(ca-cert), 它将组件(peers, orders)绑定到Organization. 通过为每个Organization颁发唯一的CA证书, 我们可以模仿一个典型的区块链网络, 这个网络中的成员将使用自己的数字证书获取授权. Hyperledger Fabric中的交易和通信, 都是通过存储在 <code>keystore</code> 中的实体的私钥签名, 然后使用公钥进行身份验证.
</p>

<p>
去掉 <code>crypto-config.yaml</code> 中的注释部分, 可以清楚地看清其内容.
</p>
<div class="org-src-container">
<pre class="src src-Shell">sed '/#/d' crypto-config.yaml &gt; cryp.yaml
emacs cryp.yaml
</pre>
</div>
<p>
可以看到, 里面的内容如下:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/11.png" alt="11.png" />
</p>
</div>

<p>
<code>crypto-config.yaml</code> 中的 <code>count</code> 表示Organization中的 <code>peer</code> 的数量.
</p>

<p>
还要注意 OrdererOrgs 下的 Name, Domain, Specs 这些字段. 网络实体的命名规则为: {Hostname}.{Domain}
</p>

<p>
因此, Orderer节点的命名为 orderer.example.com, MSP ID为Orderer.
</p>

<p>
使用 <code>cryptogen</code> 生成的数字证书和密钥信息保存在 <code>crypto-config</code> 文件夹中.
</p>
</div>
</div>

<div id="outline-container-orgdcb448d" class="outline-4">
<h4 id="orgdcb448d">configtxgen工具(配置交易生成器)</h4>
<div class="outline-text-4" id="text-orgdcb448d">
<p>
configtxgen会生成4个配置信息:
</p>
<ol class="org-ol">
<li>orderer genesis block</li>
<li>channel configuration transaction</li>
<li>两个 anchor peer transactions</li>
</ol>

<p>
其中, orderer block是Orderer Service的创世区块. Channel configuration transaction文件在Channel创建的时候广播给Order. Anchor peer transactions指定了每个Organization在此Channel上的代表节点.
</p>

<p>
configtxgen的配置文件是 <code>configtx.yaml</code>. 去掉其中的注释可以看得更清晰些.
</p>

<p>
该配置文件定义了3个成员: 一个Ordering Service组织(Organization) OrdererOrg, 两个节点组织 Org1 和 Org2, 每个组织由2个Peer组成. 每个组织还指定了Anchor Peer(peer0.org1.example.com和peer0.org2.example.com). 还为每个成员指定了MSP文件夹, 用来存储每个组织在orderer genesis block中指定的根证书, 有了这些证书, 任意和Ordering service通信的节点都可以对其数字签名进行验证.
</p>
</div>
</div>

<div id="outline-container-org668187c" class="outline-4">
<h4 id="org668187c">使用工具</h4>
<div class="outline-text-4" id="text-org668187c">
<p>
其实怎么去使用这些工具, 在一键式脚本 <code>byfn.sh</code> 中都有写明. 如根据 <code>crypto-config.yaml</code> 中的配置来生成用于相关数字证书, 可以查看 <code>generateCerts()</code> 中的写法.
</p>

<p>
手动执行, 可加深了解.
</p>

<p>
创建数字证书:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/cryptogen generate --config=./crypto-config.yaml
</pre>
</div>
<p>
生成的数字证书存放在 <code>crypto-config</code> 文件夹中.
</p>

<p>
生成Ordering Service的创世区块:
设置环境变量 <code>FABRIC_CFG_PATH</code>, 告诉configtxgen工具, 要到哪里去寻找配置文件 <code>configtx.yaml</code>:
</p>
<div class="org-src-container">
<pre class="src src-Shell">export FABRIC_CFG_PATH=${PWD}
../bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</pre>
</div>
<p>
这样, Ordering Service的创世区块就生成了, 放在 <code>channel-artifacts</code> 目录中.
</p>

<p>
创建Channel配置交易:
</p>
<div class="org-src-container">
<pre class="src src-Shell">export CHANNEL_NAME=mychannel  &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
</pre>
</div>

<p>
创建Channel上Org1的anchor peer:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
</pre>
</div>

<p>
创建Channel上Org2的anchor peer:
</p>
<div class="org-src-container">
<pre class="src src-Shell">../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
</pre>
</div>

<p>
到此为止, 我们有了Channel, Org1, Org2, Org1的anchor peer, Org2的anchor peer
</p>
</div>
</div>

<div id="outline-container-orgffd5ae1" class="outline-4">
<h4 id="orgffd5ae1">启动网络</h4>
<div class="outline-text-4" id="text-orgffd5ae1">
<p>
我们使用docker-compose脚本来启动网络, 该脚本使用之前下载的镜像文件, 通过 <code>genesis.block</code> 引导Orderer.
</p>

<div class="org-src-container">
<pre class="src src-Shell">docker-compose -f docker-compose-cli.yaml up -d
</pre>
</div>
<p>
如果不使用 <code>-d</code>, 则日志会实时显示, 这样需要新开一个终端做接下来的工作. 使用了 <code>-d</code> 就表示后台执行.
</p>

<p>
启动CLI容器, CLI容器主要用来发送一些管理命令.
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker start cli
</pre>
</div>
</div>
</div>

<div id="outline-container-org7de4993" class="outline-4">
<h4 id="org7de4993">设置环境变量</h4>
<div class="outline-text-4" id="text-org7de4993">
<p>
为了能在 <code>peer0.org1.example.com</code> 上执行下面的CLI命令, 需要先配置几个环境变量, 这些环境变量已经默认在CLI容器里设置好了, 可以直接使用. 但是, 如果想发送命令到其他的Peers或Orderer中使用, 则需要相应的设置对应的环境变量. 
</p>
<div class="org-src-container">
<pre class="src src-Shell"># Environment variables for PEER0

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID="Org1MSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f297e9" class="outline-4">
<h4 id="org5f297e9">创建/加入Channel</h4>
<div class="outline-text-4" id="text-org5f297e9">
<p>
我们可以使用configtxgen工具来创建Channel.
</p>

<p>
首先进行CLI容器:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker exec -it cli bash
</pre>
</div>

<p>
之前, 我们使用configtxgen创建了Channel的配置交易channel.tx, 现在将它作为参数传递给Orderer, 作为创建Channel请求的一部分.
</p>

<p>
创建Channel的命令包含一些参数. <code>-c</code> 表示Channel名字, <code>-f</code> 表示Channel配置交易, 这边是channel.tx, 当然你也可以挂载你自己的配置交易, 名字也可以不一样, <code>--cafile</code> 允许我们验证TLS握手, 参数为证书根路径.
</p>

<p>
注: 不使用SSL/TLS的HTTP通信, 就是不加密的通信. SSL/TSL协议的基本过程为:
</p>
<ol class="org-ol">
<li>Client向Server索要并验证公钥</li>
<li>双方协商生成"对话密钥"</li>
<li>双方采用"对话密钥"进行加密</li>
</ol>
<p>
前两步就是握手阶段.
</p>
<div class="org-src-container">
<pre class="src src-Shell">export CHANNEL_NAME=mychannel
peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>
<p>
该命令返回一个创世区块, 我们准备把它加入到Channel. 在CLI容器当前目录下, 会生成一个mychannel.block的区块. 如图所示:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/18.png" alt="18.png" />
</p>
</div>

<p>
将 peer0.org1.example.com 加到 channel 中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer channel join -b mychannel.block
</pre>
</div>
<p>
如果要将其他节点加入Channel, 需要修改相应的环境变量. 这边以加入 peer0.org2.example.com 到Channel为例.
</p>
<div class="org-src-container">
<pre class="src src-Shell">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:7051 
CORE_PEER_LOCALMSPID="Org2MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
peer channel join -b mychannel.block
</pre>
</div>
<p>
注意, 这会改掉原有的环境变量. 如果全部写在一行去执行, 则不会改变默认的环境变量.
</p>
</div>
</div>

<div id="outline-container-org134f260" class="outline-4">
<h4 id="org134f260">关于Channel.</h4>
<div class="outline-text-4" id="text-org134f260">
<p>
在Fabric中, Channel是很重要的概念. 一个Peer要想与另一个Peer发生交易, 必须处于同一个Channel中, 账本与Channel也是一对一的关系. Channel需要使用 <code>peer channel ...</code> 这样的命令进行维护.
</p>

<p>
create(Channel在Orderer结点内部): <code>peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel.tx</code>
</p>

<p>
join(加入一个Channel): <code>peer channel join -b mychannel.block</code>
</p>

<p>
update(更新channel的某Org的配置): <code>peer channel update -o orderer.example.com:7050 -c mychannel -f ./Org1MSPanchors.tx</code>
</p>

<p>
Channel分成System Channel和Application Channel. 通过 <code>peer channel ...</code> 命令维护的都是Application Channel. 对Application Channel发起维护命令的Peer节点, 必须是提交的配置文件中所配置的Org中的一员, 提交的配置文件一般为 channel.tx, mychannel.block, Org1MSPanchors.tx. 本质的意思是说, 该Peer节点要持有该组织所颁发的证书.
</p>

<p>
create, join, update 三个命令, 都使用了配置文件.
</p>

<ol class="org-ol">
<li>channel.tx: 这是创建Application Channel的配置文件. channel.tx由configtxgen工具根据指定的profile从configtx.yaml中读取配置数据, profile指的是configtx.yaml中Profiles项下定义的某一个配置项. configtx.yaml文件规定了Channel中包含哪些组织, 创建Channel的命令会根据configtx.yaml生成配置信息, 导入到channel.tx中.</li>

<li>mychannel.block: 它是Application Channel的创世区块. 通过 <code>peer channel create</code> 生成. channel.tx只是配置原型, 在create过程中, 会根据System Channel的配置进行详细填补, 最后生成一个block. 要想加入Application Channel, 就要先获取这个Channel的genesis block.</li>

<li>Org1MSPanchors.tx: 更新组织的配置文件, 由configtxgen工具根据Org ID从configtx.yaml中指定的profile项生成. <code>configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP</code> 是指从configtx.yaml的Profiles下的TwoOrgsChannel项中获取Org ID为Org1MSP的组织的配置数据, 更新mychannel后, 把获取生成的配置数据导入到./Org1MSPanchors.tx文件中.</li>
</ol>
</div>
</div>

<div id="outline-container-org6510d9a" class="outline-4">
<h4 id="org6510d9a">更新锚节点</h4>
<div class="outline-text-4" id="text-org6510d9a">
<div class="org-src-container">
<pre class="src src-Shell">peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>

<p>
将Org2的锚节点定义为 peer0.org2.example.com:
</p>
<div class="org-src-container">
<pre class="src src-Shell">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp 
CORE_PEER_ADDRESS=peer0.org2.example.com:7051 
CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt 
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre>
</div>
</div>
</div>

<div id="outline-container-org0eb0a46" class="outline-4">
<h4 id="org0eb0a46">Chaincode的安装与初始化</h4>
<div class="outline-text-4" id="text-org0eb0a46">
<p>
应用程序通过Chaincode与BlockChain交互. 因此, 我们要在每个Peer上安装Chaincode来执行交易, 并在Channel中对其实例化.
</p>

<p>
将Go语言编写的Chaincode放在Peer的文件系统中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/
</pre>
</div>

<p>
将Node.js语言编写的Chaincode放在Peer的文件系统中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode install -n mycc -v 1.0 -l node -p /opt/gopath/src/github.com/chaincode/chaincode_example02/node/
</pre>
</div>

<p>
然后, 在Channel上进行实例化. 实例化会先初始化Chaincode, 为Chaincode设置背书策略, 为目标Peer启动Chaincode容器. <code>-P</code> 参数指定了在Chaincode上, 一个交易被认可所需要的背书级别.
</p>

<p>
如果策略是 <code>-P "OR ('Org0MSP.peer','Org1MSP.peer')"</code>, 表示Org1或Org2中的Peer认可, 就认可该交易. 如果把OR改成AND, 就表示需要两个都认可, 交易才会被认可.
</p>

<p>
实例化Go语言的Chaincode:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.peer','Org2MSP.peer')"
</pre>
</div>

<p>
实例化Node.js语言的Chaincode:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org1MSP.peer','Org2MSP.peer')"
</pre>
</div>
</div>
</div>

<div id="outline-container-org81cf3bd" class="outline-4">
<h4 id="org81cf3bd">查询</h4>
<div class="outline-text-4" id="text-org81cf3bd">
<p>
假设我们要查询 <code>a</code> 的值, 以确认Chaincode是否已实例化, state DB是否已填充. 查询的语法如下:
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'
</pre>
</div>

<p>
查询结果如下图所示:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/19.png" alt="19.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfa2714b" class="outline-4">
<h4 id="orgfa2714b">调用</h4>
<div class="outline-text-4" id="text-orgfa2714b">
<p>
假设我们要从 <code>a</code> 里面减去10给 <code>b</code>.
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}'
</pre>
</div>

<p>
此时, 再次查询 <code>a</code> 的值, 应该会从100变为90.
</p>
<div class="org-src-container">
<pre class="src src-Shell">peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'
</pre>
</div>


<div class="figure">
<p><img src="/assets/blog/2018/03/28/fabric官方案例first-network/20.png" alt="20.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org9ba9966" class="outline-4">
<h4 id="org9ba9966">背后的原理</h4>
<div class="outline-text-4" id="text-org9ba9966">
<p>
以上所说的步骤, 就是 <code>script.sh</code> 文件中的 <code>./byfn.sh up</code>. 现在, 使用 <code>./byfn.sh down</code> 来关闭它们.
</p>

<p>
总结一下, 主要步骤包含以下几点:
</p>
<ol class="org-ol">
<li><code>script.sh</code> 被拷贝到CLI容器中. <code>script.sh</code> 使用设定的Channel名字和Channel的配置文件 <code>channel.tx</code> 作为参数执行 <code>createChannel</code> 命令.</li>
<li><code>createChannel</code> 输出创世区块, 以 <code>channel_name.block</code> 命名. 该区块保存在Peer的文件系统里, 包含了 <code>channel.tx</code> 所指定的Channel的配置信息.</li>
<li><code>joinChannel</code> 被执行. 它使用 <code>channel_name.block</code> 作为输入, 将四个Peer节点加入到Channel, 并建立一个以 <code>channel_name.block</code> 为起始块的链.</li>
<li>现在的Channel = 2 * Org = 4 * Peer. 其中, Org1 = peer0.org1.example.com + peer1.org1.example.com, Org2 = peer0.org2.example.com + peer1.org2.example.com</li>
<li>将Org1MSPanchor.tx, Org2MSPanchor.tx, Channel作为参数给Ordering Service, 更新Org1MSP的Anchor Peer(peer0.org1.example.com)和Org2MSP的Anchor Peer(peer0.org2.example.com).</li>
<li>在peer0.org2.example.com上实例化Chaincode,  实例化过程将添加Chaincode到Channel上, 并启动Peer节点对应的容器, 初始化和Chaincode有关的键值对. 在这边, 初始化的值为["a", "100", "b", "200"]. 实例化后会启动一个名为 <code>dev-peer0.org2.example.com-mycc-1.0</code> 的容器.</li>
<li>实例化过程还会以背书策略为参数.</li>
<li>在peer0.org1.example.com上查询 <code>a</code> 的值. 之前, Chaincode已经安装在peer0.org1.example.com上了, 因此查询操作会启动一个名为 <code>dev-peer0.org1.example.com-mycc-1.0</code> 的容器.</li>
<li>在peer0.org1.example.com上执行转账.</li>
<li>发送查询到peer1.org2.example.com. 这时会启动第3个容器 <code>dev-peer1.org2.example.com-mycc-1.0</code>.</li>
</ol>
</div>
</div>

<div id="outline-container-org8b7a4bc" class="outline-4">
<h4 id="org8b7a4bc">总结</h4>
<div class="outline-text-4" id="text-org8b7a4bc">
<p>
要想对账本进行操作, 需要先在Peer上安装Chaincode. Chaincode容器在需要时(如查询)才会启动. Channel中每个Peer都有账本的副本, 存储了不可改变的, 序列化的记录区块和State Database用于保存当前的Fabric状态. 没有安装Chaincode的Peer也会同步账本.
</p>
</div>
</div>

<div id="outline-container-org031f31c" class="outline-4">
<h4 id="org031f31c">查看日志</h4>
<div class="outline-text-4" id="text-org031f31c">
<p>
CLI容器的日志:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker logs -f cli
</pre>
</div>

<p>
Chaincode的日志:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker logs dev-peer0.org2.example.com-mycc-1.0
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c2a856" class="outline-4">
<h4 id="org6c2a856">CouchDB</h4>
<div class="outline-text-4" id="text-org6c2a856">
<p>
状态数据库使用goleveldb或CouchDB. 默认为goleveldb.
</p>
</div>
</div>

<div id="outline-container-org3b05e66" class="outline-4">
<h4 id="org3b05e66">数据持久化</h4>
<div class="outline-text-4" id="text-org3b05e66">
<p>
如果要在Peer容器中进行数据持久化, 可以将docker容器内相应的目录挂载到宿主机器的一个目录中. 如, 添加下面的内容到 <code>docker-compose-base.yaml</code> 的Peer的约定中:
</p>
<div class="org-src-container">
<pre class="src src-Shell">volumes:
 - /var/hyperledger/peer0:/var/hyperledger/production
</pre>
</div>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-03-28</span>
        <span title="last modification date" class="post-info">2018-03-30</span>
        <span title="tags" class="post-info"><a href="/tags/blockchain/">BlockChain</a></span>
        <span title="author" class="post-info">Pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/03/28/fabric官方案例first-network";
          var disqus_url = "http://pinvondev.github.io/blog/2018/03/28/fabric官方案例first-network";
          var disqus_shortname = 'pinvon';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:pinvon &lt;at&gt; Inspiron">Pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
