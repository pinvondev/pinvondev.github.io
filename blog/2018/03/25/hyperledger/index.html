<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Hyperledger - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="&lt;TODO: insert your keywords here&gt;" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="//www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>Hyperledger</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8c625a3">词汇表</a></li>
<li><a href="#org4e829dd">简介</a>
<ul>
<li><a href="#org56024f6">分布式账本</a></li>
<li><a href="#org6fb3d98">智能合约</a></li>
<li><a href="#orgd3b6cca">共识</a></li>
<li><a href="#org4de49df">Hyperledger Fabric</a></li>
</ul>
</li>
<li><a href="#orge55fbb3">快速入门</a>
<ul>
<li><a href="#orge568d0f">先决条件</a>
<ul>
<li><a href="#orge0b513c">Git安装</a></li>
<li><a href="#orga35da44">Go语言</a></li>
<li><a href="#org1548a12">Docker</a></li>
<li><a href="#org7a0e22e">安装Pip</a></li>
</ul>
</li>
<li><a href="#org9c7c7f9">安装Hyperledger Fabric</a>
<ul>
<li><a href="#org01c22a4">创建GOPATH</a></li>
<li><a href="#org052202a">获取Fabric源码</a></li>
<li><a href="#orgc8ea856">安装Go相关库</a></li>
<li><a href="#org12089df">Orderer节点的编译</a></li>
<li><a href="#orgfd9021a">Peer节点的编译</a></li>
<li><a href="#orgb55b50b">编译Fabric工具</a></li>
<li><a href="#orga83458b">Docker镜像</a></li>
<li><a href="#org5f703d6">其他Docker镜像</a></li>
</ul>
</li>
<li><a href="#org072da40">运行</a></li>
<li><a href="#org7593be3">手动运行</a>
<ul>
<li><a href="#org37990c7">启动网络</a></li>
<li><a href="#org0b2688b">创建Channel</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org8c625a3" class="outline-2">
<h2 id="org8c625a3">词汇表</h2>
<div class="outline-text-2" id="text-org8c625a3">
</div>
<ul class="org-ul">
<li><a id="org4b81c53"></a>Anchor Peer(锚节点)<br />
<div class="outline-text-6" id="text-org4b81c53">
<p>
锚节点是通道中能被所有对等节点探测, 并能与之进行通信的一种对等节点. 通道中的每个成员都有一个(或多个, 以防单点故障)锚节点, 允许属于不同成员身份的节点来发现通道中存在的其他节点.
</p>

<p>
注: 网络中的节点.
</p>
</div>
</li>

<li><a id="org45a234e"></a>Block(区块)<br />
<div class="outline-text-6" id="text-org45a234e">
<p>
在一个通道上, 区块是一组有序交易的集合. 区块往往通过密码学手段(Hash)连接到前一个区块.
</p>
</div>
</li>

<li><a id="org1452081"></a>Chain(链)<br />
<div class="outline-text-6" id="text-org1452081">
<p>
链就是区块经过"哈希连接"结构化的交易日志. 对等节点(peer)从共识服务(order service)接收区块, 并根据背书策略和并发冲突标记区块的交易是否有效, 然后将该区块追加到对等节点文件系统的哈希链上.
</p>
</div>
</li>

<li><a id="orgba5b521"></a>Chaincode(链码)<br />
<div class="outline-text-6" id="text-orgba5b521">
<p>
链码是一个运行在账本上的软件, 可以对资产进行编码, 其中的交易指令(或业务逻辑)也可以用来修改资产.
</p>
</div>
</li>

<li><a id="orgd551be2"></a>Channel(通道)<br />
<div class="outline-text-6" id="text-orgd551be2">
<p>
通道是构建在"Fabric"网络上的私有区块链, 实现了数据的隔离和保密. 通道特定的账本在通道中是与所有对等节点共享的, 并且交易方必须通过该通道的正确验证才能与账本进行交互. 通道是由一个配置块来定义的.
</p>

<p>
注: 有点像局部网络.
</p>
</div>
</li>

<li><a id="org17469b7"></a>Commitment(提交)<br />
<div class="outline-text-6" id="text-org17469b7">
<p>
一个通道中的每个对等节点都会验证交易的有序区块, 然后将区块提交(写或追加)到该通道上账本的各个副本, 对等节点也会标记每个区块中的每笔交易的状态是有效还是无效.
</p>

<p>
注: 采矿成功后, 增加新区块.
</p>
</div>
</li>

<li><a id="orgae15dbd"></a>Concurrency Control Version Check(并发控制版本检查CCVC)<br />
<div class="outline-text-6" id="text-orgae15dbd">
<p>
CCVC是保持通道中各对等节点状态同步的一种方法.
</p>

<p>
对等节点并行执行交易, 在交易提交到账本之前(将交易打包成区块添加到区块链之前), 对等节点会检查交易在执行期间读到的数据是否被修改. 执行后要提交, 在这两个事件之间如果数据被改动, 就会引发CCVC冲突, 该交易会被账本中标记为无效, 不会被写入区块链中.
</p>
</div>
</li>

<li><a id="org44df023"></a>Configuration Block(配置区块)<br />
<div class="outline-text-6" id="text-org44df023">
<p>
为系统链或通道定义成员和策略的配置数据. 对某个通道或整个网络的配置修改都将导致生成一个新的配置区块, 并追加到适当的链上.
</p>
</div>
</li>

<li><a id="orge7d9553"></a>Consensus(共识)<br />
<div class="outline-text-6" id="text-orge7d9553">
<p>
共识是贯穿整个交易流程的广义术语, 用于产生一个对于排序的同意书和确认构成区块的交易集的正确性.
</p>
</div>
</li>

<li><a id="orgdccc975"></a>Current State(当前状态)<br />
<div class="outline-text-6" id="text-orgdccc975">
<p>
ledger的当前状态表示其chain交易log中所有key的最新值.
</p>
</div>
</li>

<li><a id="org0be3f86"></a>Ordering Service(排序服务或共识服务)<br />
<div class="outline-text-6" id="text-org0be3f86">
<p>
Ordering Service独立于Peer, 以先到先得的方式为网络上所有的channel做交易排序, 包含与每个Member相关的加密材料.
</p>

<p>
Orderer为区块链写入操作提供时序保证, 具体实现可以是共识算法或分布式的消息订阅消费系统(kafka).
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org4e829dd" class="outline-2">
<h2 id="org4e829dd">简介</h2>
<div class="outline-text-2" id="text-org4e829dd">
</div>
<div id="outline-container-org56024f6" class="outline-3">
<h3 id="org56024f6">分布式账本</h3>
<div class="outline-text-3" id="text-org56024f6">
<p>
去中心化: 在整个区块链网络中, 每个参与者都保存着一个区块链账本的副本.
</p>

<p>
协作: 所有参与者共同维护着账本.
</p>

<p>
不可篡改: 加密技术保证交易一旦写入账本, 就无法篡改. 不可篡改性使得信息来源的确认变得容易.
</p>
</div>
</div>

<div id="outline-container-org6fb3d98" class="outline-3">
<h3 id="org6fb3d98">智能合约</h3>
<div class="outline-text-3" id="text-org6fb3d98">
<p>
区块链网络使用智能合约来实现对账本的访问和控制.
</p>

<p>
智能合约不仅可用于在区块链网络中打包信息, 还可以用于自动执行参与者定义的特定交易操作. 如, 买卖双方可以定义一个智能合约, 以保证当卖方发货的商品运送到达时, 买方支付的货款会自动转账给卖方.
</p>
</div>
</div>

<div id="outline-container-orgd3b6cca" class="outline-3">
<h3 id="orgd3b6cca">共识</h3>
<div class="outline-text-3" id="text-orgd3b6cca">
<p>
共识就是保持网络中所有账本交易的同步流程. 它保证了账本只会在交易双方都确认后才进行更新. 同时在账本更新时, 交易双方能够在账本中的相同位置, 更新一个相同的交易信息.
</p>

<p>
目前, 我们只需把区块链理解为一个共享的, 通过智能合约更新的多副本交易系统, 同时这个系统通过协作共识机制保证了网络中所有账本副本的同步.
</p>
</div>
</div>

<div id="outline-container-org4de49df" class="outline-3">
<h3 id="org4de49df">Hyperledger Fabric</h3>
<div class="outline-text-3" id="text-org4de49df">
<p>
2015年, Linux基金会启动了Hyperledger项目, 目标是发展跨行业的区块链技术. Hyperledger Fabric是Hyperledger的一个区块链项目.
</p>

<p>
Hyperledger Fabric需要登录才能加入网络.
</p>

<p>
通道功能: 允许参与者为交易新建一个单独的账本. 当网络中的一些参与者是竞争对手时, 这个功能尤为重要. 因为这些参与者并不希望所有的交易信息(如给部分客户优惠)都对网络中所有参与者公开. 只有在同一个通道中的参与者, 才会拥有该通道中的账本.
</p>

<p>
共享账本: Hyperledger Fabric的账本子系统包含世界状态和交易记录. 世界状态组件描述了账本在特定时间点的状态, 它是账本的数据库; 交易记录组件记录了产生世界状态当前值的所有交易, 它是世界状态的更新历史.
</p>

<p>
智能合约: 在Hyperledger Fabric中称为chaincode. 当一个区块链外部的应用程序需要访问账本时, 就会调用chaincode. 一般情况下, chaincode只会访问账本的世界状态, 不会查询交易记录. 目前使用Go编写chaincode.
</p>
</div>
</div>
</div>

<div id="outline-container-orge55fbb3" class="outline-2">
<h2 id="orge55fbb3">快速入门</h2>
<div class="outline-text-2" id="text-orge55fbb3">
</div>
<div id="outline-container-orge568d0f" class="outline-3">
<h3 id="orge568d0f">先决条件</h3>
<div class="outline-text-3" id="text-orge568d0f">
<p>
在v1.0.0发行之前, 使用Ubuntu的Vagrant来作为开发环境. 而Docker容器可以为MacOS, Windows, Linux三个平台的开发人员提供一致的体验, 因此, 现在更推荐使用Docker容器进行开发环境的搭建.
</p>

<p>
本平台为Ubuntu 16.04LTS. 如果是其他系统, 请查看<a href="http://hyperledger-fabric.readthedocs.io/en/latest/dev-setup/devenv.html">官网的环境搭建</a>
</p>
</div>

<div id="outline-container-orge0b513c" class="outline-4">
<h4 id="orge0b513c">Git安装</h4>
</div>

<div id="outline-container-orga35da44" class="outline-4">
<h4 id="orga35da44">Go语言</h4>
<div class="outline-text-4" id="text-orga35da44">
<p>
安装 Go 1.9 或者更后的版本.
</p>

<p>
首先到<a href="https://golang.org/dl/">官网</a>下载压缩包. 最好选择稳定版本.
</p>

<p>
仅介绍Ubuntu 16.04TLS的安装, 其他环境的安装, 请参考<a href="https://golang.org/doc/install">官网的安装教程</a>
</p>

<div class="org-src-container">
<pre class="src src-Shell"># 解压至/usr/local目录
sudo tar -C /usr/local -xzf go1.9.4.linux-amd64.tar.gz

# 打开配置
emacs ~/.bashrc

# 将 /usr/local/go/bin 添加到环境变量
export GOROOT=/usr/local/go
export GOPATH=$HOME/go # 配置GOPATH是为了后面需要
export PATH=$GOPATH/bin:$GOROOT/bin:$PATH

# 使配置生效
source ~/.bashrc
</pre>
</div>

<p>
测试直接输入 <code>go</code>, 会有一些go命令的说明. 如果有异常, 说明没安装成功. 
</p>

<p>
也可以直接测试文件: 新建文件 test.go, 输入代码:
</p>
<div class="org-src-container">
<pre class="src src-GO">package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
</pre>
</div>

<p>
运行:
</p>
<div class="org-src-container">
<pre class="src src-Shell">go run test.go
</pre>
</div>

<p>
如果出现"hello world", 则说明安装成功.
</p>
</div>
</div>


<div id="outline-container-org1548a12" class="outline-4">
<h4 id="org1548a12">Docker</h4>
<div class="outline-text-4" id="text-org1548a12">
<p>
Docker是一个容器, 在这个容器中, 我们可以运行我们的实例. 可以把Docker大致当成一个虚拟机, 但是Docker不需要占用那么多空间.
</p>

<p>
每个Docker将在本地运行一个与Hyperledger网络相关的服务.
</p>

<p>
可以使用CLI或终端来安装Docker, 这边我们需要安装两个包: docker-engine和docker-compose.
</p>

<p>
docker-engine: 基础包, 它使得docker容器需要的所有必须的文件正常运行.
</p>

<p>
docker-compose: 用于配置Docker.
</p>
</div>

<ul class="org-ul">
<li><a id="org1d117a7"></a>添加Docker的APT源<br />
<div class="outline-text-5" id="text-org1d117a7">
<div class="org-src-container">
<pre class="src src-Shell"># 将官方Docker资源库的GPG密钥添加到系统
sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D

# 将Docker存储库添加到APT源
echo "deb https://apt.dockerproject.org/repo ubuntu-xenial main" | sudo tee /etc/apt/sources.list.d/docker.list

# 更新软件包数据库
sudo apt-get update

# 确保从Docker repo中安装
apt-cache policy docker-engine
</pre>
</div>
</div>
</li>

<li><a id="org579d1d9"></a>安装Docker<br />
<div class="outline-text-5" id="text-org579d1d9">
<div class="org-src-container">
<pre class="src src-Shell">sudo apt-get install -y docker-engine

# 开启docker服务
sudo service docker start

# 让docker服务开机自启动
sudo systemctl enable docker

# 如果要取消开机自动启动, 则输入
sudo systemctl disable docker

# 测试docker是否在运行
docker

# 使用pip安装docker-compose
sudo pip install docker-compose
</pre>
</div>

<p>
关于Docker的安装, 到此结束.
</p>

<p>
默认情况下, 运行docker需要root权限, 也可以用安装docker的用户运行. 但是如果其他用户想要运行docker, 则会出错. 可以通过如下命令, 使用户有权限运行docker:
</p>
<div class="org-src-container">
<pre class="src src-Shell">sudo usermod -aG docker username
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org7a0e22e" class="outline-4">
<h4 id="org7a0e22e">安装Pip</h4>
</div>
</div>
<div id="outline-container-org9c7c7f9" class="outline-3">
<h3 id="org9c7c7f9">安装Hyperledger Fabric</h3>
<div class="outline-text-3" id="text-org9c7c7f9">
</div>
<div id="outline-container-org01c22a4" class="outline-4">
<h4 id="org01c22a4">创建GOPATH</h4>
<div class="outline-text-4" id="text-org01c22a4">
<div class="org-src-container">
<pre class="src src-Shell">mkdir -p $GOPATH

cd $GOPATH
mkdir src
cd src
mkdir github.com
cd github.com
mkdir hyperledger
cd hyperledger
</pre>
</div>
</div>
</div>

<div id="outline-container-org052202a" class="outline-4">
<h4 id="org052202a">获取Fabric源码</h4>
<div class="outline-text-4" id="text-org052202a">
<p>
在hyperledger目录下, 执行如下命令:
</p>
<div class="org-src-container">
<pre class="src src-Shell">git clone https://github.com/hyperledger/fabric.git
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc8ea856" class="outline-4">
<h4 id="orgc8ea856">安装Go相关库</h4>
<div class="outline-text-4" id="text-orgc8ea856">
<p>
安装必要工具:
</p>
<div class="org-src-container">
<pre class="src src-Shell">sudo apt install libtool libltdl-dev
</pre>
</div>

<p>
如果直接使用 <code>make docker</code>, 在国内会碰到许多错误, 比如编译golint时因为下载超时报错. 这是因为hyperledger fabric是使用go语言编写的, 需要依赖一些工具或者第三方库, 但是因为谷歌有些东西被墙了, 所以要自己手动下载并安装.
</p>
<div class="org-src-container">
<pre class="src src-Shell">mkdir -p $GOPATH/src/golang.org/x
cd $GOPATH/src/golang.org/x
git clone https://github.com/golang/tools.git

# 下载完成后执行以下命令
go get github.com/kardianos/govendor
go get github.com/golang/lint/golint
go get golang.org/x/tools/cmd/goimports
go get github.com/onsi/ginkgo/ginkgo
go get github.com/axw/gocov/...
go get github.com/client9/misspell/cmd/misspell
go get github.com/AlekSi/gocov-xml
go get github.com/golang/protobuf/protoc-gen-go
</pre>
</div>

<p>
如果出现如下问题:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/25/hyperledger/5.png" alt="5.png" />
</p>
</div>

<p>
说明当前用户没有权限来运行docker. 执行以下语句:
</p>
<div class="org-src-container">
<pre class="src src-Shell">sudo usermod -aG docker $USER
# 重启
</pre>
</div>
</div>
</div>

<div id="outline-container-org12089df" class="outline-4">
<h4 id="org12089df">Orderer节点的编译</h4>
<div class="outline-text-4" id="text-org12089df">
<p>
Orderer节点容器里面运行的是Orderer服务, 要想生成Orderer镜像, 就需要先编译出Orderer程序.
</p>
<div class="org-src-container">
<pre class="src src-Shell">make orderer
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd9021a" class="outline-4">
<h4 id="orgfd9021a">Peer节点的编译</h4>
<div class="outline-text-4" id="text-orgfd9021a">
<p>
Chaincode运行在Peer所在的机器上, 需要给Chaincode准备运行的基础环境, 即ccenv和javaenv两个镜像. 由于被墙, 需要先将之前go的工具拷贝进来.
</p>

<div class="org-src-container">
<pre class="src src-Shell">mkdir -p build/docker/gotools/bin/
cp $GOPATH/src/bin/* ./build/docker/gotools/bin/
make peer
</pre>
</div>

<p>
成功之后显示如下:
<img src="/assets/blog/2018/03/25/hyperledger/7.png" alt="7.png" />
</p>


<p>
使用命令 <code>docker image</code> 可查看已安装的镜像文件.
</p>

<p>
现在, 可以进入 <code>example/e2e_cli</code>, 使用脚本, 一键启动程序.
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 开启
./network_setup.sh up [channel-id is optional]

# 关闭
./network_setup.sh down
</pre>
</div>

<p>
为了加快部署过程, hyperledger提供了一个脚本来执行所有任务. 该脚本会生成配置结果, 本地网络, Chaincode测试.
</p>

<p>
进入 <code>examples/e2e_cli</code> 目录, 从Docker Hub获取镜像:
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 使脚本可执行
chmod +x download-dockerimages.sh

# 执行脚本
./download-dockerimages.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb55b50b" class="outline-4">
<h4 id="orgb55b50b">编译Fabric工具</h4>
<div class="outline-text-4" id="text-orgb55b50b">
<p>
configtxgen工具用来配置Fabric的通道. 它的配置参数主要由 <code>configtx.yaml</code> 文件提供.
</p>

<p>
cryptogen工具可以快速地根据配置自动批量生成所需要的密钥及证书文件. 它的配置参数主要由 <code>crypto-config.yaml</code> 文件提供.
</p>

<p>
在 <code>fabric</code> 目录下, 编译 <code>configtxgen</code>:
</p>
<div class="org-src-container">
<pre class="src src-Shell">make configtxgen
</pre>
</div>

<p>
如果出现下图所示的提示, 说明编译成功.
<img src="/assets/blog/2018/03/25/hyperledger/3.png" alt="3.png" />
</p>

<p>
编译后的执行文件放在 <code>fabric/build/bin/configtxgen</code>.
</p>

<p>
如果出现 <code>find: `/src/github.com/hyperledger/fabric/core/chaincode/shim': 没有那个文件或目录</code>, 说明 <code>GOPATH</code> 没有配置好, 或者配置了之后没有 <code>source ~/.bashrc</code>.
</p>

<p>
cryptogen工具的编译方式也一样:
</p>
<div class="org-src-container">
<pre class="src src-Shell">make cryptogen
</pre>
</div>

<p>
编译 configtxlator:
</p>
<div class="org-src-container">
<pre class="src src-Shell">make configxlator
</pre>
</div>
</div>
</div>

<div id="outline-container-orga83458b" class="outline-4">
<h4 id="orga83458b">Docker镜像</h4>
<div class="outline-text-4" id="text-orga83458b">
<p>
前面只是生成了Fabric的二进制文件, 不能直接使用. 需要将这些文件打包到Docker镜像中.
</p>


<div class="org-src-container">
<pre class="src src-Shell"># 生成Orderer镜像
make orderer-docker

# 生成Peer镜像
make peer-docker

# fabric-tools镜像
make tools-docker

# 查看docker镜像文件
docker images
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f703d6" class="outline-4">
<h4 id="org5f703d6">其他Docker镜像</h4>
<div class="outline-text-4" id="text-org5f703d6">
<p>
CouchDB做状态数据库, Kafka做共识, Zookeeper做Kafka的高可用支持. 直接使用以下命令生成:
</p>
<div class="org-src-container">
<pre class="src src-Shell">make docker
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org072da40" class="outline-3">
<h3 id="org072da40">运行</h3>
<div class="outline-text-3" id="text-org072da40">
<p>
configtxgen工具会生成两个内容: Orderer的bootstrap block和Fabric的channel configuration transaction.
</p>

<p>
orderer block: ordering服务的创世区块(第一个区块).
</p>

<p>
channel transaction: 在 create channel 时会被广播给orderer.
</p>

<p>
configtx.yaml: 给出网络的定义, 拓扑结构.
</p>

<p>
crypto-config目录: 包含每个实体的admin证书, ca证书, 签名证书, 私钥等.
</p>

<p>
generateArtifacts.sh: 该脚本自动为我们生成启动网络所需的配置及创世区块. 如果之前使用过 <code>network_setup.sh</code>, 则先将 <code>channel-artifact目录</code> 里的可见文件都删除, 隐藏文件不用删, 再将 <code>crypto-config</code> 目录直接删除.
</p>

<p>
生成通道的区块和配置:
</p>
<div class="org-src-container">
<pre class="src src-Shell">cd examples/e2e_cli
./generateArtifacts.sh 
</pre>
</div>

<p>
成功后会有类似如下的输出:
<img src="/assets/blog/2018/03/25/hyperledger/4.png" alt="4.png" />
</p>

<p>
启动网络:
</p>
<pre class="example">
cd examples/e2e_cli
./network_setup.sh up [channel-id-optional]
</pre>

<p>
出现如下界面, 说明网络启动运行, 并测试成功:
</p>


<div class="figure">
<p><img src="/assets/blog/2018/03/25/hyperledger/8.png" alt="8.png" />
</p>
</div>

<p>
停止网络有两种方法:
</p>

<p>
第一种:
</p>
<div class="org-src-container">
<pre class="src src-Shell"># 新开一个终端, 进入examples/e2e_cli
rm -f $(docker ps -aq)

# 查看镜像
docker images

# 将dev-peerx.orgx.example字样的镜像文件删除
# 输入其image id的前6位
docker rmi -f 07032a eb54b1 a9ad47

# 删除配置结果
rm ./ channel-artifacts/*.tx
rm -rf crypto-config
</pre>
</div>

<p>
第二种:
</p>
<div class="org-src-container">
<pre class="src src-Shell">./network_setup.sh down
# 该命令会自动删除启动网络时生成的镜像文件和配置文件
</pre>
</div>
</div>
</div>

<div id="outline-container-org7593be3" class="outline-3">
<h3 id="org7593be3">手动运行</h3>
<div class="outline-text-3" id="text-org7593be3">
<p>
之前是使用脚本一键启动, 关闭. 我们可以手动来做一遍, 这样就明白背后发生了什么事.
</p>

<p>
进入 <code>examples/e2e_cli</code> 目录.
</p>

<p>
打开 <code>docker-compose-cli.yaml</code>, 找到启动 <code>script.sh</code> 的语句, 注释掉.
</p>
<div class="org-src-container">
<pre class="src src-Shell">working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
# command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT'
</pre>
</div>
</div>

<div id="outline-container-org37990c7" class="outline-4">
<h4 id="org37990c7">启动网络</h4>
<div class="outline-text-4" id="text-org37990c7">
<div class="org-src-container">
<pre class="src src-Shell">docker-compose -f docker-compose-cli.yaml up
</pre>
</div>
</div>
</div>

<div id="outline-container-org0b2688b" class="outline-4">
<h4 id="org0b2688b">创建Channel</h4>
<div class="outline-text-4" id="text-org0b2688b">
<p>
Channel在逻辑上将我们自己编写的Chaincode与其他的Chaincode区分开来.
</p>

<p>
进入Cli镜像:
</p>
<div class="org-src-container">
<pre class="src src-Shell">docker exec -it cli bash
</pre>
</div>

<p>
仅以peer0节点为例, 修改环境变量:
</p>
<div class="org-src-container">
<pre class="src src-Shell">
</pre>
</div>


<div class="org-src-container">
<pre class="src src-Shell">Having all peers join the channel...
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key
CORE_PEER_LOCALMSPID=Org1MSP
CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt
CORE_PEER_TLS_ENABLED=true
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ID=cli
CORE_LOGGING_LEVEL=DEBUG
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-03-25</span>
        <span title="last modification date" class="post-info">2018-03-28</span>
        <span title="tags" class="post-info"><a href="/tags/blockchain/">BlockChain</a></span>
        <span title="author" class="post-info">pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/03/25/hyperledger";
          var disqus_url = "http://pinvondev.github.io/blog/2018/03/25/hyperledger";
          var disqus_shortname = 'pinvon';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
       <div id="hashover"></div>
       <script type="text/javascript" src="/hashover.php"></script>
       <noscript>You must have JavaScript enabled to use the comments.</noscript>
      </section>
      <script src="//code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x (<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:pinvon &lt;at&gt; ubuntu">pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
