<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>九 SDK - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="&lt;TODO: insert your keywords here&gt;" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="q" value="site:pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>九 SDK</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgdc035c8">概述</a></li>
<li><a href="#org6b3dfff">FabricClient</a></li>
<li><a href="#org5002257">Config</a></li>
<li><a href="#org5a7f680">Channel</a></li>
<li><a href="#orgf3521e5">Peer</a></li>
<li><a href="#orgb6e9704">Orderer</a></li>
<li><a href="#org28af92f">User</a></li>
<li><a href="#orge4fdbd8">KeyValueStore</a></li>
<li><a href="#org5399cbb">EventHub</a></li>
<li><a href="#org5840438">FabricCAClient</a></li>
<li><a href="#org51b4baf">UML图</a></li>
<li><a href="#org3fd7398">应用场景</a>
<ul>
<li><a href="#orgbc71046">用户登记和注册</a></li>
<li><a href="#org5754771">在排序服务上创建通道</a></li>
<li><a href="#org390c98e">Peer节点加入通道</a></li>
<li><a href="#orga6b00e3">安装链码</a></li>
<li><a href="#orge7c252f">通过Peer节点实例化链码</a></li>
<li><a href="#orgc4eb017">发起交易请求并生成区块</a></li>
<li><a href="#org5f0d040">链码的开发和调试</a>
<ul>
<li><a href="#org662bdd2">链码调用参数解析</a></li>
<li><a href="#org2f53b54">交易信息解析</a></li>
<li><a href="#org5b5b4c5">状态数据操作</a></li>
<li><a href="#org4e3434e">链码调用</a></li>
<li><a href="#org682487d">事件处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgdc035c8" class="outline-2">
<h2 id="orgdc035c8">概述</h2>
<div class="outline-text-2" id="text-orgdc035c8">
<p>
目前的SDK有以下几种:
</p>

<p>
Golang: <a href="https://github.com/hyperledger/fabric-sdk-go">https://github.com/hyperledger/fabric-sdk-go</a>
</p>

<p>
Node.js: <a href="https://github.com/hyperledger/fabric-sdk-node">https://github.com/hyperledger/fabric-sdk-node</a> (最全)
</p>

<p>
Python: <a href="https://github.com/hyperledger/fabric-sdk-py">https://github.com/hyperledger/fabric-sdk-py</a>
</p>

<p>
Java: <a href="https://github.com/hyperledger/fabric-sdk-java">https://github.com/hyperledger/fabric-sdk-java</a>
</p>

<p>
主要模块: FabricClient, Config, Channel, Peer, Orderer, User, KeyValueStore, EventHub, Logger等.
</p>
</div>
</div>

<div id="outline-container-org6b3dfff" class="outline-2">
<h2 id="org6b3dfff">FabricClient</h2>
<div class="outline-text-2" id="text-org6b3dfff">
<p>
应用程序的入口模块, 提供通道管理, 链码管理, 数据存储, 密码学相关的功能. 每个FabricClient实例对应一个区块链网络, 包括记账节点, 排序节点等. 如果应用程序需要访问多个网络, 可以建立多个FabricClient实例, 不同的实例对应不同的网络.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">输入参数</th>
<th scope="col" class="org-left">输出参数</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">NewChannel</td>
<td class="org-left">(name string)</td>
<td class="org-left">(Channel, error)</td>
<td class="org-left">创建通道</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Channel</td>
<td class="org-left">(name string)</td>
<td class="org-left">(Channel)</td>
<td class="org-left">查询指定名称的通道</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">ExtractChannelConfig</td>
<td class="org-left">(configEnvelope []byte)</td>
<td class="org-left">([]byte, error)</td>
<td class="org-left">从ConfigEnvelope里解析出ConfigUpdate</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">SignChannelConfig</td>
<td class="org-left">(config []byte)</td>
<td class="org-left">(*common.ConfigSignature, error)</td>
<td class="org-left">用FabricClient关联的用户身份对ExtractChannelConfig解析出来的config进行签名</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CreateChannel</td>
<td class="org-left">(request fab.Create ChannelRequest)</td>
<td class="org-left">(apitxn.TransactionID, error)</td>
<td class="org-left">创建通道, 创建通道的参数包括通道名称, 排序服务实例, 通道配置等信息, 返回包含随机数的交易号</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">QueryChannelInfo</td>
<td class="org-left">(name string, peers []fab.Peer)</td>
<td class="org-left">(fab.Channel, error)</td>
<td class="org-left">从指定节点查询通道</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">StateStore</td>
<td class="org-left">()</td>
<td class="org-left">(fab.KeyValueStore)</td>
<td class="org-left">返回状态存储的实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">SigningManager</td>
<td class="org-left">()</td>
<td class="org-left">(fab.SigningManager)</td>
<td class="org-left">返回签名Manager实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">CryptoSuite</td>
<td class="org-left">()</td>
<td class="org-left">bccsp.BCCSP</td>
<td class="org-left">返回BCCSP实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">SaveUserToStateStore</td>
<td class="org-left">(user fab.User, skip Persistence bool)</td>
<td class="org-left">(error)</td>
<td class="org-left">保存用户实例到状态存储里</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">LoadUserFromStateStore</td>
<td class="org-left">(name string)</td>
<td class="org-left">(fab.User, error)</td>
<td class="org-left">从状态存储里获取指定名称的用户实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">InstallChaincode</td>
<td class="org-left">(chaincodeName string, chaincodePath string, chaincodeVersion string, chaincodePackage []byte, targets []fab.Peer)</td>
<td class="org-left">([]*apitxn.TransactionProposal Response, string, error)</td>
<td class="org-left">安装指定链码名称, 路径, 版本的链码到指定的节点中</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">QueryChannels</td>
<td class="org-left">(peer fab.Peer)</td>
<td class="org-left">(*pb.ChannelQueryResponse, error)</td>
<td class="org-left">查询指定节点加入的所有通道</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">QueryInstalledChaincodes</td>
<td class="org-left">(peer fab.Peer)</td>
<td class="org-left">(*pb.ChannelQueryResponse, error)</td>
<td class="org-left">查询指定节点安装的所有链码</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">UserContext</td>
<td class="org-left">()</td>
<td class="org-left">(user fab.User)</td>
<td class="org-left">返回当前FabricClient的用户实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">SetUserContext</td>
<td class="org-left">(user fab.User)</td>
<td class="org-left">()</td>
<td class="org-left">设置当前FabricClient的用户实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Config</td>
<td class="org-left">()</td>
<td class="org-left">(config.Config)</td>
<td class="org-left">设置当前FabricClient的配置实例</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">NewTxnID</td>
<td class="org-left">()</td>
<td class="org-left">apitxn.TransactionID, error</td>
<td class="org-left">本地生成包含随机数的交易号</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5002257" class="outline-2">
<h2 id="org5002257">Config</h2>
<div class="outline-text-2" id="text-org5002257">
<p>
初始化FabricClient时需要离线获取配置信息, 包括可信的根证书, 排序服务节点证书和IP地址, 记账节点证书和IP地址等. Config读取后传递给FabricClient. 配置信息是动态传递的, SDK不会持久化存储, 应用程序负责维护这些配置信息.
</p>


<div class="figure">
<p><img src="./51.png" alt="51.png" />
</p>
</div>


<div class="figure">
<p><img src="./52.png" alt="52.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5a7f680" class="outline-2">
<h2 id="org5a7f680">Channel</h2>
<div class="outline-text-2" id="text-org5a7f680">
<p>
通道是排序服务创建的隔离不同链上交易的实例, 加入到不同通道的节点接收到的是不同的交易. 通道在配置了排序服务节点和Peer节点后需要初始化, 初始化的时候给排序服务节点发送获取配置区块的请求.
</p>


<div class="figure">
<p><img src="./53.png" alt="53.png" />
</p>
</div>


<div class="figure">
<p><img src="./54.png" alt="54.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf3521e5" class="outline-2">
<h2 id="orgf3521e5">Peer</h2>
<div class="outline-text-2" id="text-orgf3521e5">
<p>
Peer是客户端发送背书请求, 交易查询的节点. Peer实例包含节点名称, 地址, 角色, 注册证书等信息.
</p>


<div class="figure">
<p><img src="./55.png" alt="55.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb6e9704" class="outline-2">
<h2 id="orgb6e9704">Orderer</h2>
<div class="outline-text-2" id="text-orgb6e9704">
<p>
Orderer是客户端发送交易进行排序的节点, Orderer实例包含了排序服务节点地址信息, 定义了发送原子广播请求和获取区块的接口.
</p>


<div class="figure">
<p><img src="./56.png" alt="56.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org28af92f" class="outline-2">
<h2 id="org28af92f">User</h2>
<div class="outline-text-2" id="text-org28af92f">
<p>
User表示已经生成了注册证书和签名密钥的实体, 注册证书必须是CA颁发的证书, 只有生成了注册证书的实体, 都能进行部署链码, 提交交易, 查询交易等.
</p>


<div class="figure">
<p><img src="./57.png" alt="57.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge4fdbd8" class="outline-2">
<h2 id="orge4fdbd8">KeyValueStore</h2>
<div class="outline-text-2" id="text-orge4fdbd8">
<p>
KeyValueStore提供给应用程序保存敏感信息的功能, 如用户私钥, 证书信息等.
</p>


<div class="figure">
<p><img src="./58.png" alt="58.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5399cbb" class="outline-2">
<h2 id="org5399cbb">EventHub</h2>
<div class="outline-text-2" id="text-org5399cbb">
<p>
EventHub封装了与Peer节点交互的事件流, 接收Peer的各种异步通知事件.
</p>


<div class="figure">
<p><img src="./59.png" alt="59.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5840438" class="outline-2">
<h2 id="org5840438">FabricCAClient</h2>
<div class="outline-text-2" id="text-org5840438">

<div class="figure">
<p><img src="./60.png" alt="60.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org51b4baf" class="outline-2">
<h2 id="org51b4baf">UML图</h2>
<div class="outline-text-2" id="text-org51b4baf">

<div class="figure">
<p><img src="./61.png" alt="61.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org3fd7398" class="outline-2">
<h2 id="org3fd7398">应用场景</h2>
<div class="outline-text-2" id="text-org3fd7398">
</div>
<div id="outline-container-orgbc71046" class="outline-3">
<h3 id="orgbc71046">用户登记和注册</h3>
<div class="outline-text-3" id="text-orgbc71046">
<ol class="org-ol">
<li>应用程序根据配置文件获取CA和CSP的配置信息.</li>
<li>应用程序根据配置信息创建FabricClient的实例, 并设置CryptoSuite和KeyValueStore等信息, FabricClient实例是整个操作的入口.</li>
<li>应用程序获取负责提交用户资料的登记员信息Registrar, 如果不存在, 需要先初始化登记员用户, 获取登记员的注册证书和私钥信息.</li>
<li>应用程序根据配置信息和组织信息创建FabricCAClient实例.</li>
<li>应用程序根据需要登记的用户信息, 生成RegistrationRequest请求, 提交给FabricCAClient.</li>
<li>登记员Registrar会提交访问Fabric-CA的POST请求, 请求的URL是/api/v1/register.</li>
<li>Fabric-CA验证请求, 生成用户注册的密码Secret, 最终返回给应用程序, 完成用户信息登记的步骤.</li>
<li>应用程序利用申请的用户信息和返回的注册密码, 调用FabricCAClient的enroll().</li>
<li>FabricCAClient生成私钥和证书签名请求CSR, 调用Fabrica-CA的enroll()生成注册证书.</li>
<li>Fabric-CA返回生成的注册证书和私钥给应用程序.</li>
<li>应用程序可选地保存用户信息到KeyValueStore里.</li>
</ol>


<div class="figure">
<p><img src="./62.png" alt="62.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5754771" class="outline-3">
<h3 id="org5754771">在排序服务上创建通道</h3>
<div class="outline-text-3" id="text-org5754771">
<p>
创建通道需要先使用工具configtxgen生成通道的配置文件mychannel.tx.
</p>

<ol class="org-ol">
<li>应用程序读取通道配置文件mychannel.tx, 这个文件是用configtxgen生成的, 包含了通道名称, 组织配置等信息.</li>
<li>创建通道只需要和Orderer节点通信, 需要通过Orderer节点的配置, 生成Orderer实例.</li>
<li>应用程序指定通道名称, 并通过mychannel.tx和Orderer实例, 生成创建通道请求CreateChannelRequest.</li>
<li>应用程序创建FabricClient实例, 调用CreateChannel(CreateChannelRequest)创建通道.</li>
<li>SDK将CreateChannelRequest转换, 生成HeaderType_CONFIG_UPDATE类型的交易common.Payload.</li>
<li>SDK对common.Payload进行签名, 签名者需要有创建通道的管理员权限.</li>
<li>SDK通过Orderer实例, 发送SendBroadcast请求, 提交请求给Orderer节点.</li>
<li>Orderer节点检查提交的请求, 校验是否有权限创建新的通道, 创建通道以后, Orderer节点就可以接收新的通道请求了.</li>
</ol>


<div class="figure">
<p><img src="./63.png" alt="63.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org390c98e" class="outline-3">
<h3 id="org390c98e">Peer节点加入通道</h3>
<div class="outline-text-3" id="text-org390c98e">
<p>
创建通道以后, Orderer节点上就有了新通道的基本信息, 可以对新通道的交易进行排序打包生成区块了. 现在, 将Peer节点加入到新通道中, 应用程序才能通过Peer节点发起交易请求. 将Peer节点加入通道, 需要从Orderer节点上获取genesis.block, 然后在Peer节点本地初始化链.
</p>

<ol class="org-ol">
<li>应用程序进行必要的初始化配置, 如创建FabricClient实例, 设置发起加入通道请求的用户, Channel实例, Orderer实例等.</li>
<li>应用程序调用GenesisBlock的请求, 获取创世区块, Channel实例会构造HeaderType_DELIVER_SEEK_INFO的请求, 通过Orderer实例发送sendDeliver请求给Orderer节点, 获取该通道的genesis.block.</li>
<li>应用程序利用获取到的genesis.block, 构造JoinChannelRequest请求, 通过Channel实例发起JoinChannel请求.</li>
<li>SDK的JoinChannel会根据JoinChannelRequest请求, 重新构造类型为HeaderType_ENDORSER_TRANSACTION的Proposal, Proposal会利用FabricClient实例设置的用户进行签名, 生成SignedProposal.</li>
<li>需要为每个加入通道的Peer节点创建一个Peer实例, 通过Peer实例调用ProcessProposal向Peer节点发送加入通道的SignedProposal.</li>
<li>SignedProposal调用CSCC的JoinChain请求, Peer节点接收到SignedProposal请求后, 会调用CSCC进行必要的消息有效性检查和权限检查, 然后在本地Peer节点初始化链. 初始化的过程会根据通道名称在本地目录创建账本数据, 写入通道的genesis.block.</li>
<li>创建好通道的本地账本以后, Peer节点会启动Gossip服务, 从排序服务节点同步最新的区块数据. 根据Peer节点的配置, 参与主节点的选举或者直接作为主节点进行Peer节点之间的P2P通信.</li>
<li>Peer节点初始化链以后, 就可以接收新链的交易请求了.</li>
</ol>


<div class="figure">
<p><img src="./64.png" alt="64.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orga6b00e3" class="outline-3">
<h3 id="orga6b00e3">安装链码</h3>
<div class="outline-text-3" id="text-orga6b00e3">
<p>
把包含链码源码的ChaincodeDeploymentSpec上传到Peer节点.
</p>
</div>
</div>

<div id="outline-container-orge7c252f" class="outline-3">
<h3 id="orge7c252f">通过Peer节点实例化链码</h3>
<div class="outline-text-3" id="text-orge7c252f">
<p>
实例化链码时, 会创建链码镜像, 启动链码容器, 并调用链码的Init接口初始化, 生成的交易会发送到Orderer节点, 生成区块并记录到账本中.
</p>

<ol class="org-ol">
<li>应用程序创建多个实例, 包含FabricClient实例, User实例, Channel实例, Peer实例等.</li>
<li>通过调用Channel实例的SendInstantiateProposal进行链码实例化.</li>
<li>SDK会构造包含ChaincodeDeploymentSpec的ChaincodeInvocationSpec, 调用的是LSCC的deploy请求.</li>
<li>应用程序发送Peer节点的请求同样会用Channel关联的用户进行签名, 通过Peer实例的ProcessTransactionProposal提交生成的SignedProposal.</li>
<li>每次给Peer节点发送SignedProposal时, 都会新建一个gRPC的连接, 通过ProcessProposal接口提交请求.</li>
<li>Peer节点通过SignedProposal进行验证以后, 会调用LSCC执行链码部署的操作.</li>
<li>Peer节点返回的只是背书节点模拟执行和背书签名的结果, 还要提交给Orderer节点生成最终的区块才能生效, 调用的过程与Peer节点接入通道的过程一样.</li>
<li>生成的新区块会通过主节点分发给组织内的其他Peer节点.</li>
</ol>


<div class="figure">
<p><img src="./65.png" alt="65.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4eb017" class="outline-3">
<h3 id="orgc4eb017">发起交易请求并生成区块</h3>
<div class="outline-text-3" id="text-orgc4eb017">
<p>
其实, 实例化链码的过程, 也是一种交易, 所以发起交易请求其实和实例化链码很相似.
</p>

<p>
不同之处在于:
</p>
<ol class="org-ol">
<li>普通的交易请求调用链码的Invoke接口, 实例化链码调用的是Init接口.</li>
<li>普通的交易请求是不嵌套的ChaincodeInvocationSpec请求, 包含通道的名称和调用链码的函数和参数等.</li>
<li>实例化链码的时候才开始构建链码镜像并启动链码容器, 所以速度较慢; 调用链码的背书节点已经启动了链码容器, 所以调用链码的速度较快.</li>
</ol>


<div class="figure">
<p><img src="./66.png" alt="66.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5f0d040" class="outline-3">
<h3 id="org5f0d040">链码的开发和调试</h3>
<div class="outline-text-3" id="text-org5f0d040">
<p>
链码的SDK是shim, 链码是通过SDK和背书节点通信的, 链码的SDK只要实现接口的定义就能和背书节点交互.
</p>

<p>
shim提供给链码的接口主要有:
</p>
<ol class="org-ol">
<li>链码调用参数解析</li>
<li>交易信息解析</li>
<li>状态数据库操作</li>
<li>链码调用</li>
<li>事件处理</li>
<li>辅助操作</li>
</ol>
</div>

<div id="outline-container-org662bdd2" class="outline-4">
<h4 id="org662bdd2">链码调用参数解析</h4>
<div class="outline-text-4" id="text-org662bdd2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GetArgs() byte</td>
<td class="org-left">返回调用函数名称和参数的列表, 类型是字节数组</td>
</tr>

<tr>
<td class="org-left">GetStringArgs() []string</td>
<td class="org-left">返回调用函数名称和参数的列表, 类型是字符串</td>
</tr>

<tr>
<td class="org-left">GetFunctionAndParameters() (string, []string)</td>
<td class="org-left">返回调用的函数名称和参数, 类型是字符串</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2f53b54" class="outline-4">
<h4 id="org2f53b54">交易信息解析</h4>
<div class="outline-text-4" id="text-org2f53b54">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GetTxID() string</td>
<td class="org-left">获取交易号</td>
</tr>

<tr>
<td class="org-left">GetCreator() ([]byte, error)</td>
<td class="org-left">获取提交交易的身份信息(MSP, 证书)</td>
</tr>

<tr>
<td class="org-left">GetTransient() (map[string][]byte, error)</td>
<td class="org-left">获取私密信息, 这部分信息不会写入账本数据</td>
</tr>

<tr>
<td class="org-left">GetBinding() ([]byte, error)</td>
<td class="org-left">获取交易的绑定信息, 包含随机数和提交交易的身份信息等</td>
</tr>

<tr>
<td class="org-left">GetSignedProposal() (*pb.SignedProposal, error)</td>
<td class="org-left">获取签名的Proposal, 签名者是和提交交易的身份一样的</td>
</tr>

<tr>
<td class="org-left">GetTxTimestamp() (*timestamp.Timestamp, error)</td>
<td class="org-left">获取提交交易的时间戳</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org5b5b4c5" class="outline-4">
<h4 id="org5b5b4c5">状态数据操作</h4>
<div class="outline-text-4" id="text-org5b5b4c5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">GetState(key string)([]byte, error)</td>
<td class="org-left">根据指定键查询状态数据库里存储的值</td>
</tr>

<tr>
<td class="org-left">PutState(key string, value []byte)error</td>
<td class="org-left">向状态数据库写入链值对(模拟写入)</td>
</tr>

<tr>
<td class="org-left">DelState(key string) error</td>
<td class="org-left">删除状态数据库里键对应的值(模拟删除, 记账时才删)</td>
</tr>

<tr>
<td class="org-left">GetHistoryForKey(key string) (HistoryQueryIterator Interface, error)</td>
<td class="org-left">查询一个键的历史数据</td>
</tr>

<tr>
<td class="org-left">GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error)</td>
<td class="org-left">查询状态数据库里链在[startKey, endKey)之间的值</td>
</tr>

<tr>
<td class="org-left">CreateCompositeKey(objectType string, attributes []string)(string, error)</td>
<td class="org-left">构造组合键</td>
</tr>

<tr>
<td class="org-left">SplitCompositeKey(compositeKey string)(string, []string, error)</td>
<td class="org-left">分割组合键</td>
</tr>

<tr>
<td class="org-left">GetStateByPartialCompositeKey(objectType string, keys []string)(StateQueryIteratorInterface, error)</td>
<td class="org-left">部分组合键查询</td>
</tr>

<tr>
<td class="org-left">GetQueryResult(query string)(StateQueryIteratorInterface, error)</td>
<td class="org-left">根据指定条件查询状态数据库里存储的值</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4e3434e" class="outline-4">
<h4 id="org4e3434e">链码调用</h4>
<div class="outline-text-4" id="text-org4e3434e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">InvokeChaincode(chaincodeName string, args byte, channel string) pb.Response</td>
<td class="org-left">根据指定条件查询状态数据库里存储的值</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org682487d" class="outline-4">
<h4 id="org682487d">事件处理</h4>
<div class="outline-text-4" id="text-org682487d">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">接口名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SetEvent(name string, payload []byte) error</td>
<td class="org-left">设置事件的名称和内容</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-04-15</span>
        <span title="last modification date" class="post-info">2018-04-17</span>
        <span title="tags" class="post-info"><a href="/tags/blockchain/">BlockChain</a></span>
        <span title="author" class="post-info">Pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/04/15/九-sdk";
          var disqus_url = "http://pinvondev.github.io/blog/2018/04/15/九-sdk";
          var disqus_shortname = 'pinvon';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <div class="footer">
        <p>Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.3.50.2 (<a href="http://orgmode.org">Org</a> mode 9.1.5)</p>
        <p>
          Copyright &copy; 2012 - 2013 <a href="mailto:pinvon &lt;at&gt; Inspiron">Pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
        </p>
      </div>
    </div>
  </body>
</html>
