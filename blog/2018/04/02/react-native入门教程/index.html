<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>React-Native入门教程 - Pinvon&#39;s Blog</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pinvon" />
    <meta name="description" content="&lt;TODO: insert your description here&gt;" />
    <meta name="keywords" content="&lt;TODO: insert your keywords here&gt;" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Pinvon&#39;s Blog</a></h1>
        <p>所见，所闻，所思，所想</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/pinvondev">GitHub</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="q" value="site:pinvondev.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>React-Native入门教程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2a067b7">props(属性)</a></li>
<li><a href="#org8862b8a">state(状态)</a></li>
<li><a href="#orgc1963d9">style(样式)</a></li>
<li><a href="#orgcebb074">高度与宽度</a>
<ul>
<li><a href="#org6f39277">指定宽高</a></li>
<li><a href="#org7717238">弹性宽高(flex)</a></li>
</ul>
</li>
<li><a href="#org1301a23">使用Flexbox布局</a>
<ul>
<li><a href="#org08e52f3">flexDirection</a></li>
<li><a href="#org25ad702">justifyContent</a></li>
<li><a href="#org3196cea">alignItems</a></li>
</ul>
</li>
<li><a href="#orga4b698f">处理文本输入</a></li>
<li><a href="#org134c642">(ScrollView)滚动视图</a></li>
<li><a href="#orgce1fd3b">长列表</a>
<ul>
<li><a href="#org1e2c768">FlatList</a></li>
<li><a href="#org2a7275c">SectionList</a></li>
</ul>
</li>
<li><a href="#org68bfe5d">网络</a>
<ul>
<li><a href="#org04a0e2d">fetch</a>
<ul>
<li><a href="#orgb3a3c55">发起网络请求</a></li>
</ul>
</li>
<li><a href="#org30f31b6">处理服务器的响应数据</a></li>
<li><a href="#orgd66297e">AJAX</a></li>
<li><a href="#orgb9296a9">WebSocket</a></li>
</ul>
</li>
<li><a href="#org356eccd">Navigation</a>
<ul>
<li><a href="#orgf592e8b">安装</a></li>
<li><a href="#orgd079fc4">创建两个页面</a></li>
</ul>
</li>
<li><a href="#org2a662ca">集成到现有原生应用</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2a067b7" class="outline-2">
<h2 id="org2a067b7">props(属性)</h2>
<div class="outline-text-2" id="text-org2a067b7">
<p>
大部分组件在创建的时候, 就可以使用各种参数来进行定制. 这些参数就称为 <code>props</code>.
</p>

<p>
例如, 在创建图片时:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { Image } from 'react-native';

export default class Bananas extends Component {
  render() {
    let pic = {
      uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'
    };
    return (
      &lt;Image source={pic} style={{width: 193, height: 110}} /&gt;
    );
  }
}
</pre>
</div>
<p>
这边, 使用名为 <code>source</code> 的props来指定图片的地址, 使用名为 <code>style</code> 的props来控制尺寸.
</p>
</div>
</div>

<div id="outline-container-org8862b8a" class="outline-2">
<h2 id="org8862b8a">state(状态)</h2>
<div class="outline-text-2" id="text-org8862b8a">
<p>
<code>props</code> 一旦被指定, 在该组件的生命周期中就不再改变. 如果有组件继续了该组件, 则可以在子组件中使用 <code>state</code> 来改变.
</p>

<p>
一般做法: 子组件在 <code>constructor()</code> 中初始化 <code>state</code>, 在需要修改时使用 <code>setState()</code>.
</p>

<p>
如: 要制作一段闪烁的文字. 文字内容在组件创建时被指定, 所以文字内容应该是一个 <code>prop</code>, 而文字的显示或隐藏状态(快速显隐切换可产生闪烁效果)是随时间变化的, 因此这个状态应该写到 <code>state</code> 中.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { Text, View } from 'react-native';
class Blink extends Component {
    constructor(props) {
        super(props);
        this.state = { showText: true };

        // 每1s对showText状态取反
        setInterval(() =&gt; {
            this.setState(previousState =&gt; {
                return { showText: !previousState.showText };
            });
        }, 1000);
    }
    render () {
        // 根据showText的值来决定是否显示text内容
        let display = this.state.showText ? this.props.text : ' ';
        return (
                &lt;Text&gt;{display}&lt;/Text&gt;
        );
    }
}
export default class BlinkApp extends Component {
  render() {
    return (
      &lt;View&gt;
        &lt;Blink text='I love to blink' /&gt;
        &lt;Blink text='Yes blinking is so great' /&gt;
        &lt;Blink text='Why did they ever take this out of HTML' /&gt;
        &lt;Blink text='Look at me look at me look at me' /&gt;
      &lt;/View&gt;
    );
  }
}
</pre>
</div>

<p>
这只是示例. <code>state</code> 使用的典型场景是在接收到服务器返回的新数据, 或在用户输入数据之后.
</p>
</div>
</div>

<div id="outline-container-orgc1963d9" class="outline-2">
<h2 id="orgc1963d9">style(样式)</h2>
<div class="outline-text-2" id="text-orgc1963d9">
<p>
所有核心组件都接受名为 <code>style</code> 的属性.
</p>

<p>
在实际开发的时候, 样式会很复杂. 建议使用 <code>StyleSheet.create</code> 来集中定义组件的样式. 如:
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, StyleSheet, Text, View } from 'react-native';

export default class LotsOfStyles extends Component {
  render() {
    return (
      &lt;View&gt;
        &lt;Text style={styles.red}&gt;just red&lt;/Text&gt;
        &lt;Text style={styles.bigblue}&gt;just bigblue&lt;/Text&gt;
        &lt;Text style={[styles.bigblue, styles.red]}&gt;bigblue, then red&lt;/Text&gt;
        &lt;Text style={[styles.red, styles.bigblue]}&gt;red, then bigblue&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  bigblue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
  red: {
    color: 'red',
  },
});

AppRegistry.registerComponent('LotsOfStyles', () =&gt; LotsOfStyles);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcebb074" class="outline-2">
<h2 id="orgcebb074">高度与宽度</h2>
<div class="outline-text-2" id="text-orgcebb074">
</div>
<div id="outline-container-org6f39277" class="outline-3">
<h3 id="org6f39277">指定宽高</h3>
<div class="outline-text-3" id="text-org6f39277">
<p>
组件的高度与宽度决定了它在屏幕上显示的尺寸. 给组件设定尺寸的方式是在样式中指定 <code>width</code> 和 <code>height</code>. React Native中尺寸没有单位, 表示的是与设备像素密度无关的逻辑像素点.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FixedDimensionsBasics extends Component {
  render() {
    return (
      &lt;View&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
        &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt;
        &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} /&gt;
      &lt;/View&gt;
    );
  }
};
// 注册应用(registerComponent)后才能正确渲染
// 注意：只把应用作为一个整体注册一次，而不是每个组件/模块都注册
AppRegistry.registerComponent('AwesomeProject', () =&gt; FixedDimensionsBasics);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7717238" class="outline-3">
<h3 id="org7717238">弹性宽高(flex)</h3>
<div class="outline-text-3" id="text-org7717238">
<p>
<code>flex</code> 表示在可利用的空间中动态扩张或收缩. 一般会使用 <code>flex:1</code> 来指定某个组件扩张以撑满所有剩余的空间.
</p>

<p>
如果有多个并列的子组件使用了 <code>flex:1</code>, 则这些子组件会平分父容器中的剩余空间.
</p>

<p>
组件能撑满剩余空间的前提是其父容器的尺寸不为0. 如果父容器既没有固定的 <code>width</code> 和 <code>height</code>, 也没有设定 <code>flex</code>, 则父容器的尺寸为0. 这样的话, 即使子组件使用了 <code>flex</code> 也不会起效果.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FlexDimensionsBasics extends Component {
  render() {
    return (
      // 试试去掉父View中的`flex: 1`。
      // 则父View不再具有尺寸，因此子组件也无法再撑开。
      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？
      &lt;View style={{flex: 1}}&gt;
        &lt;View style={{flex: 1, backgroundColor: 'powderblue'}} /&gt;
        &lt;View style={{flex: 2, backgroundColor: 'skyblue'}} /&gt;
        &lt;View style={{flex: 3, backgroundColor: 'steelblue'}} /&gt;
      &lt;/View&gt;
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; FlexDimensionsBasics);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1301a23" class="outline-2">
<h2 id="org1301a23">使用Flexbox布局</h2>
<div class="outline-text-2" id="text-org1301a23">
<p>
在React Native中, 使用flexbox规则来指定某个组件的子元素的布局. flexbox可以在不同屏幕尺寸上提供一致的布局结构.
</p>
</div>

<div id="outline-container-org08e52f3" class="outline-3">
<h3 id="org08e52f3">flexDirection</h3>
<div class="outline-text-3" id="text-org08e52f3">
<p>
在组件的 <code>style</code> 中指定 <code>flexDirection</code> 可以决定布局的主轴. 子元素可以沿着水平排列(row), 也可以垂直排列(column), 默认为column.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class FlexDirectionBasics extends Component {
  render() {
    return (
      // 尝试把`flexDirection`改为`column`看看
      &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;
      &lt;/View&gt;
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; FlexDirectionBasics);
</pre>
</div>
</div>
</div>

<div id="outline-container-org25ad702" class="outline-3">
<h3 id="org25ad702">justifyContent</h3>
<div class="outline-text-3" id="text-org25ad702">
<p>
在组件中的 <code>style</code> 中指定 <code>justifyContent</code> 可以决定子元素沿着主轴的排列方式. 如, 左对齐, 右对齐, 还是居中, 等等, 都是由它来指定.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class JustifyContentBasics extends Component {
  render() {
    return (
      // 尝试把`justifyContent`改为`center`看看
      // 尝试把`flexDirection`改为`row`看看
      &lt;View style={{
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'space-between',
      }}&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;
      &lt;/View&gt;
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; JustifyContentBasics);
</pre>
</div>
</div>
</div>

<div id="outline-container-org3196cea" class="outline-3">
<h3 id="org3196cea">alignItems</h3>
<div class="outline-text-3" id="text-org3196cea">
<p>
在组件的 <code>style</code> 中指定 <code>alignItems</code> 可以决定其子元素沿着次轴的排列方式.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, View } from 'react-native';

class AlignItemsBasics extends Component {
  render() {
    return (
      // 尝试把`alignItems`改为`flex-start`看看
      // 尝试把`justifyContent`改为`flex-end`看看
      // 尝试把`flexDirection`改为`row`看看
      &lt;View style={{
        flex: 1,
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
      }}&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;
        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;
      &lt;/View&gt;
    );
  }
};

AppRegistry.registerComponent('AwesomeProject', () =&gt; AlignItemsBasics);
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga4b698f" class="outline-2">
<h2 id="orga4b698f">处理文本输入</h2>
<div class="outline-text-2" id="text-orga4b698f">
<p>
<code>TextInput</code> 是一个允许用户输入文本的基础组件. 它有一个名为 <code>onChangeText</code> 属性, 此属性接受一个函数, 而此函数会在文本变化时被调用; 有一个名为 <code>onSubmitEditing</code> 的属性, 在文件被提交后被调用.
</p>

<p>
把输入的单词转换成🍕:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { AppRegistry, Text, TextInput, View } from 'react-native';

export default class PizzaTranslator extends Component {
  constructor(props) {
    super(props);
    this.state = {text: ''};
  }

  render() {
    return (
      &lt;View style={{padding: 10}}&gt;
        &lt;TextInput
          style={{height: 40}}
          placeholder="Type here to translate!"
          onChangeText={(text) =&gt; this.setState({text})}
        /&gt;
        &lt;Text style={{padding: 10, fontSize: 42}}&gt;
          {this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '🍕').join(' ')}
        &lt;/Text&gt;
      &lt;/View&gt;
    );
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org134c642" class="outline-2">
<h2 id="org134c642">(ScrollView)滚动视图</h2>
<div class="outline-text-2" id="text-org134c642">
<p>
<code>ScrollView</code> 是一个通用的可滚动的容器, 可以在其中放入多个组件和视图, 而且这些组件并不需要是同类型的. <code>ScrollView</code> 可以水平或者垂直滚动.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import{ ScrollView, Image, Text, View } from 'react-native'

export default class IScrolledDownAndWhatHappenedNextShockedMe extends Component {
  render() {
      return(
        &lt;ScrollView&gt;
          &lt;Text style={{fontSize:96}}&gt;Scroll me plz&lt;/Text&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Text style={{fontSize:96}}&gt;If you like&lt;/Text&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Text style={{fontSize:96}}&gt;Scrolling down&lt;/Text&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Text style={{fontSize:96}}&gt;What's the best&lt;/Text&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Text style={{fontSize:96}}&gt;Framework around?&lt;/Text&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Image source={require('./img/favicon.png')} /&gt;
          &lt;Text style={{fontSize:80}}&gt;React Native&lt;/Text&gt;
        &lt;/ScrollView&gt;
    );
  }
}
</pre>
</div>

<p>
<code>ScrollView</code> 会将内部所有组件都渲染. 如果如果要显示较长的滚动列表, 应该使用功能差不多, 但性能更好的长列表.
</p>
</div>
</div>

<div id="outline-container-orgce1fd3b" class="outline-2">
<h2 id="orgce1fd3b">长列表</h2>
<div class="outline-text-2" id="text-orgce1fd3b">
<p>
React Native中有几个长列表, 一般使用 <code>FlatList</code> 或 <code>SectionList</code>.
</p>
</div>

<div id="outline-container-org1e2c768" class="outline-3">
<h3 id="org1e2c768">FlatList</h3>
<div class="outline-text-3" id="text-org1e2c768">
<p>
用于显示一个垂直的滚动列表, 内部元素格式相同, 元素个数可增删. 它优先渲染屏幕上可见的元素.
</p>

<p>
<code>FlatList</code> 有两个必须的属性: <code>data</code> 和 <code>renderItem</code>. <code>data</code> 是列表的数据源, <code>renderItem</code> 则从数据源中逐个解析数据, 然后返回一个设定好格式的组件来渲染.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { FlatList, StyleSheet, Text, View } from 'react-native';

export default class FlatListBasics extends Component {
  render() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;FlatList
          data={[
            {key: 'Devin'},
            {key: 'Jackson'},
            {key: 'James'},
            {key: 'Joel'},
            {key: 'John'},
            {key: 'Jillian'},
            {key: 'Jimmy'},
            {key: 'Julie'},
          ]}
          renderItem={({item}) =&gt; &lt;Text style={styles.item}&gt;{item.key}&lt;/Text&gt;}
        /&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
   flex: 1,
   paddingTop: 22
  },
  item: {
    padding: 10,
    fontSize: 18,
    height: 44,
  },
})
</pre>
</div>
</div>
</div>

<div id="outline-container-org2a7275c" class="outline-3">
<h3 id="org2a7275c">SectionList</h3>
<div class="outline-text-3" id="text-org2a7275c">
<p>
适用于渲染一组需要分组的数据, 也许还带有分组标签.
</p>

<div class="org-src-container">
<pre class="src src-JavaScript">import React, { Component } from 'react';
import { SectionList, StyleSheet, Text, View } from 'react-native';

export default class SectionListBasics extends Component {
  render() {
    return (
      &lt;View style={styles.container}&gt;
        &lt;SectionList
          sections={[
            {title: 'D', data: ['Devin']},
            {title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']},
          ]}
          renderItem={({item}) =&gt; &lt;Text style={styles.item}&gt;{item}&lt;/Text&gt;}
          renderSectionHeader={({section}) =&gt; &lt;Text style={styles.sectionHeader}&gt;{section.title}&lt;/Text&gt;}
        /&gt;
      &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
   flex: 1,
   paddingTop: 22
  },
  sectionHeader: {
    paddingTop: 2,
    paddingLeft: 10,
    paddingRight: 10,
    paddingBottom: 2,
    fontSize: 14,
    fontWeight: 'bold',
    backgroundColor: 'rgba(247,247,247,1.0)',
  },
  item: {
    padding: 10,
    fontSize: 18,
    height: 44,
  },
})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org68bfe5d" class="outline-2">
<h2 id="org68bfe5d">网络</h2>
<div class="outline-text-2" id="text-org68bfe5d">
<p>
一般移动应用都要从Server中获取数据. 我们可能要给某个REST API发起POST请求, 以提交用户数据; 也可能从Server上获取一些数据.
</p>
</div>

<div id="outline-container-org04a0e2d" class="outline-3">
<h3 id="org04a0e2d">fetch</h3>
<div class="outline-text-3" id="text-org04a0e2d">
<p>
如果学过 <code>XMLHttpRequest(ajax)</code>, 则 <code>fetch</code> 用起来比较容易上手.
</p>
</div>

<div id="outline-container-orgb3a3c55" class="outline-4">
<h4 id="orgb3a3c55">发起网络请求</h4>
<div class="outline-text-4" id="text-orgb3a3c55">
<p>
从指定地址获取内容:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">fetch('https://mywebsite.com/mydata.json')
</pre>
</div>

<p>
<code>fetch()</code> 还有可选的第二个参数, 用来定制HTTP请求一些参数. 如:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">fetch('https://mywebsite.com/endpoint/', {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    firstParam: 'yourValue',
    secondParam: 'yourOtherValue',
  })
})
</pre>
</div>
<p>
提交数据的格式取决于 <code>headers</code> 中的 <code>Content-Type</code>. <code>Content-Type</code> 有多种, 对应的 <code>body</code> 的格式也有多种. 使用哪种, 协商清楚就好. 比如用网页表示的形式传递:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">fetch('https://mywebsite.com/endpoint/', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  body: 'key1=value1&amp;key2=value2'
})
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org30f31b6" class="outline-3">
<h3 id="org30f31b6">处理服务器的响应数据</h3>
<div class="outline-text-3" id="text-org30f31b6">
<div class="org-src-container">
<pre class="src src-JavaScript">getMoviesFromApiAsync() {
    return fetch('https://facebook.github.io/react-native/movies.json')
      .then((response) =&gt; response.json())
      .then((responseJson) =&gt; {
        return responseJson.movies;
      })
      .catch((error) =&gt; {
        console.error(error);
      });
  }
</pre>
</div>

<p>
还可以使用ES7标准中的 <code>async/await</code> 语法:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">// 注意这个方法前面有async关键字
  async getMoviesFromApi() {
    try {
      // 注意这里的await语句，其所在的函数必须有async关键字声明
      let response = await fetch('https://facebook.github.io/react-native/movies.json');
      let responseJson = await response.json();
      return responseJson.movies;
    } catch(error) {
      console.error(error);
    }
  }
</pre>
</div>

<p>
默认情况下, iOS会阻止所有非https请求. 如果非要使用http协议, 参考文档<a href="https://segmentfault.com/a/1190000002933776">https://segmentfault.com/a/1190000002933776</a>.
</p>
</div>
</div>

<div id="outline-container-orgd66297e" class="outline-3">
<h3 id="orgd66297e">AJAX</h3>
<div class="outline-text-3" id="text-orgd66297e">
<p>
此处不介绍.
</p>
</div>
</div>

<div id="outline-container-orgb9296a9" class="outline-3">
<h3 id="orgb9296a9">WebSocket</h3>
<div class="outline-text-3" id="text-orgb9296a9">
<p>
React Native还支持 <code>WebSocket</code>.
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">var ws = new WebSocket('ws://host.com/path');

ws.onopen = () =&gt; {
  // 打开一个连接

  ws.send('something'); // 发送一个消息
};

ws.onmessage = (e) =&gt; {
  // 接收到了一个消息
  console.log(e.data);
};

ws.onerror = (e) =&gt; {
  // 发生了一个错误
  console.log(e.message);
};

ws.onclose = (e) =&gt; {
  // 连接被关闭了
  console.log(e.code, e.reason);
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org356eccd" class="outline-2">
<h2 id="org356eccd">Navigation</h2>
<div class="outline-text-2" id="text-org356eccd">
<p>
React Native中有多种导航组件, 社区主推 <code>react-navigation</code>.
</p>
</div>

<div id="outline-container-orgf592e8b" class="outline-3">
<h3 id="orgf592e8b">安装</h3>
<div class="outline-text-3" id="text-orgf592e8b">
<div class="org-src-container">
<pre class="src src-Shell">yarn add react-navigation
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd079fc4" class="outline-3">
<h3 id="orgd079fc4">创建两个页面</h3>
<div class="outline-text-3" id="text-orgd079fc4">
<p>
创建有两个页面(Main和Profile)的应用:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">import {
  StackNavigator,
} from 'react-navigation';

const App = StackNavigator({
  Main: {screen: MainScreen},
  Profile: {screen: ProfileScreen},
});
</pre>
</div>

<p>
其中, 每个 <code>screen</code> 组件都可以单独设置导航选项, 如导航头的标题, 页面的跳转等:
</p>
<div class="org-src-container">
<pre class="src src-JavaScript">class MainScreen extends React.Component {
  static navigationOptions = {
    title: 'Welcome',
  };
  render() {
    const { navigate } = this.props.navigation;
    return (
      &lt;Button
        title="Go to Jane's profile"
        onPress={() =&gt;
          navigate('Profile', { name: 'Jane' });
        }
      /&gt;
    );
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2a662ca" class="outline-2">
<h2 id="org2a662ca">集成到现有原生应用</h2>
<div class="outline-text-2" id="text-org2a662ca">
<p>
在原生应用程序的基础上, 加上React Native写的内容. 值得学习.
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2018-04-02</span>
        <span title="last modification date" class="post-info">2018-04-02</span>
        <span title="tags" class="post-info"><a href="/tags/reactnative/">ReactNative</a></span>
        <span title="author" class="post-info">Pinvon</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/2018/04/02/react-native入门教程";
          var disqus_url = "http://pinvondev.github.io/blog/2018/04/02/react-native入门教程";
          var disqus_shortname = 'pinvon';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      </section>
      <div class="footer">
        <p>Generated by <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.3.50.2 (<a href="http://orgmode.org">Org</a> mode 9.1.5)</p>
        <p>
          Copyright &copy; 2012 - 2013 <a href="mailto:pinvon &lt;at&gt; Inspiron">Pinvon</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
        </p>
      </div>
    </div>
  </body>
</html>
