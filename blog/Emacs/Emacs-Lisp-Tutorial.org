#+TITLE:       Emacs Lisp 教程
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-01-15 一
#+URI:         /blog/%y/%m/%d/emacs-lisp-教程
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        Emacs
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 声明

学习自[[http://smacs.github.io/elisp/][happierbee]]写的教程.

* 执行程序

在*scratch*中, 写完一行代码后, 在代码最后面键入C-j, 或者C-x C-e.

* 基础知识

** 函数和变量

*** 函数
函数的例子:
#+BEGIN_SRC Elisp
(defun hello-world (name)
  "say hello to user whose name is NAME."
  (message "Hello, %s" name))

;; 调用
(hello-world "Emacser")
#+END_SRC
函数的返回值是函数里的最后一个表达式.

*** 全局变量
由于Elisp中函数是全局的, 所以变量也很容易成为全局变量.

**** setq
#+BEGIN_SRC Elisp
(setq foo "I am Emacser") ;; "I am Emacser"
(message foo) ;; "I am Emacser"
#+END_SRC

**** defvar
defvar也可以定义变量, 但是如果定义的变量在之前有赋过值, 则不起作用. 另外, defvar可以为变量提供文档字符串, 即可以使用C-h v来查看变量的说明.
#+BEGIN_SRC Elisp
(defvar variable-name value
	"document string")

;; 例子
(defvar foo "Did I have a value"
  "A demo variable")
(message foo) ;; "I am Emacser", 因为之前已经用setq对foo赋过值

(defvar bar "I am bar"
  "A demo variable name")
(message bar) ;; "I am bar", 由于之前没有对bar赋值, 因此本次生效
#+END_SRC

*** 局部变量
Elisp中使用 =let= 或 =let*= 来对局部变量进行绑定.
#+BEGIN_SRC Elisp
(defun circle-area (radix)
  (let ((pi 3.1415926)
        area)
    (setq area (* pi radix radix))
    (message "直径为 %.2f 的圆面积是 %.2f" radix area)))
(circle-area 3)
;; 或者
(defun circle-area (radix)
  (let* ((pi 3.1415926)
         (area (* pi radix radix)))
    (message "直径为 %.2f 的圆面积是 %.2f" radix area)))
#+END_SRC
let*和let的使用形式完全相同, 区别在于let*在声明中就能使用前面声明的变量.

*** lambda表达式
#+BEGIN_SRC Elisp
(lambda (arguments-list)
	"documentation string"
	body)
;; 调用
(funcall (lambda (name)
	(message "Hello %s" name)) "Emacser")
#+END_SRC
也可以把lambda表达式赋值给一个变量, 再用funcall来调用:
#+BEGIN_SRC Elisp
(setq foo (lambda (name)
	(message "Hello %s" name)))
(funcall foo "Emacser")
#+END_SRC

** 控制结构

*** 顺序执行
使用progn.

*** 条件判断
#+BEGIN_SRC Elisp
(if condition true_body false_body)
#+END_SRC

还有一个条件判断的方法, 有点像C中的switch-case, 结构如下:
#+BEGIN_SRC Elisp
(cond (case1 body)
	(case2 body)
	...
	(t body)) ;; 前面的情况都不符合时, 执行这条语句

;; 例子
(defun fib (n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (fib (- n 1)) (fib (- n 2))))))
(fib 10) ;; returns 55
#+END_SRC

*** 循环
#+BEGIN_SRC Elisp
(while condition body)
#+END_SRC

** 逻辑运算
and和or具有短路性质, or常用于设置函数的默认参数, and用于参数检查. 如:
#+BEGIN_SRC Elisp
(defun hello-world (&optional name)
  (or name (setq name "Emacser"))
  (message "Hello %s" name))
(hello-world) ;; "Hello Emacser"
(hello-world "Vim") ;; "Hello Vim"
#+END_SRC

#+BEGIN_SRC Elisp
(defun square-number-p (n)
  (and (>= n 0) (= (/ n (sqrt n)) (sqrt n)))) ;; (n >= 0) && (n/sqrt(n))  == (sqrt(n))
(square-number-p -1) ;; nil
(square-number-p 25) ;; t
#+END_SRC

* 数字

emacs的数字分为整数和浮点数.

** 测试函数
是否为整数类型: integerp
是否为浮点数类型: floatp
是否为数字类型: numberp
是否为0: zerop
是否为非负整数: wholenump

** 数的比较
由于Elisp中的赋值是setq函数, 所以=就是比较两个数字是否相等. 还有一些跟比较有关的操作符: >, <, >=, <=

由于精度的原因, 如果比较两个浮点数, 一般结果都是不相等, 正确的比较, 应该在一定的误差内进行比较.

eql可以比较两个数字的值和类型是否都一致.

注意, 不等号是/=.

** 数的转换

整数->浮点数: float
浮点数->整数: 向上取整(ceiling), 向下取整(floor), 四舍五入(round)

** 数的运算
与其他语言类似.
没有++和--, 可以这样写: (setq foo (1+ foo))和(setq foo (1- foo))
取余: %或mod函数, %要求第1个参数为整数, 而mod则没有这个要求
绝对值: abs
三角函数: sin, cos, tan, asin, acos, atan
开方: sqrt
指数: exp是以e为底的指数运算, expt可以自己指定底数
对数: log, 底数默认为e, 也可以自己指定 (log arg &optional base)
随机数: random, (random t)可以产生新种子

* 字符和字符串
Elisp中的字符串是有序的字符数组, 和C不同的是, Elisp中的字符串可以容纳任何字符, 包括\0.

** 字符
字符的读入语法, 是在字符前加问号:
#+BEGIN_SRC Elisp
?A ;; 65
?\a ;; 转义字符, 7
?\C-i ;; 表示键入的Ctrl-i, 9
?\M-A ;; 表示键入的Alt-A
#+END_SRC

** 测试函数
是否为字符串: stringp; 没有charp, 因为字符就是整数.
string-or-null-p: 对象是一个字符或nil时, 返回t
char-or-string-p: 对象是否为字符串或字符

Elisp没有测试字符串是否为空的函数, 需要自定义:
#+BEGIN_SRC Elisp
(defun string-emptyp (str)
	(not (string< "" str)))
#+END_SRC

** 构造函数
#+BEGIN_SRC Elisp
(make-string 5 ?x) ;; "xxxxx"
(string ?a ?b ?c) ;; "abc"
(substring "0123456789" 3 5) ;; "34"
(concat "0" "1") ;; "01"
#+END_SRC

** 字符串比较
char-equal: 比较两个字符是否相等. 通常case-fold-search都是t, 表示忽略大小写
string=: 字符串比较; string-equal是别名
string<: 按字典序比较, string-less是别名
空字符串小于所有字符串, length可以检测字符串长度, 所以也可以用length来判断字符串是否为空.

** 转换函数
string-to-char: 只返回字符串的第一个字符
char-to-string: 字符转字符串
string-to-number
number-to-string: 只能转10进制的数字, 若要输出其他进制, 可以用format函数, (format "%#o" 256)
concat: 可以把一个字符构成的列表或向量转成字符串
vconcat: 可以把字符串转成列表
downcase/upcase: 大小写转换
capitalize: 第1个字符大写, 其他小写
upcase-initials: 第1个字符大写, 其他不管

** 查找和替换
(string-match regexp string &optional start): 从指定位置对字符串进行正则表达式匹配.

有时需要对正则表达式进行处理:
#+BEGIN_SRC Elisp
(string-match "2*" "232*3=696")  ;; 0
(string-match (regexp-quote "2*") "232*3=696")  ;;  2
#+END_SRC

(replace-match newtext &optional fixedcase literal string subexp): 替换函数
如: (replace-match "x" nil nil str 0)
