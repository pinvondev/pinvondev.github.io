#+TITLE:       回溯算法
#+AUTHOR:      pinvon
#+EMAIL:       pinvon@t480
#+DATE:        2018-09-26 三

#+URI:         /blog/Algorithm/backtracking.org/%y/%m/%d/%t/ Or /blog/Algorithm/backtracking.org/%t/
#+TAGS:        Algorithms
#+DESCRIPTION: <Add description here>

#+LANGUAGE:    en
#+OPTIONS:     H:4 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 回溯算法

[[https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html][转载链接]]

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

** 基本思想

在包含问题的所有解的解空间树中，按照 =深度优先搜索= 的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

** 一般步骤

1. 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

2. 确定结点的扩展搜索规则

3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

** 算法框架

*** 非递归回溯框架

#+BEGIN_SRC C++
int a[n],i;
初始化数组a[];
i = 1;
while (i>0(有路可走) && (未达到目标))        // 还未回溯到头
    if(i > n)                                // 搜索到叶结点
        搜索到一个解，输出；
    else                                     // 处理第i个元素
        a[i]第一个可能的值；
        while(a[i]在不满足约束条件且在搜索空间内) 
            a[i]下一个可能的值；
        if(a[i]在搜索空间内) 
            标识占用的资源；
            i = i+1;                         // 扩展下一个结点
        else 
            清理所占的状态空间；             // 回溯
            i = i –1; 
#+END_SRC

*** 递归的算法框架

#+BEGIN_SRC C++
int a[n];
try(int i) 
    if(i>n) 
        输出结果;
    else 
        for(j = 下界; j <= 上界; j=j+1)     // 枚举i所有可能的路径
            if(fun(j))                      // 满足限界函数和约束条件
                a[i] = j;
                ...                         // 其他操作
                try(i+1);
                回溯前的清理工作（如a[i]置空值等）;
#+END_SRC
