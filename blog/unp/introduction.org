#+TITLE:       简介
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-01-05 五
#+URI:         /blog/%y/%m/%d/简介
#+KEYWORDS:    <TODO: insert your keywords here>
#+TAGS:        Unix网络编程-读书笔记
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: <TODO: insert your description here>

* 简单的时间/日期客户程序

** 创建TCP套接口
#+BEGIN_SRC C++
if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        err_sys("socket error");
}
#+END_SRC

socket()创建网际(AF_INET)字节流(SOCK_STREAM)套接口, 并返回一个整数用来标识该套接口.

** 指定服务器IP地址和端口
#+BEGIN_SRC C++
bzero(&servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons(13);
if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0)
    err_quit("inet_pton error for %s", argv[1]);
#+END_SRC

- bzero()把整个结构清零
- 置地址簇为AF_INET
- htons()把机器上的整数转换成网络字节顺序. 网络字节顺序是大端模式(整数的高位字节放在内存的低地址处)的, 如十进制整数16, 如果是Intel机器(小端模式), 转成16进制就是0x0010, 转换成大端模式, 就变成0x1000. 而如果是IBM的机器, 则使用大端模式进行存储, 不需要进行转换.
- inet_pton()将点分十进制数(第二个参数)转换成二进制数(第三个参数), 第一个参数是地址簇, 有AF_INET和AF_INET6.

*** bzero()与memset()
bzero()原型:
#+BEGIN_SRC C++
extern void bzero(void *s, int n); 
#+END_SRC
功能是把字符串s的前n个字节置为0.

memset()原型:
#+BEGIN_SRC C++
extern void *memset(void *buffer, int c, int count);
#+END_SRC
功能是把buffer所指内存区域的前count个字节置为c, 返回指向buffer的指针.

一般来说, 如果是初始化数据, 会更推荐使用bzero(), 因为memset()的后两个参数类型相同, 容易搞混, 经常导致使用错误.

*** inet_pton()和inet_addr()

inet_pton()可以支持IPv4和IPv6的地址转换, inet_addr()只能支持IPv4.

** 建立与服务器的连接
#+BEGIN_SRC C++
if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) < 0)
    err_sys("connect error");
#+END_SRC
使用sockfd标识的套接口, 与第2个参数所指的地址结构对应的服务器建立连接. 

SA就是struct sockaddr, 通用套接口地址结构.

** 读入并输出服务器的应答
#+BEGIN_SRC C++
while ((n = read(sockfd, recvline, MAXLINE)) > 0) {
    recvline[n] = 0;
    if (fputs(recvline, stdout) == EOF)
        err_sys("fputs error");
}
if (n < 0)
    err_sys("read error");
#+END_SRC
TCP是一种无记录边界的字节流协议, 数据可以有多种返回方式. 一般如果数据量很大, 会把数据拆分成多个分组发送. 因此, 不能确保一次read调用就能把所有数据读取出来, =常常是把read编码在某个循环中, 当read返回0(远程关闭连接)或负值(错误发生)时才终止循环=
