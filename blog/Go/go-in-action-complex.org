#+TITLE:       Go实战(四) 复合数据类型
#+AUTHOR:      Pinvon
#+EMAIL:       pinvon@Inspiron
#+DATE:        2018-04-27 五

#+URI:         /blog/Go/%y/%m/%d/%t/ Or /blog/Go/%t/
#+TAGS:        Go
#+DESCRIPTION: <Add description here>

#+LANGUAGE:    en
#+OPTIONS:     H:4 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 注

学习自: Go 语言圣经

** 概述

数组和结构体有固定内存大小的数据结构; slice 和 map 是动态的数据结构, 会根据需要而动态增长.

* 数组

数组的长度固定, 我们一般不直接使用数组. slice 提供的功能会更多, 但我们要先理解数组, 才能理解 slice 的原理.

数组下标从 0 开始, len() 返回数组元素个数.

** 初始化

默认每个元素都被初始化为元素类型所对应的零值. 也可以自己赋予初始值:
#+BEGIN_SRC Golang
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 3}
fmt.Println(r[2])  // 0
#+END_SRC

可以根据初始化元素的个数来决定数组的长度:
#+BEGIN_SRC Golang
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q)  // [3]int
#+END_SRC

数组长度是数组类型的一部分, 因此下面的赋值是错误的:
#+BEGIN_SRC Golang
q := [3]int{1,2,3}
q = [4]int{1,2,3,4}  // 编译错误
#+END_SRC
另外, 数组长度必须是常量表达式, 因为数组长度在编译期确定.

** 索引和对应的值

我们可以在数组里存放索引-值, 做法如下:
#+BEGIN_SRC Golang
type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
#+END_SRC

如果有索引未使用, 可以直接省略, Go 会使用零值来代替:
#+BEGIN_SRC Golang
r := [...]int{99:-1}
#+END_SRC
从 0 到 98 的索引对应的值都是 0; 索引为 99 对应的值是 -1.

** 数组运算

如果数组元素类型是可比较的, 且两个数组的所有元素都相等, 则这两个数组是相等的.
#+BEGIN_SRC Golang
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
#+END_SRC

** 遍历

#+BEGIN_SRC Golang
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
#+END_SRC

* slice

slice 的语法和数组很像, 但不固定长度.

** slice 的数据结构

slice 的底层引用了一个数组对象.

一个 slice 由三部分构成: 指针, 长度, 容量.
1. 指针: 指向第一个 slice 元素对应的底层数组元素的地址.(注: slice 的第一个元素不一定是数组的第一个元素)
2. 长度: slice 中的元素数目, 不能超过容量, 使用 len() 获得.
3. 容量: 从 slice 的开始位置到底层数据的结尾位置, 使用 cap() 获得.

如下图所示, 多个 slice 之间可以共享底层数据, 并且引用的数组部分区间可以重叠.

[[./7.png]]

从这个图中, 也可以看出, len() 指的是 slice 的长度, cap() 指的是从 slice[0] 开始到底层数组最后一个元素之间的长度.

slice 在初始化时不需要指定长度, 而数组需要指定长度. 但是 slice 的底层数据结构又是数组, 这个背后的原理是什么?

其实, 在初始化 slice 时, 会隐式创建一个合适大小的数组, 然后 slice 的指针指向底层的数组.

** 声明和初始化

- 声明一个未指定大小的数组来定义切片: var name []type

- 使用 make() 创建切片: var slice1 []type = make([]type, len)

- slice1 := make([]type, len)

- 可以初始化的时候就指定容量: slice1 := make([]type, len, cap)

- 利用已有的数组来创建 slice: slice1 := array[m:n]

** 切片

假设 x 是 slice 类型的, 则对 x 进行切片, 可以写成: y := x[m:n].

其中, $0 \leq m \leq n \leq cap(s)$. y 引用 x 从第 m 个元素到第 n-1 个元素之间的数据. 

如果切片操作超过了 cap(x), 则会出现 =panic:out of range= 错误; 如果切片操作超过了 len(x), 则意味着对 x 进行扩展, 此时 y 里面的数据会比 x 还多.

** slice 作为函数参数

因为 slice 的底层数据结构是数组, 且多个 slice 可以共享同一个底层数据结构, 因此, 对 slice 进行复制, 其实只是为底层数组创建了一个新的 slice 别名. 如果在函数内部对 slice 进行了修改, 会影响到函数外部. 如:
#+BEGIN_SRC Golang
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

a := [...]int{0, 1, 2, 3, 4, 5}  // a 是数组, a[:] 是 slice
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
#+END_SRC

** 比较

slice 不能像数组那样, 通过 == 操作符来判断两个 slice 是否含有全部相同的元素. 但有个例外: 如果这个 slice 是 []byte 类型的, 则可以使用 bytes.Equal() 来判断; 对于其他类型, 只能通过遍历每个元素来比较.

#+BEGIN_SRC Golang
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
#+END_SRC

slice 可以和 nil 作比较. slice 类型的零值就是 nil, 此时 slice 没有底层数组, len() 和 cap() 都是 0.

#+BEGIN_EXAMPLE
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
#+END_EXAMPLE
可以看出, 如果要判断一个 slice 是否为空, 应该判断 len() 是否为 0, 而不能将其与 nil 作比较. 因为一个 nil 值的 slice 的行为与其他任意 0 长度的 slice 是一样的.

** append()

append() 用于向 slice 添加新元素. 如:
#+BEGIN_SRC Golang
var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
#+END_SRC

当然, 这一段代码只是用来演示 append() 的用法, 其实际效果与 runes = []rune("Hello, 世界") 一样.

*** append() 原理

假设 appendInt() 就是 []int 类型的 slice 的 append() 操作.

#+BEGIN_SRC Golang
func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen <= cap(x) {
        // There is room to grow.  Extend the slice.
        z = x[:zlen]
    } else {
        // There is insufficient space.  Allocate a new array.
        // Grow by doubling, for amortized linear complexity.
        zcap := zlen
        if zcap < 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
#+END_SRC
通过代码可以看出来, 每次添加新元素到 x 时, 都会先判断 len(x) 是否有足够空间来容纳新元素.

如果足够容纳, 则直接扩展 x, 然后将新元素添加进来, 添加新元素后的 slice 与原来的 slice 共享同一个数组;

如果空间不足, 则创建一个新的 slice, 其 cap() 至少要设置成添加新元素后的长度的两倍. 然后再将所有元素放进新的 slice 中, 添加新元素后的 slice 与原来的 slice 不共享同一数组.

copy() 是 Go 语言内置的函数, 可以将第二个参数复制给第一个参数.

内置的 append() 的实现会更加复杂, 它还可以追加多个元素, 甚至是另一个 slice. 如(注意最后一次追加时, 使用了省略号, 表示接收变长的 slice 参数):
#+BEGIN_SRC Golang
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
#+END_SRC

我们可以适当修改 appendInt() 来达到同样的目的:
#+BEGIN_SRC Golang
func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    // ...expand z to at least zlen...
    copy(z[len(x):], y)
    return z
}
#+END_SRC

** 在 slice 原有内存空间修改元素

nonempty() 在原有 slice 内存空间上返回不包含空字符串的列表:
#+BEGIN_SRC Golang
// Nonempty is an example of an in-place slice algorithm.
package main

import "fmt"

// nonempty returns a slice holding only the non-empty strings.
// The underlying array is modified during the call.
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != "" {
            strings[i] = s
            i++
        }
    }
    return strings[:i]
}

...

data := []string{"one", "", "three"}
fmt.Printf("%q\n", nonempty(data)) // `["one" "three"]`
fmt.Printf("%q\n", data)           // `["one" "three" "three"]`
#+END_SRC
在这边, 输入的 slice 和输出的 slice 共享一个底层数组, 这样可以避免分配另一个数组, 不过原来的数据可能会被覆盖.

* map

hash table 是一个无序的 k-v 对的集合, 所有的 k 都是不同的, 根据给定的 k, 可以在常数时间复杂度内检索, 更新或删除对应的 v. 在 Go 中, map 就是一个 hash table 的引用.

一个 map 类型的数据, 其所有的 k 必须是相同的类型, 所有的 v 也必须是相同的类型, 但 k 和 v 两者之间的类型可以不同. 另外, k 的类型要能支持 == 运算符, 这样可以判断 k 是否相等来判断是否已经存在. 最后, 浮点类型虽然可以作为 k, 但不是一个好选择, 因为直接比较浮点数, 得到的结果往往都是不相等.

** 创建 map 类型的数据

使用内置的 map() 创建 map:
#+BEGIN_SRC Golang
ages := make(map[string]int)  // mapping from strings to ints
#+END_SRC

使用 map 字面值的语法创建 map:
#+BEGIN_SRC Golang
ages := map[string]int{
	"alice": 31,
	"charlie": 34,
}
#+END_SRC
这相当于:
#+BEGIN_SRC Golang
ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
#+END_SRC

创建空 map 的表达式:
#+BEGIN_SRC Golang
ages := map[string]int{}
#+END_SRC

上面的初始化都是使用简短变量声明的. 如果先声明, 再创建, 可以这样:
#+BEGIN_SRC Golang
var ages map[string]int
ages = make(map[string]int)
#+END_SRC

** 访问 map 元素

#+BEGIN_SRC Golang
// 更新元素, 如果不存在该键, 则新增
ages["alice"] = 32

// 查询
fmt.Println(ages["alice"])  // "32"

// 删除元素
delete(ages, "alice")  // remove element ages["alice"]
#+END_SRC
这些操作都是安全的, 如果查询一个不存在的元素, 则会返回 v 的类型所对应的零值. 如, ages["bob"] 将返回 0.

但是, 如果 bob 键存在, 且对应的值就是 0, 程序中该如何判断这是 bob 键不存在而返回的 0, 还是原本就存在的 0?
#+BEGIN_SRC Golang
age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }
#+END_SRC
或直接写成:
#+BEGIN_SRC Golang
if age, ok := ages["bob"]; !ok { ... }
#+END_SRC

** 禁止取址操作

#+BEGIN_SRC Golang
_ = &ages["bob"]  // compile error: cannot take address of map element
#+END_SRC

禁止对 map 元素取地址的原因在于, map 可能随着元素数量的增大而重新分配更大的空间, 从而可能导致之前的地址无效.

** 遍历

#+BEGIN_SRC Golang
for name, age := range ages {
	fmt.Println("%s\t%d\n", name, age)
}
#+END_SRC
每次遍历的顺序都可能不同. 如果想按顺序遍历 key/value 对, 需要显式地对 key 进行排序. 如:
#+BEGIN_SRC Golang
import "sort"

names := make([]string, 0, len(ages))
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
#+END_SRC

** map 类型的零值

map 类型的零值为 nil.

大部分操作: 查找, 删除, len(), range循环都可以安全地工作在 nil 值的 map 上, 它们的行为和空 map 类似.

但是如果向 nil 值的 map 存入元素, 将会导致一个 panic 异常:
#+BEGIN_SRC Golang
var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
ages["carol"] = 21 // panic: assignment to entry in nil map
#+END_SRC
修改办法是将 ages 的声明语句改成:
#+BEGIN_SRC Golang
var ages map[string]int
ages = make(map[string]int)

// 或
ages := make(map[string]int)
#+END_SRC

所以要注意: 在向 map 存数据之前必须先创建 map.

** 比较

map 和 slice 一样, map 类型的数据相互之间不能用 == 来比较, 唯一的例外是可以与 nil 比较. 如果要判断两个 map 是否包含相同的 k-v 对, 需要通过循环实现:
#+BEGIN_SRC Golang
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}
#+END_SRC
在这个例子中, 使用 !ok 来区分元素不同和元素缺失.
