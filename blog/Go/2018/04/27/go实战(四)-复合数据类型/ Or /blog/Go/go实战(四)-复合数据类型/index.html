<!DOCTYPE html>
<html lang="en">
<head>
  <title>Go实战(四) 复合数据类型 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="Go" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Go实战(四) 复合数据类型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2c8c5f2">注</a>
<ul>
<li><a href="#org9d1df12">概述</a></li>
</ul>
</li>
<li><a href="#org081407a">数组</a>
<ul>
<li><a href="#org5909fdd">初始化</a></li>
<li><a href="#orgfb033af">索引和对应的值</a></li>
<li><a href="#org4570737">数组运算</a></li>
<li><a href="#orgef4f071">遍历</a></li>
</ul>
</li>
<li><a href="#orgc0c327f">slice</a>
<ul>
<li><a href="#org0b0116f">slice 的数据结构</a></li>
<li><a href="#orgd9a6965">声明和初始化</a></li>
<li><a href="#orgc070389">切片</a></li>
<li><a href="#org99b2d49">slice 作为函数参数</a></li>
<li><a href="#orgefbf787">比较</a></li>
<li><a href="#orgd4722f8">append()</a>
<ul>
<li><a href="#org7392c2f">append() 原理</a></li>
</ul>
</li>
<li><a href="#orgb9cbc09">在 slice 原有内存空间修改元素</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org2c8c5f2" class="outline-2">
<h2 id="org2c8c5f2">注</h2>
<div class="outline-text-2" id="text-org2c8c5f2">
<p>
学习自: Go 语言圣经
</p>
</div>

<div id="outline-container-org9d1df12" class="outline-3">
<h3 id="org9d1df12">概述</h3>
<div class="outline-text-3" id="text-org9d1df12">
<p>
数组和结构体有固定内存大小的数据结构; slice 和 map 是动态的数据结构, 会根据需要而动态增长.
</p>
</div>
</div>
</div>

<div id="outline-container-org081407a" class="outline-2">
<h2 id="org081407a">数组</h2>
<div class="outline-text-2" id="text-org081407a">
<p>
数组的长度固定, 我们一般不直接使用数组. slice 提供的功能会更多, 但我们要先理解数组, 才能理解 slice 的原理.
</p>

<p>
数组下标从 0 开始, len() 返回数组元素个数.
</p>
</div>

<div id="outline-container-org5909fdd" class="outline-3">
<h3 id="org5909fdd">初始化</h3>
<div class="outline-text-3" id="text-org5909fdd">
<p>
默认每个元素都被初始化为元素类型所对应的零值. 也可以自己赋予初始值:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 3}
fmt.Println(r[2])  // 0
</pre>
</div>

<p>
可以根据初始化元素的个数来决定数组的长度:
</p>
<div class="org-src-container">
<pre class="src src-Golang">q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q)  // [3]int
</pre>
</div>

<p>
数组长度是数组类型的一部分, 因此下面的赋值是错误的:
</p>
<div class="org-src-container">
<pre class="src src-Golang">q := [3]int{1,2,3}
q = [4]int{1,2,3,4}  // 编译错误
</pre>
</div>
<p>
另外, 数组长度必须是常量表达式, 因为数组长度在编译期确定.
</p>
</div>
</div>

<div id="outline-container-orgfb033af" class="outline-3">
<h3 id="orgfb033af">索引和对应的值</h3>
<div class="outline-text-3" id="text-orgfb033af">
<p>
我们可以在数组里存放索引-值, 做法如下:
</p>
<div class="org-src-container">
<pre class="src src-Golang">type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
</pre>
</div>

<p>
如果有索引未使用, 可以直接省略, Go 会使用零值来代替:
</p>
<div class="org-src-container">
<pre class="src src-Golang">r := [...]int{99:-1}
</pre>
</div>
<p>
从 0 到 98 的索引对应的值都是 0; 索引为 99 对应的值是 -1.
</p>
</div>
</div>

<div id="outline-container-org4570737" class="outline-3">
<h3 id="org4570737">数组运算</h3>
<div class="outline-text-3" id="text-org4570737">
<p>
如果数组元素类型是可比较的, 且两个数组的所有元素都相等, 则这两个数组是相等的.
</p>
<div class="org-src-container">
<pre class="src src-Golang">a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
</pre>
</div>
</div>
</div>

<div id="outline-container-orgef4f071" class="outline-3">
<h3 id="orgef4f071">遍历</h3>
<div class="outline-text-3" id="text-orgef4f071">
<div class="org-src-container">
<pre class="src src-Golang">var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc0c327f" class="outline-2">
<h2 id="orgc0c327f">slice</h2>
<div class="outline-text-2" id="text-orgc0c327f">
<p>
slice 的语法和数组很像, 但不固定长度.
</p>
</div>

<div id="outline-container-org0b0116f" class="outline-3">
<h3 id="org0b0116f">slice 的数据结构</h3>
<div class="outline-text-3" id="text-org0b0116f">
<p>
slice 的底层引用了一个数组对象.
</p>

<p>
一个 slice 由三部分构成: 指针, 长度, 容量.
</p>
<ol class="org-ol">
<li>指针: 指向第一个 slice 元素对应的底层数组元素的地址.(注: slice 的第一个元素不一定是数组的第一个元素)</li>
<li>长度: slice 中的元素数目, 不能超过容量, 使用 len() 获得.</li>
<li>容量: 从 slice 的开始位置到底层数据的结尾位置, 使用 cap() 获得.</li>
</ol>

<p>
如下图所示, 多个 slice 之间可以共享底层数据, 并且引用的数组部分区间可以重叠.
</p>


<div class="figure">
<p><img src="https://pinvondev.github.io/assets/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/7.png" alt="7.png" />
</p>
</div>

<p>
从这个图中, 也可以看出, len() 指的是 slice 的长度, cap() 指的是从 slice[0] 开始到底层数组最后一个元素之间的长度.
</p>

<p>
slice 在初始化时不需要指定长度, 而数组需要指定长度. 但是 slice 的底层数据结构又是数组, 这个背后的原理是什么?
</p>

<p>
其实, 在初始化 slice 时, 会隐式创建一个合适大小的数组, 然后 slice 的指针指向底层的数组.
</p>
</div>
</div>

<div id="outline-container-orgd9a6965" class="outline-3">
<h3 id="orgd9a6965">声明和初始化</h3>
<div class="outline-text-3" id="text-orgd9a6965">
<ul class="org-ul">
<li>声明一个未指定大小的数组来定义切片: var name []type</li>

<li>使用 make() 创建切片: var slice1 []type = make([]type, len)</li>

<li>slice1 := make([]type, len)</li>

<li>可以初始化的时候就指定容量: slice1 := make([]type, len, cap)</li>

<li>利用已有的数组来创建 slice: slice1 := array[m:n]</li>
</ul>
</div>
</div>

<div id="outline-container-orgc070389" class="outline-3">
<h3 id="orgc070389">切片</h3>
<div class="outline-text-3" id="text-orgc070389">
<p>
假设 x 是 slice 类型的, 则对 x 进行切片, 可以写成: y := x[m:n].
</p>

<p>
其中, \(0 \leq m \leq n \leq cap(s)\). y 引用 x 从第 m 个元素到第 n-1 个元素之间的数据. 
</p>

<p>
如果切片操作超过了 cap(x), 则会出现 <code>panic:out of range</code> 错误; 如果切片操作超过了 len(x), 则意味着对 x 进行扩展, 此时 y 里面的数据会比 x 还多.
</p>
</div>
</div>

<div id="outline-container-org99b2d49" class="outline-3">
<h3 id="org99b2d49">slice 作为函数参数</h3>
<div class="outline-text-3" id="text-org99b2d49">
<p>
因为 slice 的底层数据结构是数组, 且多个 slice 可以共享同一个底层数据结构, 因此, 对 slice 进行复制, 其实只是为底层数组创建了一个新的 slice 别名. 如果在函数内部对 slice 进行了修改, 会影响到函数外部. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

a := [...]int{0, 1, 2, 3, 4, 5}  // a 是数组, a[:] 是 slice
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgefbf787" class="outline-3">
<h3 id="orgefbf787">比较</h3>
<div class="outline-text-3" id="text-orgefbf787">
<p>
slice 不能像数组那样, 通过 == 操作符来判断两个 slice 是否含有全部相同的元素. 但有个例外: 如果这个 slice 是 []byte 类型的, 则可以使用 bytes.Equal() 来判断; 对于其他类型, 只能通过遍历每个元素来比较.
</p>

<div class="org-src-container">
<pre class="src src-Golang">func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
</pre>
</div>

<p>
slice 可以和 nil 作比较. slice 类型的零值就是 nil, 此时 slice 没有底层数组, len() 和 cap() 都是 0.
</p>

<pre class="example">
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
</pre>
<p>
可以看出, 如果要判断一个 slice 是否为空, 应该判断 len() 是否为 0, 而不能将其与 nil 作比较. 因为一个 nil 值的 slice 的行为与其他任意 0 长度的 slice 是一样的.
</p>
</div>
</div>

<div id="outline-container-orgd4722f8" class="outline-3">
<h3 id="orgd4722f8">append()</h3>
<div class="outline-text-3" id="text-orgd4722f8">
<p>
append() 用于向 slice 添加新元素. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
</pre>
</div>

<p>
当然, 这一段代码只是用来演示 append() 的用法, 其实际效果与 runes = []rune("Hello, 世界") 一样.
</p>
</div>

<div id="outline-container-org7392c2f" class="outline-4">
<h4 id="org7392c2f">append() 原理</h4>
<div class="outline-text-4" id="text-org7392c2f">
<p>
假设 appendInt() 就是 []int 类型的 slice 的 append() 操作.
</p>

<div class="org-src-container">
<pre class="src src-Golang">func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen &lt;= cap(x) {
        // There is room to grow.  Extend the slice.
        z = x[:zlen]
    } else {
        // There is insufficient space.  Allocate a new array.
        // Grow by doubling, for amortized linear complexity.
        zcap := zlen
        if zcap &lt; 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
</pre>
</div>
<p>
通过代码可以看出来, 每次添加新元素到 x 时, 都会先判断 len(x) 是否有足够空间来容纳新元素.
</p>

<p>
如果足够容纳, 则直接扩展 x, 然后将新元素添加进来, 添加新元素后的 slice 与原来的 slice 共享同一个数组;
</p>

<p>
如果空间不足, 则创建一个新的 slice, 其 cap() 至少要设置成添加新元素后的长度的两倍. 然后再将所有元素放进新的 slice 中, 添加新元素后的 slice 与原来的 slice 不共享同一数组.
</p>

<p>
copy() 是 Go 语言内置的函数, 可以将第二个参数复制给第一个参数.
</p>

<p>
内置的 append() 的实现会更加复杂, 它还可以追加多个元素, 甚至是另一个 slice. 如(注意最后一次追加时, 使用了省略号, 表示接收变长的 slice 参数):
</p>
<div class="org-src-container">
<pre class="src src-Golang">var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
</pre>
</div>

<p>
我们可以适当修改 appendInt() 来达到同样的目的:
</p>
<div class="org-src-container">
<pre class="src src-Golang">func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    // ...expand z to at least zlen...
    copy(z[len(x):], y)
    return z
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9cbc09" class="outline-3">
<h3 id="orgb9cbc09">在 slice 原有内存空间修改元素</h3>
<div class="outline-text-3" id="text-orgb9cbc09">
<p>
nonempty() 在原有 slice 内存空间上返回不包含空字符串的列表:
</p>
<div class="org-src-container">
<pre class="src src-Golang">// Nonempty is an example of an in-place slice algorithm.
package main

import "fmt"

// nonempty returns a slice holding only the non-empty strings.
// The underlying array is modified during the call.
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != "" {
            strings[i] = s
            i++
        }
    }
    return strings[:i]
}

...

data := []string{"one", "", "three"}
fmt.Printf("%q\n", nonempty(data)) // `["one" "three"]`
fmt.Printf("%q\n", data)           // `["one" "three" "three"]`
</pre>
</div>
<p>
在这边, 输入的 slice 和输出的 slice 共享一个底层数组, 这样可以避免分配另一个数组, 不过原来的数据可能会被覆盖.
</p>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-04-27</span>
            <span title="last modification date" class="post-info">2018-05-04</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/go">Go</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/";
         var disqus_url = "https://pinvondev.github.io/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
            <script type="text/javascript" src="/media/js/particle.js"></script>
            <script type="text/javascript" src="/media/js/love.js"></script>
</div>

  </div></body>
</html>
