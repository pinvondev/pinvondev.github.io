<!DOCTYPE html>
<html lang="en">
<head>
  <title>Go实战(四) 复合数据类型 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="Go" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Go实战(四) 复合数据类型</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org60e494e">注</a>
<ul>
<li><a href="#org14cb67c">概述</a></li>
</ul>
</li>
<li><a href="#org7a86730">数组</a>
<ul>
<li><a href="#orge5f6dcd">初始化</a></li>
<li><a href="#orgfe43e2b">索引和对应的值</a></li>
<li><a href="#org1b6310e">数组运算</a></li>
<li><a href="#org53a2922">遍历</a></li>
</ul>
</li>
<li><a href="#org97d353d">slice</a>
<ul>
<li><a href="#orgc1e2ae1">slice 的数据结构</a></li>
<li><a href="#org1c68cd5">声明和初始化</a></li>
<li><a href="#org56e10bc">切片</a></li>
<li><a href="#orgef7eff1">slice 作为函数参数</a></li>
<li><a href="#org6311c5d">比较</a></li>
<li><a href="#orgaa4baa6">append()</a>
<ul>
<li><a href="#org16eda6c">append() 原理</a></li>
</ul>
</li>
<li><a href="#orgeed90b0">在 slice 原有内存空间修改元素</a></li>
</ul>
</li>
<li><a href="#org9a5e59e">map</a>
<ul>
<li><a href="#orgf71ceca">创建 map 类型的数据</a></li>
<li><a href="#org201ebd2">访问 map 元素</a></li>
<li><a href="#org79f84b2">禁止取址操作</a></li>
<li><a href="#org1e7c99e">遍历</a></li>
<li><a href="#orgb3fb6db">map 类型的零值</a></li>
<li><a href="#org00e6395">比较</a>
<ul>
<li><a href="#org523dc03">slice 等不可比较的类型作为 map 的 Key</a></li>
</ul>
</li>
<li><a href="#orga361f55">把 map 当作 set 来使用</a></li>
<li><a href="#org30a6e7a">Value 的聚合</a></li>
</ul>
</li>
<li><a href="#orgaef8f3b">struct</a>
<ul>
<li><a href="#orgcf790e4">声明</a></li>
<li><a href="#org6ac995d">访问 struct 变量的成员</a></li>
<li><a href="#orgf3de7d5">成员</a>
<ul>
<li><a href="#orge481c38">注</a></li>
</ul>
</li>
<li><a href="#org512cd16">struct 类型的零值</a></li>
<li><a href="#org8f47132">空 struct</a></li>
<li><a href="#org6d64046">初始化</a>
<ul>
<li><a href="#org4a9182e">根据成员的定义顺序初始化</a></li>
<li><a href="#org64c9e7c">根据成员的名字来初始化(推荐)</a></li>
<li><a href="#orge926cd3">注</a></li>
</ul>
</li>
<li><a href="#org205288e">struct 作为函数参数或返回值</a></li>
<li><a href="#org0eded59">struct 比较</a></li>
<li><a href="#org9a82b49">struct 嵌套</a>
<ul>
<li><a href="#org6867752">匿名嵌入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8ef99e3">JSON</a>
<ul>
<li><a href="#orge38b96e">JSON 的数据类型</a></li>
<li><a href="#org4220772">marshaling(编码)</a>
<ul>
<li><a href="#orgb76c142">注</a>
<ul>
<li><a href="#orga749eba">结构体成员Tag</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org460320c">unmarshaling(解码)</a></li>
<li><a href="#orgb426c67">例子</a></li>
</ul>
</li>
<li><a href="#org92acafd">TEXT 模板 和 HTML 模板</a>
<ul>
<li><a href="#org778d471">TEXT 模板</a></li>
<li><a href="#org49500f0">HTML 模板</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org60e494e" class="outline-2">
<h2 id="org60e494e">注</h2>
<div class="outline-text-2" id="text-org60e494e">
<p>
学习自: Go 语言圣经
</p>
</div>

<div id="outline-container-org14cb67c" class="outline-3">
<h3 id="org14cb67c">概述</h3>
<div class="outline-text-3" id="text-org14cb67c">
<p>
数组和结构体有固定内存大小的数据结构; slice 和 map 是动态的数据结构, 会根据需要而动态增长.
</p>
</div>
</div>
</div>

<div id="outline-container-org7a86730" class="outline-2">
<h2 id="org7a86730">数组</h2>
<div class="outline-text-2" id="text-org7a86730">
<p>
数组的长度固定, 我们一般不直接使用数组. slice 提供的功能会更多, 但我们要先理解数组, 才能理解 slice 的原理.
</p>

<p>
数组下标从 0 开始, len() 返回数组元素个数.
</p>
</div>

<div id="outline-container-orge5f6dcd" class="outline-3">
<h3 id="orge5f6dcd">初始化</h3>
<div class="outline-text-3" id="text-orge5f6dcd">
<p>
默认每个元素都被初始化为元素类型所对应的零值. 也可以自己赋予初始值:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 3}
fmt.Println(r[2])  // 0
</pre>
</div>

<p>
可以根据初始化元素的个数来决定数组的长度:
</p>
<div class="org-src-container">
<pre class="src src-Golang">q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q)  // [3]int
</pre>
</div>

<p>
数组长度是数组类型的一部分, 因此下面的赋值是错误的:
</p>
<div class="org-src-container">
<pre class="src src-Golang">q := [3]int{1,2,3}
q = [4]int{1,2,3,4}  // 编译错误
</pre>
</div>
<p>
另外, 数组长度必须是常量表达式, 因为数组长度在编译期确定.
</p>
</div>
</div>

<div id="outline-container-orgfe43e2b" class="outline-3">
<h3 id="orgfe43e2b">索引和对应的值</h3>
<div class="outline-text-3" id="text-orgfe43e2b">
<p>
我们可以在数组里存放索引-值, 做法如下:
</p>
<div class="org-src-container">
<pre class="src src-Golang">type Currency int

const (
    USD Currency = iota // 美元
    EUR                 // 欧元
    GBP                 // 英镑
    RMB                 // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB]) // "3 ￥"
</pre>
</div>

<p>
如果有索引未使用, 可以直接省略, Go 会使用零值来代替:
</p>
<div class="org-src-container">
<pre class="src src-Golang">r := [...]int{99:-1}
</pre>
</div>
<p>
从 0 到 98 的索引对应的值都是 0; 索引为 99 对应的值是 -1.
</p>
</div>
</div>

<div id="outline-container-org1b6310e" class="outline-3">
<h3 id="org1b6310e">数组运算</h3>
<div class="outline-text-3" id="text-org1b6310e">
<p>
如果数组元素类型是可比较的, 且两个数组的所有元素都相等, 则这两个数组是相等的.
</p>
<div class="org-src-container">
<pre class="src src-Golang">a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
</pre>
</div>
</div>
</div>

<div id="outline-container-org53a2922" class="outline-3">
<h3 id="org53a2922">遍历</h3>
<div class="outline-text-3" id="text-org53a2922">
<div class="org-src-container">
<pre class="src src-Golang">var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

// Print the indices and elements.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Print the elements only.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org97d353d" class="outline-2">
<h2 id="org97d353d">slice</h2>
<div class="outline-text-2" id="text-org97d353d">
<p>
slice 的语法和数组很像, 但不固定长度.
</p>
</div>

<div id="outline-container-orgc1e2ae1" class="outline-3">
<h3 id="orgc1e2ae1">slice 的数据结构</h3>
<div class="outline-text-3" id="text-orgc1e2ae1">
<p>
slice 的底层引用了一个数组对象.
</p>

<p>
一个 slice 由三部分构成: 指针, 长度, 容量.
</p>
<ol class="org-ol">
<li>指针: 指向第一个 slice 元素对应的底层数组元素的地址.(注: slice 的第一个元素不一定是数组的第一个元素)</li>
<li>长度: slice 中的元素数目, 不能超过容量, 使用 len() 获得.</li>
<li>容量: 从 slice 的开始位置到底层数据的结尾位置, 使用 cap() 获得.</li>
</ol>

<p>
如下图所示, 多个 slice 之间可以共享底层数据, 并且引用的数组部分区间可以重叠.
</p>


<div class="figure">
<p><img src="https://pinvondev.github.io/assets/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/7.png" alt="7.png" />
</p>
</div>

<p>
从这个图中, 也可以看出, len() 指的是 slice 的长度, cap() 指的是从 slice[0] 开始到底层数组最后一个元素之间的长度.
</p>

<p>
slice 在初始化时不需要指定长度, 而数组需要指定长度. 但是 slice 的底层数据结构又是数组, 这个背后的原理是什么?
</p>

<p>
其实, 在初始化 slice 时, 会隐式创建一个合适大小的数组, 然后 slice 的指针指向底层的数组.
</p>
</div>
</div>

<div id="outline-container-org1c68cd5" class="outline-3">
<h3 id="org1c68cd5">声明和初始化</h3>
<div class="outline-text-3" id="text-org1c68cd5">
<ul class="org-ul">
<li>声明一个未指定大小的数组来定义切片: var name []type</li>

<li>使用 make() 创建切片: var slice1 []type = make([]type, len)</li>

<li>slice1 := make([]type, len)</li>

<li>可以初始化的时候就指定容量: slice1 := make([]type, len, cap)</li>

<li>利用已有的数组来创建 slice: slice1 := array[m:n]</li>
</ul>
</div>
</div>

<div id="outline-container-org56e10bc" class="outline-3">
<h3 id="org56e10bc">切片</h3>
<div class="outline-text-3" id="text-org56e10bc">
<p>
假设 x 是 slice 类型的, 则对 x 进行切片, 可以写成: y := x[m:n].
</p>

<p>
其中, \(0 \leq m \leq n \leq cap(s)\). y 引用 x 从第 m 个元素到第 n-1 个元素之间的数据. 
</p>

<p>
如果切片操作超过了 cap(x), 则会出现 <code>panic:out of range</code> 错误; 如果切片操作超过了 len(x), 则意味着对 x 进行扩展, 此时 y 里面的数据会比 x 还多.
</p>
</div>
</div>

<div id="outline-container-orgef7eff1" class="outline-3">
<h3 id="orgef7eff1">slice 作为函数参数</h3>
<div class="outline-text-3" id="text-orgef7eff1">
<p>
因为 slice 的底层数据结构是数组, 且多个 slice 可以共享同一个底层数据结构, 因此, 对 slice 进行复制, 其实只是为底层数组创建了一个新的 slice 别名. 如果在函数内部对 slice 进行了修改, 会影响到函数外部. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

a := [...]int{0, 1, 2, 3, 4, 5}  // a 是数组, a[:] 是 slice
reverse(a[:])
fmt.Println(a) // "[5 4 3 2 1 0]"
</pre>
</div>
</div>
</div>

<div id="outline-container-org6311c5d" class="outline-3">
<h3 id="org6311c5d">比较</h3>
<div class="outline-text-3" id="text-org6311c5d">
<p>
slice 不能像数组那样, 通过 == 操作符来判断两个 slice 是否含有全部相同的元素. 但有个例外: 如果这个 slice 是 []byte 类型的, 则可以使用 bytes.Equal() 来判断; 对于其他类型, 只能通过遍历每个元素来比较.
</p>

<div class="org-src-container">
<pre class="src src-Golang">func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
</pre>
</div>

<p>
slice 可以和 nil 作比较. slice 类型的零值就是 nil, 此时 slice 没有底层数组, len() 和 cap() 都是 0.
</p>

<pre class="example">
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
</pre>
<p>
可以看出, 如果要判断一个 slice 是否为空, 应该判断 len() 是否为 0, 而不能将其与 nil 作比较. 因为一个 nil 值的 slice 的行为与其他任意 0 长度的 slice 是一样的.
</p>
</div>
</div>

<div id="outline-container-orgaa4baa6" class="outline-3">
<h3 id="orgaa4baa6">append()</h3>
<div class="outline-text-3" id="text-orgaa4baa6">
<p>
append() 用于向 slice 添加新元素. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var runes []rune
for _, r := range "Hello, 世界" {
    runes = append(runes, r)
}
fmt.Printf("%q\n", runes) // "['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']"
</pre>
</div>

<p>
当然, 这一段代码只是用来演示 append() 的用法, 其实际效果与 runes = []rune("Hello, 世界") 一样.
</p>
</div>

<div id="outline-container-org16eda6c" class="outline-4">
<h4 id="org16eda6c">append() 原理</h4>
<div class="outline-text-4" id="text-org16eda6c">
<p>
假设 appendInt() 就是 []int 类型的 slice 的 append() 操作.
</p>

<div class="org-src-container">
<pre class="src src-Golang">func appendInt(x []int, y int) []int {
    var z []int
    zlen := len(x) + 1
    if zlen &lt;= cap(x) {
        // There is room to grow.  Extend the slice.
        z = x[:zlen]
    } else {
        // There is insufficient space.  Allocate a new array.
        // Grow by doubling, for amortized linear complexity.
        zcap := zlen
        if zcap &lt; 2*len(x) {
            zcap = 2 * len(x)
        }
        z = make([]int, zlen, zcap)
        copy(z, x) // a built-in function; see text
    }
    z[len(x)] = y
    return z
}
</pre>
</div>
<p>
通过代码可以看出来, 每次添加新元素到 x 时, 都会先判断 len(x) 是否有足够空间来容纳新元素.
</p>

<p>
如果足够容纳, 则直接扩展 x, 然后将新元素添加进来, 添加新元素后的 slice 与原来的 slice 共享同一个数组;
</p>

<p>
如果空间不足, 则创建一个新的 slice, 其 cap() 至少要设置成添加新元素后的长度的两倍. 然后再将所有元素放进新的 slice 中, 添加新元素后的 slice 与原来的 slice 不共享同一数组.
</p>

<p>
copy() 是 Go 语言内置的函数, 可以将第二个参数复制给第一个参数.
</p>

<p>
内置的 append() 的实现会更加复杂, 它还可以追加多个元素, 甚至是另一个 slice. 如(注意最后一次追加时, 使用了省略号, 表示接收变长的 slice 参数):
</p>
<div class="org-src-container">
<pre class="src src-Golang">var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
</pre>
</div>

<p>
我们可以适当修改 appendInt() 来达到同样的目的:
</p>
<div class="org-src-container">
<pre class="src src-Golang">func appendInt(x []int, y ...int) []int {
    var z []int
    zlen := len(x) + len(y)
    // ...expand z to at least zlen...
    copy(z[len(x):], y)
    return z
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgeed90b0" class="outline-3">
<h3 id="orgeed90b0">在 slice 原有内存空间修改元素</h3>
<div class="outline-text-3" id="text-orgeed90b0">
<p>
nonempty() 在原有 slice 内存空间上返回不包含空字符串的列表:
</p>
<div class="org-src-container">
<pre class="src src-Golang">// Nonempty is an example of an in-place slice algorithm.
package main

import "fmt"

// nonempty returns a slice holding only the non-empty strings.
// The underlying array is modified during the call.
func nonempty(strings []string) []string {
    i := 0
    for _, s := range strings {
        if s != "" {
            strings[i] = s
            i++
        }
    }
    return strings[:i]
}

...

data := []string{"one", "", "three"}
fmt.Printf("%q\n", nonempty(data)) // `["one" "three"]`
fmt.Printf("%q\n", data)           // `["one" "three" "three"]`
</pre>
</div>
<p>
在这边, 输入的 slice 和输出的 slice 共享一个底层数组, 这样可以避免分配另一个数组, 不过原来的数据可能会被覆盖.
</p>
</div>
</div>
</div>

<div id="outline-container-org9a5e59e" class="outline-2">
<h2 id="org9a5e59e">map</h2>
<div class="outline-text-2" id="text-org9a5e59e">
<p>
hash table 是一个无序的 k-v 对的集合, 所有的 k 都是不同的, 根据给定的 k, 可以在常数时间复杂度内检索, 更新或删除对应的 v. 在 Go 中, map 就是一个 hash table 的引用.
</p>

<p>
一个 map 类型的数据, 其所有的 k 必须是相同的类型, 所有的 v 也必须是相同的类型, 但 k 和 v 两者之间的类型可以不同. 另外, k 的类型要能支持 == 运算符, 这样可以判断 k 是否相等来判断是否已经存在. 最后, 浮点类型虽然可以作为 k, 但不是一个好选择, 因为直接比较浮点数, 得到的结果往往都是不相等.
</p>
</div>

<div id="outline-container-orgf71ceca" class="outline-3">
<h3 id="orgf71ceca">创建 map 类型的数据</h3>
<div class="outline-text-3" id="text-orgf71ceca">
<p>
使用内置的 map() 创建 map:
</p>
<div class="org-src-container">
<pre class="src src-Golang">ages := make(map[string]int)  // mapping from strings to ints
</pre>
</div>

<p>
使用 map 字面值的语法创建 map:
</p>
<div class="org-src-container">
<pre class="src src-Golang">ages := map[string]int{
    "alice": 31,
    "charlie": 34,
}
</pre>
</div>
<p>
这相当于:
</p>
<div class="org-src-container">
<pre class="src src-Golang">ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
</pre>
</div>

<p>
创建空 map 的表达式:
</p>
<div class="org-src-container">
<pre class="src src-Golang">ages := map[string]int{}
</pre>
</div>

<p>
上面的初始化都是使用简短变量声明的. 如果先声明, 再创建, 可以这样:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var ages map[string]int
ages = make(map[string]int)
</pre>
</div>
</div>
</div>

<div id="outline-container-org201ebd2" class="outline-3">
<h3 id="org201ebd2">访问 map 元素</h3>
<div class="outline-text-3" id="text-org201ebd2">
<div class="org-src-container">
<pre class="src src-Golang">// 更新元素, 如果不存在该键, 则新增
ages["alice"] = 32

// 查询
fmt.Println(ages["alice"])  // "32"

// 删除元素
delete(ages, "alice")  // remove element ages["alice"]
</pre>
</div>
<p>
这些操作都是安全的, 如果查询一个不存在的元素, 则会返回 v 的类型所对应的零值. 如, ages["bob"] 将返回 0.
</p>

<p>
但是, 如果 bob 键存在, 且对应的值就是 0, 程序中该如何判断这是 bob 键不存在而返回的 0, 还是原本就存在的 0?
</p>
<div class="org-src-container">
<pre class="src src-Golang">age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }
</pre>
</div>
<p>
或直接写成:
</p>
<div class="org-src-container">
<pre class="src src-Golang">if age, ok := ages["bob"]; !ok { ... }
</pre>
</div>
</div>
</div>

<div id="outline-container-org79f84b2" class="outline-3">
<h3 id="org79f84b2">禁止取址操作</h3>
<div class="outline-text-3" id="text-org79f84b2">
<div class="org-src-container">
<pre class="src src-Golang">_ = &amp;ages["bob"]  // compile error: cannot take address of map element
</pre>
</div>

<p>
禁止对 map 元素取地址的原因在于, map 可能随着元素数量的增大而重新分配更大的空间, 从而可能导致之前的地址无效.
</p>
</div>
</div>

<div id="outline-container-org1e7c99e" class="outline-3">
<h3 id="org1e7c99e">遍历</h3>
<div class="outline-text-3" id="text-org1e7c99e">
<div class="org-src-container">
<pre class="src src-Golang">for name, age := range ages {
    fmt.Println("%s\t%d\n", name, age)
}
</pre>
</div>
<p>
每次遍历的顺序都可能不同. 如果想按顺序遍历 key/value 对, 需要显式地对 key 进行排序. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">import "sort"

names := make([]string, 0, len(ages))
for name := range ages {
    names = append(names, name)
}
sort.Strings(names)
for _, name := range names {
    fmt.Printf("%s\t%d\n", name, ages[name])
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3fb6db" class="outline-3">
<h3 id="orgb3fb6db">map 类型的零值</h3>
<div class="outline-text-3" id="text-orgb3fb6db">
<p>
map 类型的零值为 nil.
</p>

<p>
大部分操作: 查找, 删除, len(), range循环都可以安全地工作在 nil 值的 map 上, 它们的行为和空 map 类似.
</p>

<p>
但是如果向 nil 值的 map 存入元素, 将会导致一个 panic 异常:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var ages map[string]int
fmt.Println(ages == nil)    // "true"
fmt.Println(len(ages) == 0) // "true"
ages["carol"] = 21 // panic: assignment to entry in nil map
</pre>
</div>
<p>
修改办法是将 ages 的声明语句改成:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var ages map[string]int
ages = make(map[string]int)

// 或
ages := make(map[string]int)
</pre>
</div>

<p>
所以要注意: 在向 map 存数据之前必须先创建 map.
</p>
</div>
</div>

<div id="outline-container-org00e6395" class="outline-3">
<h3 id="org00e6395">比较</h3>
<div class="outline-text-3" id="text-org00e6395">
<p>
map 和 slice 一样, map 类型的数据相互之间不能用 == 来比较, 唯一的例外是可以与 nil 比较. 如果要判断两个 map 是否包含相同的 k-v 对, 需要通过循环实现:
</p>
<div class="org-src-container">
<pre class="src src-Golang">func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}
</pre>
</div>
<p>
在这个例子中, 使用 !ok 来区分元素不同和元素缺失.
</p>
</div>

<div id="outline-container-org523dc03" class="outline-4">
<h4 id="org523dc03">slice 等不可比较的类型作为 map 的 Key</h4>
<div class="outline-text-4" id="text-org523dc03">
<p>
根据前面所述, 可以知道 map 的 Key 是要可以比较的类型. 但是如果我们想让 slice 或其他不可比较的类型作为 map 的 Key, 可以通过两个步骤来绕过这个限制, 以 slice 为例:
</p>
<ul class="org-ul">
<li>定义辅助函数, 将 slice 转化为 string 类型.</li>
<li>创建 map, 其中, key 为 string 类型, 每次对 map 操作时先用辅助函数将 slice 转化为 string.</li>
</ul>
<div class="org-src-container">
<pre class="src src-Golang">var m = make(map[string]int)
func k(list []string) string { return fmt.Sprintf("%q", list) }
func Add(list []string)       { m[k(list)]++ }
func Count(list []string) int { return m[k(list)] }
</pre>
</div>
<p>
k() 将输入的参数转化为 string 类型. 如果参数是整数类型, %q 占位符将其转化为单引号引起来的字符串, 如果参数是字符串或 slice, %q 占位符将其转化成双引号引起来的字符串.
</p>
</div>
</div>
</div>

<div id="outline-container-orga361f55" class="outline-3">
<h3 id="orga361f55">把 map 当作 set 来使用</h3>
<div class="outline-text-3" id="text-orga361f55">
<p>
在 Go 语言中, 没有 set 类型. set 是指元素不重复的集合, 在 map 中, key 是不重复的, 所以如果忽略 value, 则 map 就相当于 set.
</p>
</div>
</div>

<div id="outline-container-org30a6e7a" class="outline-3">
<h3 id="org30a6e7a">Value 的聚合</h3>
<div class="outline-text-3" id="text-org30a6e7a">
<p>
map 的 Value 可以是聚合的, 意思就是, map 的 Value 可能又是一个 map. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
    edges := graph[from]
    if edges == nil {
        edges = make(map[string]bool)
        graph[from] = edges
    }
    edges[to] = true
}

func hasEdge(from, to string) bool {
    return graph[from][to]
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgaef8f3b" class="outline-2">
<h2 id="orgaef8f3b">struct</h2>
<div class="outline-text-2" id="text-orgaef8f3b">
<p>
struct 是一种聚合类型, struct 类型的实体的成员可以由零个或多个任意类型的值聚合而成.
</p>
</div>

<div id="outline-container-orgcf790e4" class="outline-3">
<h3 id="orgcf790e4">声明</h3>
<div class="outline-text-3" id="text-orgcf790e4">
<div class="org-src-container">
<pre class="src src-Golang">type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
</pre>
</div>
<p>
这段代码声明了一个 Employee 结构体类型, 然后声明了一个 Employee 类型的变量 dilbert.
</p>

<p>
结构体成员的顺序很重要, 即使成员都相同, 但顺序不同, Go 也认为这两个结构体是不同的. 通常情况下, 结构体成员一行只写一个, 不过如果相邻两个成员的类型相同, 可以合并到一行.
</p>
</div>
</div>

<div id="outline-container-org6ac995d" class="outline-3">
<h3 id="org6ac995d">访问 struct 变量的成员</h3>
<div class="outline-text-3" id="text-org6ac995d">
<p>
使用点操作符对 struct 类型变量的成员进行访问. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">dilbert.Salary -= 5000 // demoted, for writing too few lines of code
</pre>
</div>

<p>
还可以对成员取地址, 然后通过指针访问:
</p>
<div class="org-src-container">
<pre class="src src-Golang">position := &amp;dilbert.Position
*position = "Senior " + *position // promoted, for outsourcing to Elbonia
</pre>
</div>

<p>
还可以定义结构体类型的变量的指针, 通过指针来访问变量的成员:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var employeeOfTheMonth *Employee = &amp;dilbert
employeeOfTheMonth.Position += " (proactive team player)"

// 或者
(*employeeOfTheMonth).Position += " (proactive team player)"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf3de7d5" class="outline-3">
<h3 id="orgf3de7d5">成员</h3>
<div class="outline-text-3" id="text-orgf3de7d5">
<p>
如果有个名为 S 的结构体类型, 则该结构体不能再包含 S 类型的成员. 即: 一个聚合的值不能包含它自身. 但是, 可以包含 *S 指针类型的成员. 这可以让我们创建递归的数据结构, 如链表和树等.
</p>

<div class="org-src-container">
<pre class="src src-Golang">type tree struct {
    value       int
    left, right *tree
}

// Sort sorts values in place.
func Sort(values []int) {
    var root *tree
    for _, v := range values {
        root = add(root, v)
    }
    appendValues(values[:0], root)
}

// appendValues appends the elements of t to values in order
// and returns the resulting slice.
func appendValues(values []int, t *tree) []int {
    if t != nil {
        values = appendValues(values, t.left)
        values = append(values, t.value)
        values = appendValues(values, t.right)
    }
    return values
}

func add(t *tree, value int) *tree {
    if t == nil {
        // Equivalent to return &amp;tree{value: value}.
        t = new(tree)
        t.value = value
        return t
    }
    if value &lt; t.value {
        t.left = add(t.left, value)
    } else {
        t.right = add(t.right, value)
    }
    return t
}
</pre>
</div>
</div>

<div id="outline-container-orge481c38" class="outline-4">
<h4 id="orge481c38">注</h4>
<div class="outline-text-4" id="text-orge481c38">
<p>
Go 语言中, 如果 struct 的成员名是以小写字母开头, 则其他包无法访问该成员.
</p>
</div>
</div>
</div>

<div id="outline-container-org512cd16" class="outline-3">
<h3 id="org512cd16">struct 类型的零值</h3>
<div class="outline-text-3" id="text-org512cd16">
<p>
struct 类型的零值就是每个成员都是其对应的零值.
</p>
</div>
</div>

<div id="outline-container-org8f47132" class="outline-3">
<h3 id="org8f47132">空 struct</h3>
<div class="outline-text-3" id="text-org8f47132">
<div class="org-src-container">
<pre class="src src-Golang">struct{}
</pre>
</div>
<p>
大小为 0.
</p>
</div>
</div>

<div id="outline-container-org6d64046" class="outline-3">
<h3 id="org6d64046">初始化</h3>
<div class="outline-text-3" id="text-org6d64046">
</div>
<div id="outline-container-org4a9182e" class="outline-4">
<h4 id="org4a9182e">根据成员的定义顺序初始化</h4>
<div class="outline-text-4" id="text-org4a9182e">
<div class="org-src-container">
<pre class="src src-Golang">type Point struct{ X, Y int }
p := Point{1, 2}
</pre>
</div>
</div>
</div>

<div id="outline-container-org64c9e7c" class="outline-4">
<h4 id="org64c9e7c">根据成员的名字来初始化(推荐)</h4>
<div class="outline-text-4" id="text-org64c9e7c">
<div class="org-src-container">
<pre class="src src-Golang">type Point struct{ X, Y int }
p := Point{X: 1, Y: 2}
</pre>
</div>
<p>
如果未提供 Y: 2, 则 Y 的初始值为零值.
</p>
</div>
</div>

<div id="outline-container-orge926cd3" class="outline-4">
<h4 id="orge926cd3">注</h4>
<div class="outline-text-4" id="text-orge926cd3">
<p>
由于结构体在使用时, 一般都是通过指针来引用的. 所以可以这样来创建并初始化一个结构体变量:
</p>
<div class="org-src-container">
<pre class="src src-Golang">p := &amp;Point{1, 2}

// 或
p := &amp;Point{X: 1, Y: 2}
</pre>
</div>

<p>
这种写法等价于:
</p>
<div class="org-src-container">
<pre class="src src-Golang">p := new(Point)

*p = Point{1, 2}
// 或
*p = Point{X: 1, Y: 2}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org205288e" class="outline-3">
<h3 id="org205288e">struct 作为函数参数或返回值</h3>
<div class="outline-text-3" id="text-org205288e">
<div class="org-src-container">
<pre class="src src-Golang">func Scale(p Point, factor int) Point {
    return Point{p.X * factor, p.Y * factor}
}
fmt.Println(Scale(Point{1, 2}, 5)) // "{5 10}"
</pre>
</div>

<p>
但是这种直接传递的方式, 效率较低. 一般更推荐使用指针的方式传递参数. 
</p>

<p>
在 Go 中, 如果不指定使用指针传参, 都会被默认为使用值传递, 即函数内部使用的参数, 其实是传递进去的参数的一份拷贝, 在函数内部所做的修改, 影响不到外面. 所以, 可以看出, 当 struct 较大时, 值传递要消耗较多内存, 因为值传递要另外拷贝一份 struct.
</p>

<p>
可以这样声明函数:
</p>
<div class="org-src-container">
<pre class="src src-Golang">func Bonus(e *Employee, percent int) int {
    return e.Salary * percent / 100
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0eded59" class="outline-3">
<h3 id="org0eded59">struct 比较</h3>
<div class="outline-text-3" id="text-org0eded59">
<p>
如果 struct 的全部成员都是可比较的, 则 struct 也是可比较的.
</p>
</div>
</div>

<div id="outline-container-org9a82b49" class="outline-3">
<h3 id="org9a82b49">struct 嵌套</h3>
<div class="outline-text-3" id="text-org9a82b49">
<div class="org-src-container">
<pre class="src src-Golang">type Point struct {
    X, Y int
}

type Circle struct {
    Center Point
    Radius int
}

type Wheel struct {
    Circle Circle
    Spokes int
}

var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
</pre>
</div>
</div>

<div id="outline-container-org6867752" class="outline-4">
<h4 id="org6867752">匿名嵌入</h4>
<div class="outline-text-4" id="text-org6867752">
<div class="org-src-container">
<pre class="src src-Golang">type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}

var w Wheel
w.X = 8            // equivalent to w.Circle.Point.X = 8
w.Y = 8            // equivalent to w.Circle.Point.Y = 8
w.Radius = 5       // equivalent to w.Circle.Radius = 5
w.Spokes = 20
</pre>
</div>

<p>
匿名成员是指那些只给出了类型, 而没给出名字的成员.
</p>

<p>
从上面的代码中可以看出, 访问匿名成员时, 会自顶向下, 一级一级往下找, 直到找到最后一个匿名成员, 然后将值赋给该类型的变量. 如, w.X 是找到 w.Circle.Point.X, 而不是找到 w.Circle.X.
</p>

<p>
由于匿名成员有隐式的名字, 所以不能同时包含两个类型相同的匿名成员, 否则会导致名字冲突.
</p>

<p>
在初始化时, 不能使用匿名成员的方式来初始化, 必须给出完整路径. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">w = Wheel{Circle{Point{8, 8}, 5}, 20}

w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)
}

fmt.Printf("%#v\n", w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}

w.X = 42

fmt.Printf("%#v\n", w)
// Output:
// Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org8ef99e3" class="outline-2">
<h2 id="org8ef99e3">JSON</h2>
<div class="outline-text-2" id="text-org8ef99e3">
<p>
JSON 是一种用于发送和接收结构化信息的标准协议.
</p>
</div>

<div id="outline-container-orge38b96e" class="outline-3">
<h3 id="orge38b96e">JSON 的数据类型</h3>
<div class="outline-text-3" id="text-orge38b96e">
<p>
在 JSON 中, 有数字, 布尔值, 字符串, 数组, 对象. 其中, 数组和对象是通过前三个类型组合而来的. 如下所示:
</p>
<div class="org-src-container">
<pre class="src src-Golang">boolean         true
number          -273.15
string          "She said \"Hello, BF\""
array           ["gold", "silver", "bronze"]
object          {"year": 1980,
                 "event": "archery",
                 "medals": ["gold", "silver", "bronze"]}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4220772" class="outline-3">
<h3 id="org4220772">marshaling(编码)</h3>
<div class="outline-text-3" id="text-org4220772">
<p>
在 Go 中, 如果有一个 slice, 其元素都是 struct, 将这样的 slice 转化成 JSON 的过程, 就叫 marshaling(编组). 如:
</p>

<p>
有一个 struct, 名为 Movie:
</p>
<div class="org-src-container">
<pre class="src src-Golang">type Movie struct {
    Title  string
    Year   int  `json:"released"`
    Color  bool `json:"color,omitempty"`
    Actors []string
}
</pre>
</div>

<p>
有一个 slice, 其元素都是 Movie 类型:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var movies = []Movie{
    {Title: "Casablanca", Year: 1942, Color: false,
        Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
    {Title: "Cool Hand Luke", Year: 1967, Color: true,
        Actors: []string{"Paul Newman"}},
    {Title: "Bullitt", Year: 1968, Color: true,
        Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
    // ...
}
</pre>
</div>

<p>
使用 Marshal():
</p>
<div class="org-src-container">
<pre class="src src-Golang">data, err := json.Marshal(movies)
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
fmt.Printf("%s\n", data)
</pre>
</div>

<p>
打印结果:
</p>
<pre class="example">
[{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingr
id Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Ac
tors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"
Actors":["Steve McQueen","Jacqueline Bisset"]}]
</pre>

<p>
如果觉得这种输出难以阅读, 可以使用 MarshalIndent():
</p>
<div class="org-src-container">
<pre class="src src-Golang">data, err := json.MarshalIndent(movies, "", "    ")
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
fmt.Printf("%s\n", data)
</pre>
</div>

<p>
打印结果如下:
</p>
<pre class="example">
[
    {
        "Title": "Casablanca",
        "released": 1942,
        "Actors": [
            "Humphrey Bogart",
            "Ingrid Bergman"
        ]
    },
    {
        "Title": "Cool Hand Luke",
        "released": 1967,
        "color": true,
        "Actors": [
            "Paul Newman"
        ]
    },
    {
        "Title": "Bullitt",
        "released": 1968,
        "color": true,
        "Actors": [
            "Steve McQueen",
            "Jacqueline Bisset"
        ]
    }
]
</pre>
</div>

<div id="outline-container-orgb76c142" class="outline-4">
<h4 id="orgb76c142">注</h4>
<div class="outline-text-4" id="text-orgb76c142">
<p>
由于 Go 中 struct 的成员名如果是以小写字母开头, 则其他包无法访问, 所以 JSON 无法访问我们的 struct 里以小写字母开头的成员, 因此也就无法 marshaling, 不会出现在 JSON 编码的结果中.
</p>

<p>
所以到这里, 我们就可以明白, 为什么上面的例子中, struct 的成员都是大写字母开头的.
</p>

<p>
另外, 对比 Movie 的成员名和 marshaling 后 JSON 的成员名, 可以发现, Year 变成了 released, Color 变成了 color. 要知道为什么会这样, 需要先了解 结构体成员Tag 的概念.
</p>
</div>

<div id="outline-container-orga749eba" class="outline-5">
<h5 id="orga749eba">结构体成员Tag</h5>
<div class="outline-text-5" id="text-orga749eba">
<p>
结构体成员Tag 是任意的字符串, 不过我们一般写成 key:"value" 这样的格式.
</p>

<p>
如果 key 为 json, 表示使用 encoding/json 包的编码和解码行为; 如果 key 为 xml, 表示使用 encoding/xml 包的编码和解码行为.
</p>

<p>
value 中的第一个值用于指定 JSON 对象的名字, 比如将 Go 语言中的 Year 对应到 JSON 中的 released.
</p>

<p>
如果 value 中还有第二个值, 表示额外的选项, omitempty 选项表示 Go 语言结构体成员为空或零值时不生成 JSON 对象. 由于电影 Casablanca 中 Color 为 false, 所以不输出 JSON 的 color 项.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org460320c" class="outline-3">
<h3 id="org460320c">unmarshaling(解码)</h3>
<div class="outline-text-3" id="text-org460320c">
<p>
下面的例子将 JSON 格式的电影数据解码为一个 slice, 该 slice 的元素是 struct. 该例子中只解码 Title 成员:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var titles []struct{ Title string }
if err := json.Unmarshal(data, &amp;titles); err != nil {
    log.Fatalf("JSON unmarshaling failed: %s", err)
}
fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb426c67" class="outline-3">
<h3 id="orgb426c67">例子</h3>
<div class="outline-text-3" id="text-orgb426c67">
<p>
通过例子来演示, 如何通过 HTTP 接口发送 JSON 格式的请求, 并返回 JSON 格式的信息.
</p>

<p>
定义合适的类型和常量:
</p>
<div class="org-src-container">
<pre class="src src-Golang">// Package github provides a Go API for the GitHub issue tracker.
// See https://developer.github.com/v3/search/#search-issues.
package github

import "time"

const IssuesURL = "https://api.github.com/search/issues"

type IssuesSearchResult struct {
    TotalCount int `json:"total_count"`
    Items          []*Issue
}

type Issue struct {
    Number    int
    HTMLURL   string `json:"html_url"`
    Title     string
    State     string
    User      *User
    CreatedAt time.Time `json:"created_at"`
    Body      string    // in Markdown format
}

type User struct {
    Login   string
    HTMLURL string `json:"html_url"`
}
</pre>
</div>

<p>
SearchIssues() 发出一个 HTTP 请求, 然后解码返回的 JSON 格式的结果:
</p>
<div class="org-src-container">
<pre class="src src-Golang">package github

import (
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"
    "strings"
)

// SearchIssues queries the GitHub issue tracker.
func SearchIssues(terms []string) (*IssuesSearchResult, error) {
    q := url.QueryEscape(strings.Join(terms, " "))
    resp, err := http.Get(IssuesURL + "?q=" + q)
    if err != nil {
        return nil, err
    }

    // We must close resp.Body on all execution paths.
    // (Chapter 5 presents 'defer', which makes this simpler.)
    if resp.StatusCode != http.StatusOK {
        resp.Body.Close()
        return nil, fmt.Errorf("search query failed: %s", resp.Status)
    }

    var result IssuesSearchResult
    if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil {
        resp.Body.Close()
        return nil, err
    }
    resp.Body.Close()
    return &amp;result, nil
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-Golang">// Issues prints a table of GitHub issues matching the search terms.
package main

import (
    "fmt"
    "log"
    "os"

    "gopl.io/ch4/github"
)

func main() {
    result, err := github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("%d issues:\n", result.TotalCount)
    for _, item := range result.Items {
        fmt.Printf("#%-5d %9.9s %.55s\n",
            item.Number, item.User.Login, item.Title)
    }
}
</pre>
</div>

<p>
输出结果为:
</p>
<pre class="example">
$ go build gopl.io/ch4/issues
$ ./issues repo:golang/go is:open json decoder
13 issues:
#5680    eaigner encoding/json: set key converter on en/decoder
#6050  gopherbot encoding/json: provide tokenizer
#8658  gopherbot encoding/json: use bufio
#8462  kortschak encoding/json: UnmarshalText confuses json.Unmarshal
#5901        rsc encoding/json: allow override type marshaling
#9812  klauspost encoding/json: string tag not symmetric
#7872  extempora encoding/json: Encoder internally buffers full output
#9650    cespare encoding/json: Decoding gives errPhase when unmarshalin
#6716  gopherbot encoding/json: include field name in unmarshal error me
#6901  lukescott encoding/json, encoding/xml: option to treat unknown fi
#6384    joeshaw encoding/json: encode precise floating point integers u
#6647    btracey x/tools/cmd/godoc: display type kind of each named type
#4237  gjemiller encoding/base64: URLEncoding padding is optional
</pre>
</div>
</div>
</div>

<div id="outline-container-org92acafd" class="outline-2">
<h2 id="org92acafd">TEXT 模板 和 HTML 模板</h2>
<div class="outline-text-2" id="text-org92acafd">
<p>
text/template 和 html/template 等模板包提供了一个将变量值填充到一个 text 或 html 格式的模板的机制.
</p>

<p>
模板可以是一个文件, 也可以是一个字符串, 里面包含若干个 {{action}} 对象, action 将会触发其他的行为.
</p>
</div>

<div id="outline-container-org778d471" class="outline-3">
<h3 id="org778d471">TEXT 模板</h3>
<div class="outline-text-3" id="text-org778d471">
<p>
下面是一个简单的模板字符串:
</p>
<div class="org-src-container">
<pre class="src src-Golang">const templ = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`
</pre>
</div>

<p>
每个 action 前都有一个点操作符".", 表示当前值, 也就是最初被初始化为调用模板时的参数.
</p>

<p>
{{range .Items}} 和 {{end}} 对应一个循环 action, 因此它们之间的内容可能会被展开多次.
</p>

<p>
"|" 操作符表示将前一个表达式的值作为后一个函数的参数.
</p>

<p>
Title 这一行的函数就是 printf(), 这个函数在所有模板中都可以直接使用.
</p>

<p>
Age 这一行的函数就是 daysAgo(), 函数原型如下:
</p>
<div class="org-src-container">
<pre class="src src-Golang">func daysAgo(t time.Time) int {
    return int(time.Since(t).Hours() / 24)
}
</pre>
</div>

<p>
生成模板的输出有两个步骤:
</p>
<ul class="org-ul">
<li>分析模板并转化为内部表示</li>
<li>基于指定的输入执行模板</li>
</ul>

<p>
如下代码创建并分析上面定义的模板 templ:
</p>
<div class="org-src-container">
<pre class="src src-Golang">report, err := template.New("report").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ)
if err != nil {
    log.Fatal(err)
}
</pre>
</div>
<p>
首先使用 template.New() 创建并返回一个模板; 然后使用 Funcs() 将 daysAgo 等自定义函数注册到模板中; 最后调用 Parse() 分析模板.
</p>

<p>
接下来执行模板:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var report = template.Must(template.New("issuelist").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ))

func main() {
    result, err := github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    if err := report.Execute(os.Stdout, result); err != nil {
        log.Fatal(err)
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org49500f0" class="outline-3">
<h3 id="org49500f0">HTML 模板</h3>
<div class="outline-text-3" id="text-org49500f0">
<p>
暂时跳过, 用到再看.
</p>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-04-27</span>
            <span title="last modification date" class="post-info">2018-05-05</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/go">Go</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/";
         var disqus_url = "https://pinvondev.github.io/blog/Go/2018/04/27/go实战(四)-复合数据类型/ Or /blog/Go/go实战(四)-复合数据类型/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
            <script type="text/javascript" src="/media/js/love.js"></script>
</div>

  </div></body>
</html>
