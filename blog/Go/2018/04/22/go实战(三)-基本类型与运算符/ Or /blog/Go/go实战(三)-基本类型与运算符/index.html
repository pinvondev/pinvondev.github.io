<!DOCTYPE html>
<html lang="en">
<head>
  <title>Go实战(三) 基本类型与运算符 - Pinvon&#39;s Blog</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <meta name="author" content="Pinvon" />
  <meta name="description" content="&lt;Add description here&gt;" />
  <meta name="keywords" content="Go" />
  <style>
   #ds-thread #ds-reset .ds-comment-body p {color: #ffffff;}
   #ds-thread #ds-reset .ds-comment-body p a {color: #ff0;}
   #ds-thread #ds-reset .ds-comment-body p a:hover {color: #0ff;}
   #disqus_thread a {color: #00ffff;}
  </style>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/main.css" type="text/css"/>
  <link rel="stylesheet" href="https://pinvondev.github.io/media/css/comment.css" type="text/css"/>
</head>

  <body><div class="container">
<div>
  <header class="masthead">
    <h1 class="masthead-title"><a href="https://pinvondev.github.io/">Pinvon&#39;s Blog</a></h1>
    <p>所见, 所闻, 所思, 所想</p>
    <nav class="site-nav">
      <div class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z" fill="#ffff00"/>
          <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z" fill="#ffff00"/>
          <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z" fill="#ffff00"/>
        </svg>
      </div>
      <ul class="trigger">
        <li><a href="https://pinvondev.github.io/years/">Years</a></li>
        <li><a href="https://pinvondev.github.io/authors/">Authors</a></li>
        <li><a href="https://pinvondev.github.io/tags/">Tags</a></li>
        <li><a href="https://pinvondev.github.io/about/">About</a></li>
        <li><a href="https://github.com/pinvondev">Github</a></li>
        <li><a href="https://pinvondev.github.io/rss.xml">RSS</a></li>
      </ul>
    </nav>
    <form method="get" id="searchform" action="http://www.google.com/search">
      <input type="text" class="field" name="q" id="s" placeholder="Search">
      <input type="hidden" name="as_sitesearch" value="pinvondev.github.io">
    </form>
  </header>
</div>

<div>
<div class="post">
<h1 class="title">Go实战(三) 基本类型与运算符</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org37b5ee8">1. 注</a></li>
<li><a href="#orgdf862ff">2. 基本类型</a>
<ul>
<li><a href="#orgb7b4cca">2.1. 概述</a>
<ul>
<li><a href="#orgded4668">2.1.1. 整型</a>
<ul>
<li><a href="#org157030d">2.1.1.1. 注意</a></li>
<li><a href="#orgb77d39b">2.1.1.2. 表示范围</a></li>
<li><a href="#orgd33ac7f">2.1.1.3. 格式化输出</a></li>
</ul>
</li>
<li><a href="#org5fb98e4">2.1.2. 浮点数</a>
<ul>
<li><a href="#org96da40a">2.1.2.1. 格式化输出</a></li>
<li><a href="#orge352ed9">2.1.2.2. math 包</a></li>
</ul>
</li>
<li><a href="#org3761cb1">2.1.3. 复数</a>
<ul>
<li><a href="#org60e7cd0">2.1.3.1. math/cmplx 包</a></li>
</ul>
</li>
<li><a href="#org5ee5d4e">2.1.4. 布尔型</a>
<ul>
<li><a href="#orgfe12c19">2.1.4.1. 短路逻辑</a></li>
</ul>
</li>
<li><a href="#org77e0457">2.1.5. 字符串</a>
<ul>
<li><a href="#org8b70761">2.1.5.1. 子字符串操作 s[i:j]</a></li>
<li><a href="#orgad38299">2.1.5.2. 字符串不可修改</a></li>
<li><a href="#orgf43b7ab">2.1.5.3. 字符串拼接</a></li>
<li><a href="#orgf9f22f4">2.1.5.4. Unicode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org979546f">2.2. 类型转换</a></li>
<li><a href="#orga584ff6">2.3. 习惯</a></li>
</ul>
</li>
<li><a href="#org3390a16">3. 运算符</a>
<ul>
<li><a href="#org1875323">3.1. 取模运算符</a></li>
<li><a href="#org75ec8a2">3.2. 溢出</a></li>
<li><a href="#org7d15650">3.3. 位运算符</a>
<ul>
<li><a href="#org6541a92">3.3.1. 例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org37b5ee8" class="outline-2">
<h2 id="org37b5ee8"><span class="section-number-2">1</span> 注</h2>
<div class="outline-text-2" id="text-1">
<p>
学习自: Go 语言圣经
</p>
</div>
</div>

<div id="outline-container-orgdf862ff" class="outline-2">
<h2 id="orgdf862ff"><span class="section-number-2">2</span> 基本类型</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgb7b4cca" class="outline-3">
<h3 id="orgb7b4cca"><span class="section-number-3">2.1</span> 概述</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Go 语言是一种静态类型的编程语言, 所以编译器在编译时就要知道每个值的类型, 这样编译器就知道要为这个值分配多少内存, 并且知道这段分配的内存表示什么.
</p>

<p>
提前知道值的类型有很多好处, 如, 可以进一步优化代码, 提高执行效率, 等等.
</p>

<p>
Go 的基本类型包括数值型, 字符串, 布尔型.
</p>

<p>
数值型包括几种不同大小的整型数, 浮点数, 复数.
</p>
</div>

<div id="outline-container-orgded4668" class="outline-4">
<h4 id="orgded4668"><span class="section-number-4">2.1.1</span> 整型</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Go 语言提供了有符号和无符号类型的整数运算.
</p>

<p>
int8, int16, int32, int64 是四种有符号整型; uint8, uint16, uint32, uint64 是四种无符号整型.
</p>

<p>
另外, 还有 int 和 uint. int 和 uint 的大小会根据当前机器的系统架构自动判定, 一般是 32bit 或 64bit. 
</p>

<p>
rune 类型用于表示一个 Unicode 码点, 它与 int32 等价, 名称可以互换使用.
</p>

<p>
byte 类型与 int8 类型也是等价的, 可以互换使用.
</p>

<p>
uintptr 类型用于存放指针, 它与 uint 类型的范围相同, 根据系统架构来确定.
</p>
</div>

<div id="outline-container-org157030d" class="outline-5">
<h5 id="org157030d"><span class="section-number-5">2.1.1.1</span> 注意</h5>
<div class="outline-text-5" id="text-2-1-1-1">
<p>
即使根据系统架构确定了 int 类型的大小为 32bit, 我们也不能认为 int 类型与 int32 类型相同, 在需要将 int 当作 int32 使用的地方, 需要进行显式的类型转换.
</p>
</div>
</div>

<div id="outline-container-orgb77d39b" class="outline-5">
<h5 id="orgb77d39b"><span class="section-number-5">2.1.1.2</span> 表示范围</h5>
<div class="outline-text-5" id="text-2-1-1-2">
<p>
对于有符号整数, 采用 2 的补码形式表示, 即最高位表示符号位, 所以表示范围为 \(-2^{n-1} ~2^{n-1}-1\)
</p>

<p>
对于无符号整数, 所有的位都用于表示非负数, 因此表示范围是 \(0 ~ 2^{n-1}\)
</p>
</div>
</div>

<div id="outline-container-orgd33ac7f" class="outline-5">
<h5 id="orgd33ac7f"><span class="section-number-5">2.1.1.3</span> 格式化输出</h5>
<div class="outline-text-5" id="text-2-1-1-3">
<p>
%d: 输出十进制数
</p>

<p>
%o: 输出八进制数
</p>

<p>
%x: 输出十六进制数
</p>

<p>
%[1]: 使用第1个操作数
</p>

<p>
%#: 输出 0, 0x 等前缀
</p>

<pre class="example">
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
</pre>

<p>
%q: 输出带单引号的字符
</p>

<pre class="example">
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
</pre>
</div>
</div>
</div>

<div id="outline-container-org5fb98e4" class="outline-4">
<h4 id="org5fb98e4"><span class="section-number-4">2.1.2</span> 浮点数</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
Go 语言的浮点数有 float32 和 float64, 它们符合 IEEE754 标准. 浮点数的极限值可以在 math 包中找到. 如: math.MaxFload32 是 float32 能表示的最大数, 大约为 3.4e38; math.MaxFloat64 是 float64 能表示的最大数, 大约是 1.8e308.
</p>

<p>
一般我们优先使用 float64, 根据 IEEE754 标准, float32 所能表示的正整数并不是很大, 因为 32bit 的有效位是 23bit, 剩下的要用于指数和符号位, 当整数大于 23bit 能表达的范围时, float32 将出现误差. 如:
</p>
<pre class="example">
var f float32 = 16777216 // 1 &lt;&lt; 24
fmt.Println(f == f+1)    // "true"!
</pre>
</div>

<div id="outline-container-org96da40a" class="outline-5">
<h5 id="org96da40a"><span class="section-number-5">2.1.2.1</span> 格式化输出</h5>
<div class="outline-text-5" id="text-2-1-2-1">
<p>
格式化输出浮点型时, 我们一般使用 %f, 如 %8.3f 表示输出 8 个字符宽度, 小数保留 3 位.
</p>
</div>
</div>

<div id="outline-container-orge352ed9" class="outline-5">
<h5 id="orge352ed9"><span class="section-number-5">2.1.2.2</span> math 包</h5>
<div class="outline-text-5" id="text-2-1-2-2">
<p>
math 包提供了大量常用的数学函数和 IEEE754 浮点数标准中定义的特殊值的创建和测试: 正无穷大, 负无穷大, 非数 NaN(用于表示无效的除法操作, 如 0/0). 如:
</p>
<pre class="example">
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
</pre>

<p>
math.IsNaN() 可以测试一个数是否为非数 NaN, math.Nan() 返回非数对应的值. 但是要注意, NaN 和任何数都是不相等的, 包括它自己:
</p>
<pre class="example">
nan := math.NaN()
fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // "false false false"
</pre>
</div>
</div>
</div>

<div id="outline-container-org3761cb1" class="outline-4">
<h4 id="org3761cb1"><span class="section-number-4">2.1.3</span> 复数</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
Go 语言提供了两种精度的复数类型: complex64 和 complex 128, 分别对应 float32 和 float64 两种浮点数精度.
</p>

<p>
内置的 complex() 用于构建复数, 内置的 real() 和 image() 分别返回复数的实部和虚部. 如:
</p>
<pre class="example">
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
</pre>

<p>
如果数字后面直接紧跟一个 i, 则表示它是一个复数的虚部, 而实部是0:
</p>
<pre class="example">
fmt.Println(1i * 1i)  // "(-1+0i)", i^2 = -1
</pre>

<p>
我们也可以用简短变量声明的方式, 来自然的书写复数:
</p>
<pre class="example">
x := 1 + 2i
y := 3 + 4i
</pre>
</div>

<div id="outline-container-org60e7cd0" class="outline-5">
<h5 id="org60e7cd0"><span class="section-number-5">2.1.3.1</span> math/cmplx 包</h5>
<div class="outline-text-5" id="text-2-1-3-1">
<p>
math/cmplx 包提供了许多复数处理的函数, 如求复数的平方根函数和求幂函数.
</p>
</div>
</div>
</div>

<div id="outline-container-org5ee5d4e" class="outline-4">
<h4 id="org5ee5d4e"><span class="section-number-4">2.1.4</span> 布尔型</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
布尔型的值只有 true 和 false 两种, 它们并不会隐式转化成数字 0 和 1.
</p>
</div>

<div id="outline-container-orgfe12c19" class="outline-5">
<h5 id="orgfe12c19"><span class="section-number-5">2.1.4.1</span> 短路逻辑</h5>
<div class="outline-text-5" id="text-2-1-4-1">
<p>
布尔值可以和 &amp;&amp; 和 || 这两个操作符结合. 如果运算符左边的值已经可以确定整个布尔表达式的值, 那么运算符右边的值将不再被求值, 如:
</p>
<pre class="example">
a := 5
b := 4
if a&lt;0 &amp;&amp; b&lt;0 { ... }
</pre>
<p>
由于 &amp;&amp; 操作符需要两个值都为真, 结果才返回真. 所以当其判断 a&lt;0 时, 已经知道 &amp;&amp; 左边的值为假了, 所以结果肯定为假, 右边的值不需要再判断. || 操作符的短路逻辑类似.
</p>

<p>
合理安排语句, 使用短路逻辑可以提高程序效率.
</p>
</div>
</div>
</div>

<div id="outline-container-org77e0457" class="outline-4">
<h4 id="org77e0457"><span class="section-number-4">2.1.5</span> 字符串</h4>
<div class="outline-text-4" id="text-2-1-5">
<p>
字符串是一个不可改变的字节序列. 文本字符串通常被解释为采用 UTF-8 编码的 Unicode 码点(rune)序列.
</p>

<p>
内置的 len() 返回的是字符串中的 <b>字节</b> 数目, 而不是 rune 字符数目. 索引操作 s[i] 返回的是第 i 个字节的字节值, 而不是字符值. 如:
</p>
<pre class="example">
s := "你好"
fmt.Println(len(s))  // 6
fmt.Println(s[2])  // 160
</pre>
<p>
可以看出, 其长度是 6, 而不是字符数目 2. 第 i 个字节并不一定是字符串的第 i 个字符, 因为对于非 ASCII 字符的 UTF-8 编码会要两个或多个字节.
</p>

<p>
如果试图访问超出字符串索引范围的字节, 将导致 panic 异常, 如访问 s[10].
</p>
</div>

<div id="outline-container-org8b70761" class="outline-5">
<h5 id="org8b70761"><span class="section-number-5">2.1.5.1</span> 子字符串操作 s[i:j]</h5>
<div class="outline-text-5" id="text-2-1-5-1">
<p>
s[i:j] 可以得到 [i,j) 之间的字节, 并生成一个新字符串. 如:
</p>
<pre class="example">
s := "你好"
fmt.Println(s[0:1])  // �
</pre>
<p>
注意, 中文在 UTF-8 编码中, 一个字符占用 3 个字节, 所以如果只截第 1 个字节, 得到的字符将是乱码.
</p>

<p>
如果忽略 i, 将使用 0 作为开始位置; 如果忽略 j, 将使用 len(s) 作为结束位置.
</p>
</div>
</div>

<div id="outline-container-orgad38299" class="outline-5">
<h5 id="orgad38299"><span class="section-number-5">2.1.5.2</span> 字符串不可修改</h5>
<div class="outline-text-5" id="text-2-1-5-2">
<p>
注意, 字符串是不可修改的, 所以试图修改字符串内部数据的操作, 将会报错:
</p>
<pre class="example">
s := "left foot"                                                                                                                           
s[0] = 'L' // compile error: cannot assign to s[0] 
</pre>
</div>
</div>

<div id="outline-container-orgf43b7ab" class="outline-5">
<h5 id="orgf43b7ab"><span class="section-number-5">2.1.5.3</span> 字符串拼接</h5>
<div class="outline-text-5" id="text-2-1-5-3">
<ul class="org-ul">
<li>操作符将两个字符串拼接成一个新的字符串. 如:</li>
</ul>
<pre class="example">
s := "left foot"
t := s
s += ", right foot"
fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"
</pre>
<p>
看起来, t 是得到了 s 的一份拷贝, 但实际上, 由于字符串的不可修改性, 所以如果两个字符串共享相同的底层数据是安全的.
</p>

<p>
于是, 复制任何长度的字符串的代价是低廉的. 如下图所示, 一个字符串 s 和相应的子字符串切片 s[7:] 的操作可以安全地共享相同的内存, 代价低廉. 复制和切片都没有必要分配新的内存.
</p>


<div class="figure">
<p><img src="https://pinvondev.github.io/assets/blog/Go/2018/04/22/go实战(三)-基本类型与运算符/ Or /blog/Go/go实战(三)-基本类型与运算符/5.png" alt="5.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf9f22f4" class="outline-5">
<h5 id="orgf9f22f4"><span class="section-number-5">2.1.5.4</span> Unicode</h5>
<div class="outline-text-5" id="text-2-1-5-4">
<p>
Go 语言的源文件和文本字符串都是以 UTF-8 编码方式进行处理的, 所以我们可以把 Unicode 码点也写到字符串面值中.
</p>

<p>
ASCII 字符集: 使用 7bit 来表示 128 个字符.
</p>

<p>
但是世界上的字符不止 128 个, 还有汉字, 日文, 等等. 所以需要使用另一个字符集来表示所有的符号系统, 这就是 Unicode 的由来.
</p>

<p>
Unicode 为每个符号都分配一个唯一的 Unicode 码点, Unicode 码点对应 Go 语言的 rune 整数类型(与 int32 等价).
</p>

<p>
UTF-8 是 Unicode 的一个实现方式. 它是一种变长的编码方式, 可以使用 1~4 个字节表示一个符号, 当字符在 ASCII 的范围时, 就用一个字节表示, 这样可以节点空间. 另外, 在 Unicode 里, 一个中文字符占 2 个字节, 而在 UTF-8 里, 一个中文字符占 3 个字节.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org979546f" class="outline-3">
<h3 id="org979546f"><span class="section-number-3">2.2</span> 类型转换</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在 Go 语言中, 需要显式地将一个值从一种类型转化成另一种类型. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges
fmt.Println(compote)
</pre>
</div>
<p>
编译时将会报错. 我们可以改成:
</p>
<div class="org-src-container">
<pre class="src src-Golang">...
var compote = int(apples) + int(oranges)
...
</pre>
</div>

<p>
如果将大尺寸的数据类型转化成小尺寸的数据类型, 如将浮点数转成整数, 有可能会改变数值或丢失精度. 如:
</p>
<div class="org-src-container">
<pre class="src src-Golang">f := 3.141 // a float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"
</pre>
</div>
</div>
</div>

<div id="outline-container-orga584ff6" class="outline-3">
<h3 id="orga584ff6"><span class="section-number-3">2.3</span> 习惯</h3>
<div class="outline-text-3" id="text-2-3">
<p>
如果没有特殊需求, 我们会倾向于使用有符号类型. 举个例子:
</p>
<div class="org-src-container">
<pre class="src src-Golang">medals := []string{"gold", "silver", "bronze"}
for i := len(medals) - 1; i &gt;= 0; i-- {
    fmt.Println(medals[i]) // "bronze", "silver", "gold"
}
</pre>
</div>

<p>
如果 len() 返回的是 uint 类型, 则 len(medals)-1 永远不会小于 0, 并且溢出时变成 uint 类型的最大值, 访问 medals[i] 时出错, 因为在试图访问一个 slice 范围以外的元素.
</p>

<p>
只有在位运算时, 才会使用无符号类型. 如 bit 集合, 分析二进制文件格式, 哈希, 加密等操作.
</p>
</div>
</div>
</div>

<div id="outline-container-org3390a16" class="outline-2">
<h2 id="org3390a16"><span class="section-number-2">3</span> 运算符</h2>
<div class="outline-text-2" id="text-3">
<p>
所有二元运算符按优先级递减的顺序(同一排的优先级相同)排列如下:
</p>
<pre class="example">
*	/	%	&lt;&lt;	&gt;&gt;	&amp;	&amp;^
+	-	|	^	+=
==	!=	&lt;	&lt;=	&gt;	&gt;=
&amp;&amp;
||
</pre>
</div>

<div id="outline-container-org1875323" class="outline-3">
<h3 id="org1875323"><span class="section-number-3">3.1</span> 取模运算符</h3>
<div class="outline-text-3" id="text-3-1">
<p>
在不同的语言中, % 运算符的行为可能不同. 在 Go 语言中, % 运算符的符号和被取模数(% 前面的数字)的符号一致. 如 -5%3 和 -5%-3 结果都是 -2.
</p>
</div>
</div>

<div id="outline-container-org75ec8a2" class="outline-3">
<h3 id="org75ec8a2"><span class="section-number-3">3.2</span> 溢出</h3>
<div class="outline-text-3" id="text-3-2">
<p>
如果运算结果需要更多位数才能表示, 就会导致溢出.
</p>

<p>
溢出时, 超出的高 bit 位部分将被丢弃. 因此, 有可能出现这种情况: 有符号类型, 超出的高位被截掉之后, 如果剩下的比特中, 最左边的是1, 最终结果就可能成了负数.
</p>
</div>
</div>

<div id="outline-container-org7d15650" class="outline-3">
<h3 id="org7d15650"><span class="section-number-3">3.3</span> 位运算符</h3>
<div class="outline-text-3" id="text-3-3">
<p>
^ 当作二元运算符时, 表示按位异或; 当作一元运算符时, 表示按位取反.
</p>
</div>

<div id="outline-container-org6541a92" class="outline-4">
<h4 id="org6541a92"><span class="section-number-4">3.3.1</span> 例子</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">
<pre class="src src-Golang">var x uint8 = 1&lt;&lt;3 | 3&lt;&lt;5
fmt.Printf("%08b", x)
</pre>
</div>
<p>
输出: 01101000
</p>

<p>
解析: x&lt;&lt;n 中, n 必须是无符号数, x 则有/无符号位都可以. 我们可以用笔来演算, 将 x 转成二进制数, 低位对齐, 然后根据 n 来确定左移的位数. 如:
</p>
<pre class="example">
3&lt;&lt;5

// 开始的位置
       11
0000 0000

// 左移 5 位后的位置
 11       
0000 0000

// 得到的数
0110 0000
</pre>

<p>
1&lt;&lt;3 | 3&lt;&lt;5: 将 1&lt;&lt;3 和 3&lt;&lt;5 的结果用或操作符运算.
</p>

<p>
Printf() 的 %b: 打印二进制格式的数字, %08b 表示至少打印 8 个字符宽度, 不足的前缀部分用 0 填充.
</p>

<p>
再看 &amp;^ 的例子:
</p>
<div class="org-src-container">
<pre class="src src-Golang">var x uint8 = 1&lt;&lt;2 | 3&lt;&lt;5
var y uint8 = 1&lt;&lt;1 | 1&lt;&lt;2
fmt.Printf("%08b\n", x)
fmt.Printf("%08b\n", y)
fmt.Printf("%08b\n", x&amp;^y)
</pre>
</div>

<p>
输出:
</p>
<pre class="example">
01100100
00000110
01100000
</pre>

<p>
可以看出, x &amp;^ y 的意思是, y 中如果某个比特位为 1, 则 x 中相应的比特位清空成 0.
</p>
</div>
</div>
</div>
</div>

</div>
</div>
<div>
        <div class="post-meta">
            <span title="post date" class="post-info">2018-04-22</span>
            <span title="last modification date" class="post-info">2018-04-23</span>
            <span title="tags" class="post-info">:<a href="https://pinvondev.github.io/tags/go">Go</a>:</span>
            <span title="author" class="post-info"><a href="mailto:pinvon@Inspiron">Pinvon</a></span>
        </div>
    <script src="https://pinvondev.github.io/media/js/jquery-2.1.3.min.js"></script>
        <section>
            <h1>Comments</h1>
            <div id="comment-wrap">
                    <a class="disqus_label">使用 Disqus 评论</a>
    </ul>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
         //var disqus_developer = 1;
         var preempt_signal=false;
         var disqus_identifier = "/blog/Go/2018/04/22/go实战(三)-基本类型与运算符/ Or /blog/Go/go实战(三)-基本类型与运算符/";
         var disqus_url = "https://pinvondev.github.io/blog/Go/2018/04/22/go实战(三)-基本类型与运算符/ Or /blog/Go/go实战(三)-基本类型与运算符/";
         var disqus_shortname = 'pinvon';
         /* * * DON'T EDIT BELOW THIS LINE * * */
         (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
             $('#disqus_thread').css('display','none');
         })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    <script>
     /* comments */
     var ego_disqus_thread=$('#disqus_thread');
     var ego_ds_label=$('.ds-thread');
     $('.disqus_label').click(function(){
         ego_disqus_thread.show();
         ego_ds_label.hide();
     });
     $('.ds-label').click(function(){
         ego_disqus_thread.hide();
         ego_ds_label.show();
     });
    </script>
        </section>
    <script src="https://pinvondev.github.io/media/js/main.js"></script>
    <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.x(<a href="http://orgmode.org">Org mode</a> 9.x)</p>
        <p>
            Copyright &copy; 2014 - <span id="footerYear"></span> <a href="mailto:pinvon@Inspiron">Pinvon</a>
            &nbsp;&nbsp;-&nbsp;&nbsp;
            Powered by <a href="https://github.com/emacs-china/ego" target="_blank">EGO</a><br/>
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" style="border-width:0" alt="Creative Commons License" class="center"></a>
            <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
    </div>
            </div>
            <script type="text/javascript"
                    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG">
            </script>
            <script type="text/x-mathjax-config">
             MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });
            </script>
</div>

  </div></body>
</html>
